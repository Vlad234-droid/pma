/* tslint:disable */
/* eslint-disable */
/**
 * PMA API
 * Documentation PMA API v1.0
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountType'?: AccountAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'iamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'lastLogin'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'role'?: number;
    /**
     * 
     * @type {Array<Role>}
     * @memberof Account
     */
    'roles'?: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'status'?: AccountStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AccountAccountTypeEnum {
    User = 'user'
}
/**
    * @export
    * @enum {string}
    */
export enum AccountStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddressList
     */
    'lines'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'postcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'city'?: string;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'target'?: string;
    /**
     * 
     * @type {Array<ErrorDetail>}
     * @memberof ApiError
     */
    'details'?: Array<ErrorDetail>;
}
/**
 * 
 * @export
 * @interface AuditOrgObjectiveReport
 */
export interface AuditOrgObjectiveReport {
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof AuditOrgObjectiveReport
     */
    'updatedBy'?: ColleagueSimple;
    /**
     * 
     * @type {string}
     * @memberof AuditOrgObjectiveReport
     */
    'updatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditOrgObjectiveReport
     */
    'action'?: AuditOrgObjectiveReportActionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AuditOrgObjectiveReportActionEnum {
    SaveAsDraft = 'SAVE_AS_DRAFT',
    Publish = 'PUBLISH',
    Unpublish = 'UNPUBLISH'
}

/**
 * 
 * @export
 * @interface ChangeAccountStatusRequest
 */
export interface ChangeAccountStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountStatusRequest
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountStatusRequest
     */
    'status'?: ChangeAccountStatusRequestStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ChangeAccountStatusRequestStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface Colleague
 */
export interface Colleague {
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'colleagueUUID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'employeeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'countryCode'?: string;
    /**
     * 
     * @type {Effectivity}
     * @memberof Colleague
     */
    'effectivity'?: Effectivity;
    /**
     * 
     * @type {ExternalSystems}
     * @memberof Colleague
     */
    'externalSystems'?: ExternalSystems;
    /**
     * 
     * @type {Profile}
     * @memberof Colleague
     */
    'profile'?: Profile;
    /**
     * 
     * @type {Contact}
     * @memberof Colleague
     */
    'contact'?: Contact;
    /**
     * 
     * @type {ServiceDates}
     * @memberof Colleague
     */
    'serviceDates'?: ServiceDates;
    /**
     * 
     * @type {Array<WorkRelationship>}
     * @memberof Colleague
     */
    'workRelationships'?: Array<WorkRelationship>;
}
/**
 * 
 * @export
 * @interface ColleagueChangeEventPayload
 */
export interface ColleagueChangeEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'eventType'?: ColleagueChangeEventPayloadEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ColleagueChangeEventPayload
     */
    'changedAttributes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'colleagueUUID'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ColleagueChangeEventPayloadEventTypeEnum {
    Joiner = 'Joiner',
    Leaver = 'Leaver',
    Mover = 'Mover',
    Reinstatement = 'Reinstatement'
}

/**
 * 
 * @export
 * @interface ColleagueEntity
 */
export interface ColleagueEntity {
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'email'?: string;
    /**
     * 
     * @type {WorkLevel}
     * @memberof ColleagueEntity
     */
    'workLevel'?: WorkLevel;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'primaryEntity'?: string;
    /**
     * 
     * @type {Country}
     * @memberof ColleagueEntity
     */
    'country'?: Country;
    /**
     * 
     * @type {Department}
     * @memberof ColleagueEntity
     */
    'department'?: Department;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'salaryFrequency'?: string;
    /**
     * 
     * @type {Job}
     * @memberof ColleagueEntity
     */
    'job'?: Job;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'iamSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'iamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'managerUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'employmentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'hireDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'leavingDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ColleagueEntity
     */
    'manager'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'locationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'legalEntity'?: string;
}
/**
 * 
 * @export
 * @interface ColleagueProfile
 */
export interface ColleagueProfile {
    /**
     * 
     * @type {Colleague}
     * @memberof ColleagueProfile
     */
    'colleague'?: Colleague;
    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof ColleagueProfile
     */
    'profileAttributes'?: Array<TypedAttribute>;
}
/**
 * 
 * @export
 * @interface ColleagueSimple
 */
export interface ColleagueSimple {
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'businessType'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueSimple
     */
    'lineManager'?: ColleagueSimple;
}
/**
 * 
 * @export
 * @interface ColleagueView
 */
export interface ColleagueView {
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'businessType'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueView
     */
    'lineManager'?: ColleagueSimple;
    /**
     * 
     * @type {Array<SimplifiedReview>}
     * @memberof ColleagueView
     */
    'reviews'?: Array<SimplifiedReview>;
    /**
     * 
     * @type {Array<TimelinePoint>}
     * @memberof ColleagueView
     */
    'timeline'?: Array<TimelinePoint>;
}
/**
 * 
 * @export
 * @interface ColumnMetadata
 */
export interface ColumnMetadata {
    /**
     * 
     * @type {string}
     * @memberof ColumnMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColumnMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColumnMetadata
     */
    'type'?: ColumnMetadataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ColumnMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColumnMetadata
     */
    'code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ColumnMetadataTypeEnum {
    Blank = 'BLANK',
    Error = 'ERROR',
    String = 'STRING',
    Boolean = 'BOOLEAN',
    Number = 'NUMBER',
    Date = 'DATE',
    Integer = 'INTEGER',
    Decimal = 'DECIMAL'
}

/**
 * 
 * @export
 * @interface CompositePMCycleMetadataResponse
 */
export interface CompositePMCycleMetadataResponse {
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof CompositePMCycleMetadataResponse
     */
    'metadata'?: PMCycleMetadata;
    /**
     * 
     * @type {Array<PMForm>}
     * @memberof CompositePMCycleMetadataResponse
     */
    'forms'?: Array<PMForm>;
}
/**
 * 
 * @export
 * @interface CompositePMCycleResponse
 */
export interface CompositePMCycleResponse {
    /**
     * 
     * @type {PMCycle}
     * @memberof CompositePMCycleResponse
     */
    'cycle'?: PMCycle;
    /**
     * 
     * @type {Array<PMForm>}
     * @memberof CompositePMCycleResponse
     */
    'forms'?: Array<PMForm>;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'property'?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'operand'?: ConditionOperandEnum;
    /**
     * 
     * @type {object}
     * @memberof Condition
     */
    'value'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConditionOperandEnum {
    Equals = 'EQUALS',
    NotEquals = 'NOT_EQUALS',
    Contains = 'CONTAINS',
    NotContains = 'NOT_CONTAINS',
    In = 'IN',
    NotIn = 'NOT_IN',
    LessThan = 'LESS_THAN',
    LessThanEquals = 'LESS_THAN_EQUALS',
    GreaterThan = 'GREATER_THAN',
    GreaterThanEquals = 'GREATER_THAN_EQUALS',
    Like = 'LIKE',
    Null = 'NULL'
}

/**
 * Target organisation tree level.
 * @export
 * @interface ConfigEntry
 */
export interface ConfigEntry {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'name'?: string;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof ConfigEntry
     */
    'type'?: GeneralDictionaryItem;
    /**
     * 
     * @type {number}
     * @memberof ConfigEntry
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'parentUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'compositeKey'?: string;
}
/**
 * 
 * @export
 * @interface ConfigEntryResponse
 */
export interface ConfigEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof ConfigEntryResponse
     */
    'type'?: GeneralDictionaryItem;
    /**
     * 
     * @type {number}
     * @memberof ConfigEntryResponse
     */
    'version'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigEntryResponse
     */
    'root'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'compositeKey'?: string;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'workPhoneNumber'?: string;
    /**
     * 
     * @type {AddressList}
     * @memberof Contact
     */
    'addresses'?: AddressList;
}
/**
 * 
 * @export
 * @interface ContractType
 */
export interface ContractType {
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'sourceCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'sourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'accountType'?: CreateAccountRequestAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'iamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'status'?: CreateAccountRequestStatusEnum;
    /**
     * 
     * @type {object}
     * @memberof CreateAccountRequest
     */
    'role'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateAccountRequestAccountTypeEnum {
    User = 'user'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateAccountRequestStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'businessType'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentInfo
 */
export interface DeploymentInfo {
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'deploymentTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface Effectivity
 */
export interface Effectivity {
    /**
     * 
     * @type {string}
     * @memberof Effectivity
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof Effectivity
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventName'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Event
     */
    'eventProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventCreationDate'?: string;
    /**
     * 
     * @type {Event}
     * @memberof Event
     */
    'callbackEvent'?: Event;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'callbackServiceURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventPriority'?: EventEventPriorityEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EventEventPriorityEnum {
    Highest = 'HIGHEST',
    HighH = 'HIGH_H',
    High = 'HIGH',
    HighL = 'HIGH_L',
    NormalH = 'NORMAL_H',
    Normal = 'NORMAL',
    NormalL = 'NORMAL_L',
    LowH = 'LOW_H',
    Low = 'LOW',
    LowL = 'LOW_L',
    Lowest = 'LOWEST'
}

/**
 * 
 * @export
 * @interface ExtendedRestResponseListAccount
 */
export interface ExtendedRestResponseListAccount {
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedRestResponseListAccount
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Account>}
     * @memberof ExtendedRestResponseListAccount
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof ExtendedRestResponseListAccount
     */
    'errors'?: Array<ApiError>;
    /**
     * 
     * @type {string}
     * @memberof ExtendedRestResponseListAccount
     */
    'nextPage'?: string;
}
/**
 * 
 * @export
 * @interface ExternalSystems
 */
export interface ExternalSystems {
    /**
     * 
     * @type {string}
     * @memberof ExternalSystems
     */
    'sourceSystem'?: string;
    /**
     * 
     * @type {IamSourceSystem}
     * @memberof ExternalSystems
     */
    'iam'?: IamSourceSystem;
}
/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'uuid'?: string;
    /**
     * Author. Colleague from whom feedback is written or requested.
     * @type {string}
     * @memberof Feedback
     */
    'colleagueUuid': string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof Feedback
     */
    'colleagueProfile'?: ColleagueProfile;
    /**
     * Colleague to whom feedback is given.
     * @type {string}
     * @memberof Feedback
     */
    'targetColleagueUuid': string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof Feedback
     */
    'targetColleagueProfile'?: ColleagueProfile;
    /**
     * Target type: GOAL, OBJECTIVE, VALUE_BEHAVIOR, OTHER.
     * @type {string}
     * @memberof Feedback
     */
    'targetType'?: FeedbackTargetTypeEnum;
    /**
     * Object identifier that is feedback given on/to or requested about/from.
     * @type {string}
     * @memberof Feedback
     */
    'targetId'?: string;
    /**
     * Checkbox. False for Unread feedback.
     * @type {boolean}
     * @memberof Feedback
     */
    'read'?: boolean;
    /**
     * Status: DRAFT, SUBMITTED, PENDING, COMPLETED.
     * @type {string}
     * @memberof Feedback
     */
    'status': FeedbackStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'createdTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'updatedTime'?: string;
    /**
     * 
     * @type {Set<FeedbackItem>}
     * @memberof Feedback
     */
    'feedbackItems'?: Set<FeedbackItem>;
}

/**
    * @export
    * @enum {string}
    */
export enum FeedbackTargetTypeEnum {
    Goal = 'GOAL',
    Objective = 'OBJECTIVE',
    ValueBehavior = 'VALUE_BEHAVIOR',
    Other = 'OTHER'
}
/**
    * @export
    * @enum {string}
    */
export enum FeedbackStatusEnum {
    Draft = 'DRAFT',
    Submitted = 'SUBMITTED',
    Pending = 'PENDING',
    Completed = 'COMPLETED'
}

/**
 * The Feedback Item. Answers for questions, comments or free form feedback.
 * @export
 * @interface FeedbackItem
 */
export interface FeedbackItem {
    /**
     * 
     * @type {string}
     * @memberof FeedbackItem
     */
    'uuid'?: string;
    /**
     * Item code. For example, whatWellDone, whatFocusOn, comment or question1, etc.
     * @type {string}
     * @memberof FeedbackItem
     */
    'code': string;
    /**
     * Body of feedback item. Answer for question or comment.
     * @type {string}
     * @memberof FeedbackItem
     */
    'content'?: string;
    /**
     * Link to feedback
     * @type {string}
     * @memberof FeedbackItem
     */
    'feedbackUuid'?: string;
}
/**
 * 
 * @export
 * @interface FileType
 */
export interface FileType {
    /**
     * 
     * @type {number}
     * @memberof FileType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'ownerColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'parentFolderUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface GeneralDictionaryItem
 */
export interface GeneralDictionaryItem {
    /**
     * 
     * @type {number}
     * @memberof GeneralDictionaryItem
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GeneralDictionaryItem
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeneralDictionaryItem
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Grade
 */
export interface Grade {
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'type'?: HealthTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'status'?: HealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'checked'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Health
     */
    'error'?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum HealthTypeEnum {
    Service = 'SERVICE',
    Component = 'COMPONENT',
    Dependency = 'DEPENDENCY'
}
/**
    * @export
    * @enum {string}
    */
export enum HealthStatusEnum {
    Ok = 'Ok',
    Fail = 'Fail',
    Degraded = 'Degraded'
}

/**
 * 
 * @export
 * @interface IamSourceSystem
 */
export interface IamSourceSystem {
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface ImportError
 */
export interface ImportError {
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'requestUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ImportReport
 */
export interface ImportReport {
    /**
     * 
     * @type {string}
     * @memberof ImportReport
     */
    'requestUuid'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof ImportReport
     */
    'imported'?: Set<string>;
    /**
     * 
     * @type {Set<ImportError>}
     * @memberof ImportReport
     */
    'skipped'?: Set<ImportError>;
    /**
     * 
     * @type {Set<ImportError>}
     * @memberof ImportReport
     */
    'warn'?: Set<ImportError>;
}
/**
 * 
 * @export
 * @interface ImportRequest
 */
export interface ImportRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'status'?: ImportRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'lastUpdateTime'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ImportRequestStatusEnum {
    Registered = 'REGISTERED',
    InProgress = 'IN_PROGRESS',
    Processed = 'PROCESSED',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'costCategory'?: string;
}
/**
 * 
 * @export
 * @interface LegalEmployer
 */
export interface LegalEmployer {
    /**
     * 
     * @type {number}
     * @memberof LegalEmployer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LegalEmployer
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'fileName'?: string;
    /**
     * 
     * @type {FileType}
     * @memberof ModelFile
     */
    'type'?: FileType;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'status'?: ModelFileStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'fileDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'uuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'version'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'fileLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createdTime'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelFile
     */
    'fileContent'?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelFileStatusEnum {
    Draft = 'DRAFT',
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}

/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'ownerColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'referenceColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'status'?: NoteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'folderUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'content'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NoteStatusEnum {
    Created = 'CREATED',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface OrgObjective
 */
export interface OrgObjective {
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'uuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgObjective
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'status'?: OrgObjectiveStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgObjective
     */
    'version'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgObjectiveStatusEnum {
    Draft = 'DRAFT',
    Published = 'PUBLISHED',
    Unpublished = 'UNPUBLISHED'
}

/**
 * 
 * @export
 * @interface OrganisationDictionary
 */
export interface OrganisationDictionary {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionary
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionary
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganisationDictionary
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface OverallHealth
 */
export interface OverallHealth {
    /**
     * 
     * @type {string}
     * @memberof OverallHealth
     */
    'status'?: OverallHealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OverallHealth
     */
    'version'?: string;
    /**
     * 
     * @type {Array<Health>}
     * @memberof OverallHealth
     */
    'component'?: Array<Health>;
}

/**
    * @export
    * @enum {string}
    */
export enum OverallHealthStatusEnum {
    Ok = 'Ok',
    Fail = 'Fail',
    Degraded = 'Degraded'
}

/**
 * 
 * @export
 * @interface PDPGoal
 */
export interface PDPGoal {
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof PDPGoal
     */
    'number'?: number;
    /**
     * 
     * @type {object}
     * @memberof PDPGoal
     */
    'properties'?: {[key: string]: string};
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'achievementDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'status'?: PDPGoalStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PDPGoalStatusEnum {
    Draft = 'DRAFT',
    Published = 'PUBLISHED',
    Unpublished = 'UNPUBLISHED'
}

/**
 * 
 * @export
 * @interface PDPResponse
 */
export interface PDPResponse {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PDPResponse
     */
    'goals'?: Array<PDPGoal>;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PDPResponse
     */
    'form'?: PMFormElement;
}
/**
 * 
 * @export
 * @interface PMCycle
 */
export interface PMCycle {
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'entryConfigKey'?: string;
    /**
     * 
     * @type {any}
     * @memberof PMCycle
     */
    'template'?: any;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'name'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof PMCycle
     */
    'createdBy'?: ColleagueSimple;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'status'?: PMCycleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'type'?: PMCycleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'endTime'?: string;
    /**
     * 
     * @type {object}
     * @memberof PMCycle
     */
    'properties'?: {[key: string]: string};
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof PMCycle
     */
    'metadata'?: PMCycleMetadata;
}

/**
    * @export
    * @enum {string}
    */
export enum PMCycleStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Completed = 'COMPLETED',
    Draft = 'DRAFT',
    Failed = 'FAILED',
    Registered = 'REGISTERED',
    Started = 'STARTED',
    Suspended = 'SUSPENDED',
    Terminated = 'TERMINATED'
}
/**
    * @export
    * @enum {string}
    */
export enum PMCycleTypeEnum {
    Fiscal = 'FISCAL',
    Hiring = 'HIRING'
}

/**
 * 
 * @export
 * @interface PMCycleElement
 */
export interface PMCycleElement {
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'type'?: PMCycleElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMCycleElement
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'cycleType'?: PMCycleElementCycleTypeEnum;
    /**
     * 
     * @type {Array<PMTimelinePointElement | PMReviewElement>}
     * @memberof PMCycleElement
     */
    'timelinePoints'?: Array<PMTimelinePointElement | PMReviewElement>;
}

/**
    * @export
    * @enum {string}
    */
export enum PMCycleElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}
/**
    * @export
    * @enum {string}
    */
export enum PMCycleElementCycleTypeEnum {
    Fiscal = 'FISCAL',
    Hiring = 'HIRING'
}

/**
 * 
 * @export
 * @interface PMCycleMetadata
 */
export interface PMCycleMetadata {
    /**
     * 
     * @type {PMCycleElement}
     * @memberof PMCycleMetadata
     */
    'cycle'?: PMCycleElement;
}
/**
 * 
 * @export
 * @interface PMForm
 */
export interface PMForm {
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'type'?: PMFormTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMForm
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'json'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PMFormTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface PMFormElement
 */
export interface PMFormElement {
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'type'?: PMFormElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMFormElement
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'key'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PMFormElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface PMReviewElement
 */
export interface PMReviewElement extends PMTimelinePointElement {
    /**
     * 
     * @type {string}
     * @memberof PMReviewElement
     */
    'reviewType'?: PMReviewElementReviewTypeEnum;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PMReviewElement
     */
    'form'?: PMFormElement;
}

/**
    * @export
    * @enum {string}
    */
export enum PMReviewElementReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR'
}

/**
 * 
 * @export
 * @interface PMReviewElementAllOf
 */
export interface PMReviewElementAllOf {
    /**
     * 
     * @type {string}
     * @memberof PMReviewElementAllOf
     */
    'reviewType'?: PMReviewElementAllOfReviewTypeEnum;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PMReviewElementAllOf
     */
    'form'?: PMFormElement;
}

/**
    * @export
    * @enum {string}
    */
export enum PMReviewElementAllOfReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR'
}

/**
 * 
 * @export
 * @interface PMTimelinePointElement
 */
export interface PMTimelinePointElement {
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'type'?: PMTimelinePointElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMTimelinePointElement
     */
    'properties'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum PMTimelinePointElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'teamName'?: string;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'dateOfBirth'?: string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {ReportMetadata}
     * @memberof Report
     */
    'metadata'?: ReportMetadata;
    /**
     * 
     * @type {Array<Array<object>>}
     * @memberof Report
     */
    'data'?: Array<Array<object>>;
}
/**
 * 
 * @export
 * @interface ReportMetadata
 */
export interface ReportMetadata {
    /**
     * 
     * @type {Array<ColumnMetadata>}
     * @memberof ReportMetadata
     */
    'columnMetadata'?: Array<ColumnMetadata>;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'sheetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportMetadata
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RequestQuery
 */
export interface RequestQuery {
    /**
     * 
     * @type {Array<Sort>}
     * @memberof RequestQuery
     */
    'sort'?: Array<Sort>;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof RequestQuery
     */
    'filters'?: Array<Condition>;
    /**
     * 
     * @type {number}
     * @memberof RequestQuery
     */
    '_start'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestQuery
     */
    '_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestQuery
     */
    '_search'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestQuery
     */
    '_sort'?: string;
}
/**
 * 
 * @export
 * @interface RestResponseBoolean
 */
export interface RestResponseBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseBoolean
     */
    'success'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseBoolean
     */
    'data'?: boolean;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseBoolean
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseColleagueProfile
 */
export interface RestResponseColleagueProfile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseColleagueProfile
     */
    'success'?: boolean;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof RestResponseColleagueProfile
     */
    'data'?: ColleagueProfile;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseColleagueProfile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseCompositePMCycleMetadataResponse
 */
export interface RestResponseCompositePMCycleMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {CompositePMCycleMetadataResponse}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'data'?: CompositePMCycleMetadataResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseCompositePMCycleResponse
 */
export interface RestResponseCompositePMCycleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {CompositePMCycleResponse}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'data'?: CompositePMCycleResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseConfigEntryResponse
 */
export interface RestResponseConfigEntryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseConfigEntryResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ConfigEntryResponse}
     * @memberof RestResponseConfigEntryResponse
     */
    'data'?: ConfigEntryResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseConfigEntryResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseDeploymentInfo
 */
export interface RestResponseDeploymentInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseDeploymentInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {DeploymentInfo}
     * @memberof RestResponseDeploymentInfo
     */
    'data'?: DeploymentInfo;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseDeploymentInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseFeedback
 */
export interface RestResponseFeedback {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseFeedback
     */
    'success'?: boolean;
    /**
     * 
     * @type {Feedback}
     * @memberof RestResponseFeedback
     */
    'data'?: Feedback;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseFeedback
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseFile
 */
export interface RestResponseFile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseFile
     */
    'success'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof RestResponseFile
     */
    'data'?: any;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseFile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseGeneralDictionaryItem
 */
export interface RestResponseGeneralDictionaryItem {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'success'?: boolean;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'data'?: GeneralDictionaryItem;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseImportReport
 */
export interface RestResponseImportReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseImportReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {ImportReport}
     * @memberof RestResponseImportReport
     */
    'data'?: ImportReport;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseImportReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseImportRequest
 */
export interface RestResponseImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseImportRequest
     */
    'success'?: boolean;
    /**
     * 
     * @type {ImportRequest}
     * @memberof RestResponseImportRequest
     */
    'data'?: ImportRequest;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseImportRequest
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListAuditOrgObjectiveReport
 */
export interface RestResponseListAuditOrgObjectiveReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<AuditOrgObjectiveReport>}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'data'?: Array<AuditOrgObjectiveReport>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueEntity
 */
export interface RestResponseListColleagueEntity {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueEntity
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueEntity>}
     * @memberof RestResponseListColleagueEntity
     */
    'data'?: Array<ColleagueEntity>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueEntity
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueProfile
 */
export interface RestResponseListColleagueProfile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueProfile
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueProfile>}
     * @memberof RestResponseListColleagueProfile
     */
    'data'?: Array<ColleagueProfile>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueProfile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueView
 */
export interface RestResponseListColleagueView {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueView
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueView>}
     * @memberof RestResponseListColleagueView
     */
    'data'?: Array<ColleagueView>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueView
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListConfigEntryResponse
 */
export interface RestResponseListConfigEntryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListConfigEntryResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ConfigEntryResponse>}
     * @memberof RestResponseListConfigEntryResponse
     */
    'data'?: Array<ConfigEntryResponse>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListConfigEntryResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListDeploymentInfo
 */
export interface RestResponseListDeploymentInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListDeploymentInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<DeploymentInfo>}
     * @memberof RestResponseListDeploymentInfo
     */
    'data'?: Array<DeploymentInfo>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListDeploymentInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFeedback
 */
export interface RestResponseListFeedback {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFeedback
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof RestResponseListFeedback
     */
    'data'?: Array<Feedback>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFeedback
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFile
 */
export interface RestResponseListFile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFile
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof RestResponseListFile
     */
    'data'?: Array<any>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFolder
 */
export interface RestResponseListFolder {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFolder
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof RestResponseListFolder
     */
    'data'?: Array<Folder>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFolder
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListGeneralDictionaryItem
 */
export interface RestResponseListGeneralDictionaryItem {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<GeneralDictionaryItem>}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'data'?: Array<GeneralDictionaryItem>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListImportError
 */
export interface RestResponseListImportError {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListImportError
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ImportError>}
     * @memberof RestResponseListImportError
     */
    'data'?: Array<ImportError>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListImportError
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListNote
 */
export interface RestResponseListNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Note>}
     * @memberof RestResponseListNote
     */
    'data'?: Array<Note>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOrgObjective
 */
export interface RestResponseListOrgObjective {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOrgObjective
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof RestResponseListOrgObjective
     */
    'data'?: Array<OrgObjective>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOrgObjective
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOrganisationDictionary
 */
export interface RestResponseListOrganisationDictionary {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOrganisationDictionary
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OrganisationDictionary>}
     * @memberof RestResponseListOrganisationDictionary
     */
    'data'?: Array<OrganisationDictionary>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOrganisationDictionary
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListPDPGoal
 */
export interface RestResponseListPDPGoal {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListPDPGoal
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof RestResponseListPDPGoal
     */
    'data'?: Array<PDPGoal>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListPDPGoal
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListPMCycle
 */
export interface RestResponseListPMCycle {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListPMCycle
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<PMCycle>}
     * @memberof RestResponseListPMCycle
     */
    'data'?: Array<PMCycle>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListPMCycle
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListReview
 */
export interface RestResponseListReview {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListReview
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Review>}
     * @memberof RestResponseListReview
     */
    'data'?: Array<Review>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListReview
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListRole
 */
export interface RestResponseListRole {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListRole
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Role>}
     * @memberof RestResponseListRole
     */
    'data'?: Array<Role>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListRole
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListString
 */
export interface RestResponseListString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListString
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RestResponseListString
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListTimelinePoint
 */
export interface RestResponseListTimelinePoint {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListTimelinePoint
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<TimelinePoint>}
     * @memberof RestResponseListTimelinePoint
     */
    'data'?: Array<TimelinePoint>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListTimelinePoint
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListTip
 */
export interface RestResponseListTip {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListTip
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Tip>}
     * @memberof RestResponseListTip
     */
    'data'?: Array<Tip>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListTip
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListTypedAttribute
 */
export interface RestResponseListTypedAttribute {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListTypedAttribute
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof RestResponseListTypedAttribute
     */
    'data'?: Array<TypedAttribute>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListTypedAttribute
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapStringString
 */
export interface RestResponseMapStringString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapStringString
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RestResponseMapStringString
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapStringString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseNote
 */
export interface RestResponseNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {Note}
     * @memberof RestResponseNote
     */
    'data'?: Note;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseObject
 */
export interface RestResponseObject {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseObject
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof RestResponseObject
     */
    'data'?: object;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseObject
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseOrganisationDictionary
 */
export interface RestResponseOrganisationDictionary {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseOrganisationDictionary
     */
    'success'?: boolean;
    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof RestResponseOrganisationDictionary
     */
    'data'?: OrganisationDictionary;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseOrganisationDictionary
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePDPResponse
 */
export interface RestResponsePDPResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePDPResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {PDPResponse}
     * @memberof RestResponsePDPResponse
     */
    'data'?: PDPResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePDPResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMCycle
 */
export interface RestResponsePMCycle {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMCycle
     */
    'success'?: boolean;
    /**
     * 
     * @type {PMCycle}
     * @memberof RestResponsePMCycle
     */
    'data'?: PMCycle;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMCycle
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMCycleMetadata
 */
export interface RestResponsePMCycleMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMCycleMetadata
     */
    'success'?: boolean;
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof RestResponsePMCycleMetadata
     */
    'data'?: PMCycleMetadata;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMCycleMetadata
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMTimelinePointStatus
 */
export interface RestResponsePMTimelinePointStatus {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMTimelinePointStatus
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponsePMTimelinePointStatus
     */
    'data'?: RestResponsePMTimelinePointStatusDataEnum;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMTimelinePointStatus
     */
    'errors'?: Array<ApiError>;
}

/**
    * @export
    * @enum {string}
    */
export enum RestResponsePMTimelinePointStatusDataEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    Completed = 'COMPLETED',
    Overdue = 'OVERDUE',
    Started = 'STARTED',
    NotStarted = 'NOT_STARTED',
    NotCreated = 'NOT_CREATED'
}

/**
 * 
 * @export
 * @interface RestResponseReport
 */
export interface RestResponseReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {Report}
     * @memberof RestResponseReport
     */
    'data'?: Report;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseReview
 */
export interface RestResponseReview {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseReview
     */
    'success'?: boolean;
    /**
     * 
     * @type {Review}
     * @memberof RestResponseReview
     */
    'data'?: Review;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseReview
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseString
 */
export interface RestResponseString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseString
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponseString
     */
    'data'?: string;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseTip
 */
export interface RestResponseTip {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseTip
     */
    'success'?: boolean;
    /**
     * 
     * @type {Tip}
     * @memberof RestResponseTip
     */
    'data'?: Tip;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseTip
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseUUID
 */
export interface RestResponseUUID {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseUUID
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponseUUID
     */
    'data'?: string;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseUUID
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseUser
 */
export interface RestResponseUser {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseUser
     */
    'success'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof RestResponseUser
     */
    'data'?: User;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseUser
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseVoid
 */
export interface RestResponseVoid {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseVoid
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof RestResponseVoid
     */
    'data'?: object;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseVoid
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'type'?: ReviewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'status'?: ReviewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'tlPointUuid'?: string;
    /**
     * 
     * @type {object}
     * @memberof Review
     */
    'properties'?: {[key: string]: string};
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'changeStatusReason'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR'
}
/**
    * @export
    * @enum {string}
    */
export enum ReviewStatusEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    Completed = 'COMPLETED',
    Overdue = 'OVERDUE',
    Started = 'STARTED',
    NotStarted = 'NOT_STARTED',
    NotCreated = 'NOT_CREATED'
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'roleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'roleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'roleDesc'?: string;
}
/**
 * 
 * @export
 * @interface RoleRequest
 */
export interface RoleRequest {
    /**
     * 
     * @type {string}
     * @memberof RoleRequest
     */
    'accountName'?: string;
    /**
     * 
     * @type {object}
     * @memberof RoleRequest
     */
    'role'?: object;
}
/**
 * 
 * @export
 * @interface ServiceDates
 */
export interface ServiceDates {
    /**
     * 
     * @type {string}
     * @memberof ServiceDates
     */
    'hireDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDates
     */
    'leavingDate'?: string;
}
/**
 * 
 * @export
 * @interface SimplifiedReview
 */
export interface SimplifiedReview {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'type'?: SimplifiedReviewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'status'?: SimplifiedReviewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplifiedReview
     */
    'number'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum SimplifiedReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplifiedReviewStatusEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    Completed = 'COMPLETED',
    Overdue = 'OVERDUE',
    Started = 'STARTED',
    NotStarted = 'NOT_STARTED',
    NotCreated = 'NOT_CREATED'
}

/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    'order'?: SortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * 
 * @export
 * @interface TimelinePoint
 */
export interface TimelinePoint {
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'colleagueCycleUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'type'?: TimelinePointTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'endTime'?: string;
    /**
     * 
     * @type {object}
     * @memberof TimelinePoint
     */
    'properties'?: {[key: string]: string};
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'status'?: TimelinePointStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'reviewType'?: TimelinePointReviewTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimelinePoint
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'lastUpdatedTime'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TimelinePointTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}
/**
    * @export
    * @enum {string}
    */
export enum TimelinePointStatusEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    Completed = 'COMPLETED',
    Overdue = 'OVERDUE',
    Started = 'STARTED',
    NotStarted = 'NOT_STARTED',
    NotCreated = 'NOT_CREATED'
}
/**
    * @export
    * @enum {string}
    */
export enum TimelinePointReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR'
}

/**
 * 
 * @export
 * @interface Tip
 */
export interface Tip {
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'uuid'?: string;
    /**
     * History management.
     * @type {number}
     * @memberof Tip
     */
    'version'?: number;
    /**
     * Link to frontend component or page.
     * @type {string}
     * @memberof Tip
     */
    'key': string;
    /**
     * Title.
     * @type {string}
     * @memberof Tip
     */
    'title': string;
    /**
     * Description.
     * @type {string}
     * @memberof Tip
     */
    'description': string;
    /**
     * 
     * @type {ConfigEntry}
     * @memberof Tip
     */
    'targetOrganisation': ConfigEntry;
    /**
     * Image link.
     * @type {string}
     * @memberof Tip
     */
    'imageLink': string;
    /**
     * Published checkbox.
     * @type {boolean}
     * @memberof Tip
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'createdTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'updatedTime'?: string;
}
/**
 * 
 * @export
 * @interface TypedAttribute
 */
export interface TypedAttribute {
    /**
     * 
     * @type {string}
     * @memberof TypedAttribute
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypedAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypedAttribute
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypedAttribute
     */
    'type'?: TypedAttributeTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TypedAttributeTypeEnum {
    String = 'STRING',
    Date = 'DATE',
    Number = 'NUMBER',
    Boolean = 'BOOLEAN'
}

/**
 * 
 * @export
 * @interface UpdateReviewsStatusRequest
 */
export interface UpdateReviewsStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateReviewsStatusRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {Array<Review>}
     * @memberof UpdateReviewsStatusRequest
     */
    'reviews'?: Array<Review>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Colleague}
     * @memberof User
     */
    'colleague'?: Colleague;
    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof User
     */
    'profileAttributes'?: Array<TypedAttribute>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkLevel
 */
export interface WorkLevel {
    /**
     * 
     * @type {string}
     * @memberof WorkLevel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLevel
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface WorkRelationship
 */
export interface WorkRelationship {
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'locationUUID'?: string;
    /**
     * 
     * @type {ContractType}
     * @memberof WorkRelationship
     */
    'contractType'?: ContractType;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'colleagueType'?: WorkRelationshipColleagueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workingStatus'?: WorkRelationshipWorkingStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'type'?: WorkRelationshipTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'defaultExpenseAccount'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'peopleGroup'?: string;
    /**
     * 
     * @type {LegalEmployer}
     * @memberof WorkRelationship
     */
    'legalEmployer'?: LegalEmployer;
    /**
     * 
     * @type {Department}
     * @memberof WorkRelationship
     */
    'department'?: Department;
    /**
     * 
     * @type {Grade}
     * @memberof WorkRelationship
     */
    'grade'?: Grade;
    /**
     * 
     * @type {Position}
     * @memberof WorkRelationship
     */
    'position'?: Position;
    /**
     * 
     * @type {Job}
     * @memberof WorkRelationship
     */
    'job'?: Job;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'actionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'actionReasonCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'userStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workSchedule'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'employmentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'salaryFrequency'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workingHours'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'costCenter'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'assignmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'primaryEntity'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkRelationship
     */
    'workingInHiredCountry'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkRelationship
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workLevel'?: WorkRelationshipWorkLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'managerUUID'?: string;
    /**
     * 
     * @type {Colleague}
     * @memberof WorkRelationship
     */
    'manager'?: Colleague;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipColleagueTypeEnum {
    Employee = 'EMPLOYEE',
    External = 'EXTERNAL',
    Contractor = 'CONTRACTOR'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipWorkingStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Suspended = 'SUSPENDED',
    InactivePaid = 'INACTIVE_PAID'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipTypeEnum {
    Primary = 'PRIMARY'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipWorkLevelEnum {
    Wl1 = 'WL1',
    Wl2 = 'WL2',
    Wl3 = 'WL3',
    Wl4 = 'WL4',
    Wl5 = 'WL5'
}


/**
 * CMSApi - axios parameter creator
 * @export
 */
export const CMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqUrls: async (keys?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cms/help-faq-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keys) {
                localVarQueryParameter['keys'] = keys;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CMSApi - functional programming interface
 * @export
 */
export const CMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CMSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelpFaqUrls(keys?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelpFaqUrls(keys, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CMSApi - factory interface
 * @export
 */
export const CMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CMSApiFp(configuration)
    return {
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqUrls(keys?: Array<string>, options?: any): AxiosPromise<RestResponseMapStringString> {
            return localVarFp.getHelpFaqUrls(keys, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHelpFaqUrls operation in CMSApi.
 * @export
 * @interface CMSApiGetHelpFaqUrlsRequest
 */
export interface CMSApiGetHelpFaqUrlsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CMSApiGetHelpFaqUrls
     */
    readonly keys?: Array<string>
}

/**
 * CMSApi - object-oriented interface
 * @export
 * @class CMSApi
 * @extends {BaseAPI}
 */
export class CMSApi extends BaseAPI {
    /**
     * 
     * @summary Find URLs by keys
     * @param {CMSApiGetHelpFaqUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CMSApi
     */
    public getHelpFaqUrls(requestParameters: CMSApiGetHelpFaqUrlsRequest = {}, options?: AxiosRequestConfig) {
        return CMSApiFp(this.configuration).getHelpFaqUrls(requestParameters.keys, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CepApi - axios parameter creator
 * @export
 */
export const CepApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {string} feedId 
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processColleagueChangeEvent: async (feedId: string, colleagueChangeEventPayload: ColleagueChangeEventPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('processColleagueChangeEvent', 'feedId', feedId)
            // verify required parameter 'colleagueChangeEventPayload' is not null or undefined
            assertParamExists('processColleagueChangeEvent', 'colleagueChangeEventPayload', colleagueChangeEventPayload)
            const localVarPath = `/colleagues/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (feedId !== undefined && feedId !== null) {
                localVarHeaderParameter['FeedId'] = String(feedId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(colleagueChangeEventPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CepApi - functional programming interface
 * @export
 */
export const CepApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CepApiAxiosParamCreator(configuration)
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {string} feedId 
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processColleagueChangeEvent(feedId: string, colleagueChangeEventPayload: ColleagueChangeEventPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processColleagueChangeEvent(feedId, colleagueChangeEventPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CepApi - factory interface
 * @export
 */
export const CepApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CepApiFp(configuration)
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {string} feedId 
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processColleagueChangeEvent(feedId: string, colleagueChangeEventPayload: ColleagueChangeEventPayload, options?: any): AxiosPromise<void> {
            return localVarFp.processColleagueChangeEvent(feedId, colleagueChangeEventPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for processColleagueChangeEvent operation in CepApi.
 * @export
 * @interface CepApiProcessColleagueChangeEventRequest
 */
export interface CepApiProcessColleagueChangeEventRequest {
    /**
     * 
     * @type {string}
     * @memberof CepApiProcessColleagueChangeEvent
     */
    readonly feedId: string

    /**
     * 
     * @type {ColleagueChangeEventPayload}
     * @memberof CepApiProcessColleagueChangeEvent
     */
    readonly colleagueChangeEventPayload: ColleagueChangeEventPayload
}

/**
 * CepApi - object-oriented interface
 * @export
 * @class CepApi
 * @extends {BaseAPI}
 */
export class CepApi extends BaseAPI {
    /**
     * Consuming colleague changes events
     * @summary Consuming events
     * @param {CepApiProcessColleagueChangeEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepApi
     */
    public processColleagueChangeEvent(requestParameters: CepApiProcessColleagueChangeEventRequest, options?: AxiosRequestConfig) {
        return CepApiFp(this.configuration).processColleagueChangeEvent(requestParameters.feedId, requestParameters.colleagueChangeEventPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ColleaguesApi - axios parameter creator
 * @export
 */
export const ColleaguesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSuggestions', 'requestQuery', requestQuery)
            const localVarPath = `/colleagues/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ColleaguesApi - functional programming interface
 * @export
 */
export const ColleaguesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ColleaguesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestions(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ColleaguesApi - factory interface
 * @export
 */
export const ColleaguesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ColleaguesApiFp(configuration)
    return {
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueProfile> {
            return localVarFp.getSuggestions(requestQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSuggestions operation in ColleaguesApi.
 * @export
 * @interface ColleaguesApiGetSuggestionsRequest
 */
export interface ColleaguesApiGetSuggestionsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ColleaguesApiGetSuggestions
     */
    readonly requestQuery: RequestQuery
}

/**
 * ColleaguesApi - object-oriented interface
 * @export
 * @class ColleaguesApi
 * @extends {BaseAPI}
 */
export class ColleaguesApi extends BaseAPI {
    /**
     * 
     * @summary Autocomplete search among colleagues by full name and manager ID
     * @param {ColleaguesApiGetSuggestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColleaguesApi
     */
    public getSuggestions(requestParameters: ColleaguesApiGetSuggestionsRequest, options?: AxiosRequestConfig) {
        return ColleaguesApiFp(this.configuration).getSuggestions(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultAttributes: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateDefaultAttributes', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/config/default/attributes/colleagues/{colleagueUuid}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefaultAttributes(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefaultAttributes(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultAttributes(colleagueUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.updateDefaultAttributes(colleagueUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateDefaultAttributes operation in ConfigApi.
 * @export
 * @interface ConfigApiUpdateDefaultAttributesRequest
 */
export interface ConfigApiUpdateDefaultAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigApiUpdateDefaultAttributes
     */
    readonly colleagueUuid: string
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @summary Update default attributes for a colleague
     * @param {ConfigApiUpdateDefaultAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public updateDefaultAttributes(requestParameters: ConfigApiUpdateDefaultAttributesRequest, options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).updateDefaultAttributes(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigEntryApi - axios parameter creator
 * @export
 */
export const ConfigEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (configEntry: ConfigEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configEntry' is not null or undefined
            assertParamExists('create4', 'configEntry', configEntry)
            const localVarPath = `/config-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('delete6', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findColleaguesByCompositeKey: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('findColleaguesByCompositeKey', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('getPublishedEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructureByCompositeKey: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('getPublishedEntryConfigStructureByCompositeKey', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRoots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config-entries/roots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublished: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('getUnpublished', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries/unpublished`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('getUnpublishedEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/unpublished`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedRoots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config-entries/roots/unpublished`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('publishEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/publish`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('unpublishEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/publish`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (entryUuid: string, configEntry: ConfigEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('update1', 'entryUuid', entryUuid)
            // verify required parameter 'configEntry' is not null or undefined
            assertParamExists('update1', 'configEntry', configEntry)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigEntryApi - functional programming interface
 * @export
 */
export const ConfigEntryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigEntryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(configEntry: ConfigEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(configEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete6(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete6(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findColleaguesByCompositeKey(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findColleaguesByCompositeKey(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedEntryConfigStructureByCompositeKey(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedEntryConfigStructureByCompositeKey(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedRoots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedRoots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublished(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublished(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublishedEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublishedEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublishedRoots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublishedRoots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(entryUuid: string, configEntry: ConfigEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(entryUuid, configEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigEntryApi - factory interface
 * @export
 */
export const ConfigEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigEntryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(configEntry: ConfigEntry, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.create4(configEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(entryUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.delete6(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findColleaguesByCompositeKey(compositeKey: string, options?: any): AxiosPromise<RestResponseListColleagueEntity> {
            return localVarFp.findColleaguesByCompositeKey(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseConfigEntryResponse> {
            return localVarFp.getPublishedEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructureByCompositeKey(compositeKey: string, options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getPublishedEntryConfigStructureByCompositeKey(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRoots(options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getPublishedRoots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublished(compositeKey: string, options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getUnpublished(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseConfigEntryResponse> {
            return localVarFp.getUnpublishedEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedRoots(options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getUnpublishedRoots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.publishEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.unpublishEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(entryUuid: string, configEntry: ConfigEntry, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.update1(entryUuid, configEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create4 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiCreate4Request
 */
export interface ConfigEntryApiCreate4Request {
    /**
     * 
     * @type {ConfigEntry}
     * @memberof ConfigEntryApiCreate4
     */
    readonly configEntry: ConfigEntry
}

/**
 * Request parameters for delete6 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiDelete6Request
 */
export interface ConfigEntryApiDelete6Request {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiDelete6
     */
    readonly entryUuid: string
}

/**
 * Request parameters for findColleaguesByCompositeKey operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiFindColleaguesByCompositeKeyRequest
 */
export interface ConfigEntryApiFindColleaguesByCompositeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiFindColleaguesByCompositeKey
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getPublishedEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetPublishedEntryConfigStructureRequest
 */
export interface ConfigEntryApiGetPublishedEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetPublishedEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for getPublishedEntryConfigStructureByCompositeKey operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest
 */
export interface ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKey
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getUnpublished operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetUnpublishedRequest
 */
export interface ConfigEntryApiGetUnpublishedRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetUnpublished
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getUnpublishedEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetUnpublishedEntryConfigStructureRequest
 */
export interface ConfigEntryApiGetUnpublishedEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetUnpublishedEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for publishEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiPublishEntryConfigStructureRequest
 */
export interface ConfigEntryApiPublishEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiPublishEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for unpublishEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiUnpublishEntryConfigStructureRequest
 */
export interface ConfigEntryApiUnpublishEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiUnpublishEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for update1 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiUpdate1Request
 */
export interface ConfigEntryApiUpdate1Request {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiUpdate1
     */
    readonly entryUuid: string

    /**
     * 
     * @type {ConfigEntry}
     * @memberof ConfigEntryApiUpdate1
     */
    readonly configEntry: ConfigEntry
}

/**
 * ConfigEntryApi - object-oriented interface
 * @export
 * @class ConfigEntryApi
 * @extends {BaseAPI}
 */
export class ConfigEntryApi extends BaseAPI {
    /**
     * 
     * @summary Create config entry
     * @param {ConfigEntryApiCreate4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public create4(requestParameters: ConfigEntryApiCreate4Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).create4(requestParameters.configEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete config entry
     * @param {ConfigEntryApiDelete6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public delete6(requestParameters: ConfigEntryApiDelete6Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).delete6(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get colleagues by composite key
     * @param {ConfigEntryApiFindColleaguesByCompositeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public findColleaguesByCompositeKey(requestParameters: ConfigEntryApiFindColleaguesByCompositeKeyRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).findColleaguesByCompositeKey(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published config entry structure by root identifier
     * @param {ConfigEntryApiGetPublishedEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedEntryConfigStructure(requestParameters: ConfigEntryApiGetPublishedEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published config entry structure by composite key
     * @param {ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedEntryConfigStructureByCompositeKey(requestParameters: ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedEntryConfigStructureByCompositeKey(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all published root config entries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedRoots(options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedRoots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unpublished structure by composite key
     * @param {ConfigEntryApiGetUnpublishedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublished(requestParameters: ConfigEntryApiGetUnpublishedRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublished(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unpublished config entry structure by root identifier
     * @param {ConfigEntryApiGetUnpublishedEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublishedEntryConfigStructure(requestParameters: ConfigEntryApiGetUnpublishedEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublishedEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all unpublished root config entries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublishedRoots(options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublishedRoots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish config entry
     * @param {ConfigEntryApiPublishEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public publishEntryConfigStructure(requestParameters: ConfigEntryApiPublishEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).publishEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpublish config entry
     * @param {ConfigEntryApiUnpublishEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public unpublishEntryConfigStructure(requestParameters: ConfigEntryApiUnpublishEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).unpublishEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update config entry
     * @param {ConfigEntryApiUpdate1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public update1(requestParameters: ConfigEntryApiUpdate1Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).update1(requestParameters.entryUuid, requestParameters.configEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentEndpointApi - axios parameter creator
 * @export
 */
export const DeploymentEndpointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [deploymentName] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy: async (deploymentName?: string, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (deploymentName !== undefined) { 
                localVarFormParams.append('deploymentName', deploymentName as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployProcess: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deployProcess', 'body', body)
            const localVarPath = `/processes/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployments: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeploy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('undeploy', 'id', id)
            const localVarPath = `/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployByName: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('undeployByName', 'name', name)
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployProcess: async (processName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processName' is not null or undefined
            assertParamExists('undeployProcess', 'processName', processName)
            const localVarPath = `/processes/{processName}`
                .replace(`{${"processName"}}`, encodeURIComponent(String(processName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentEndpointApi - functional programming interface
 * @export
 */
export const DeploymentEndpointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentEndpointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [deploymentName] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploy(deploymentName?: string, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploy(deploymentName, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployProcess(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployProcess(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployments(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployments(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeploy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeploy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeployByName(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeployByName(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeployProcess(processName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeployProcess(processName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentEndpointApi - factory interface
 * @export
 */
export const DeploymentEndpointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentEndpointApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [deploymentName] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy(deploymentName?: string, files?: Array<any>, options?: any): AxiosPromise<RestResponseDeploymentInfo> {
            return localVarFp.deploy(deploymentName, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployProcess(body: string, options?: any): AxiosPromise<RestResponseDeploymentInfo> {
            return localVarFp.deployProcess(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployments(options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.deployments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processes(options?: any): AxiosPromise<RestResponseListString> {
            return localVarFp.processes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeploy(id: string, options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.undeploy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployByName(name: string, options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.undeployByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployProcess(processName: string, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.undeployProcess(processName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deploy operation in DeploymentEndpointApi.
 * @export
 * @interface DeploymentEndpointApiDeployRequest
 */
export interface DeploymentEndpointApiDeployRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentEndpointApiDeploy
     */
    readonly deploymentName?: string

    /**
     * 
     * @type {Array<any>}
     * @memberof DeploymentEndpointApiDeploy
     */
    readonly files?: Array<any>
}

/**
 * Request parameters for deployProcess operation in DeploymentEndpointApi.
 * @export
 * @interface DeploymentEndpointApiDeployProcessRequest
 */
export interface DeploymentEndpointApiDeployProcessRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentEndpointApiDeployProcess
     */
    readonly body: string
}

/**
 * Request parameters for undeploy operation in DeploymentEndpointApi.
 * @export
 * @interface DeploymentEndpointApiUndeployRequest
 */
export interface DeploymentEndpointApiUndeployRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentEndpointApiUndeploy
     */
    readonly id: string
}

/**
 * Request parameters for undeployByName operation in DeploymentEndpointApi.
 * @export
 * @interface DeploymentEndpointApiUndeployByNameRequest
 */
export interface DeploymentEndpointApiUndeployByNameRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentEndpointApiUndeployByName
     */
    readonly name: string
}

/**
 * Request parameters for undeployProcess operation in DeploymentEndpointApi.
 * @export
 * @interface DeploymentEndpointApiUndeployProcessRequest
 */
export interface DeploymentEndpointApiUndeployProcessRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentEndpointApiUndeployProcess
     */
    readonly processName: string
}

/**
 * DeploymentEndpointApi - object-oriented interface
 * @export
 * @class DeploymentEndpointApi
 * @extends {BaseAPI}
 */
export class DeploymentEndpointApi extends BaseAPI {
    /**
     * 
     * @param {DeploymentEndpointApiDeployRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public deploy(requestParameters: DeploymentEndpointApiDeployRequest = {}, options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).deploy(requestParameters.deploymentName, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentEndpointApiDeployProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public deployProcess(requestParameters: DeploymentEndpointApiDeployProcessRequest, options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).deployProcess(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public deployments(options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).deployments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public processes(options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).processes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentEndpointApiUndeployRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public undeploy(requestParameters: DeploymentEndpointApiUndeployRequest, options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).undeploy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentEndpointApiUndeployByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public undeployByName(requestParameters: DeploymentEndpointApiUndeployByNameRequest, options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).undeployByName(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentEndpointApiUndeployProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentEndpointApi
     */
    public undeployProcess(requestParameters: DeploymentEndpointApiUndeployProcessRequest, options?: AxiosRequestConfig) {
        return DeploymentEndpointApiFp(this.configuration).undeployProcess(requestParameters.processName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiagnosticApi - axios parameter creator
 * @export
 */
export const DiagnosticApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHc: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_working`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosticApi - functional programming interface
 * @export
 */
export const DiagnosticApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosticApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHc(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHc(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverallHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverallHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReady(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorking(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorking(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiagnosticApi - factory interface
 * @export
 */
export const DiagnosticApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosticApiFp(configuration)
    return {
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHc(options?: any): AxiosPromise<Health> {
            return localVarFp.getHc(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLive(options?: any): AxiosPromise<Health> {
            return localVarFp.getLive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallHealthCheck(options?: any): AxiosPromise<OverallHealth> {
            return localVarFp.getOverallHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady(options?: any): AxiosPromise<Health> {
            return localVarFp.getReady(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Health> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking(options?: any): AxiosPromise<Health> {
            return localVarFp.getWorking(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosticApi - object-oriented interface
 * @export
 * @class DiagnosticApi
 * @extends {BaseAPI}
 */
export class DiagnosticApi extends BaseAPI {
    /**
     * 
     * @summary Return a successful response if this instance is able to receive traffic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getHc(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getHc(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response in the case that the API Domain is in a healthy working state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getLive(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getLive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the status of API domain and all its components and dependencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getOverallHealthCheck(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getOverallHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response if this instance is able to receive traffic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getReady(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getReady(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a summary of the health check results for API Domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response in the case that the API Domain is in a healthy working state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getWorking(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getWorking(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DictionariesApi - axios parameter creator
 * @export
 */
export const DictionariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (dictionary: string, code?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictionary' is not null or undefined
            assertParamExists('findAll', 'dictionary', dictionary)
            const localVarPath = `/dictionaries/{dictionary}`
                .replace(`{${"dictionary"}}`, encodeURIComponent(String(dictionary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (dictionary: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictionary' is not null or undefined
            assertParamExists('read', 'dictionary', dictionary)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('read', 'id', id)
            const localVarPath = `/dictionaries/{dictionary}/{id}`
                .replace(`{${"dictionary"}}`, encodeURIComponent(String(dictionary)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DictionariesApi - functional programming interface
 * @export
 */
export const DictionariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DictionariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(dictionary: string, code?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListGeneralDictionaryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(dictionary, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(dictionary: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseGeneralDictionaryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(dictionary, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DictionariesApi - factory interface
 * @export
 */
export const DictionariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DictionariesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(dictionary: string, code?: string, options?: any): AxiosPromise<RestResponseListGeneralDictionaryItem> {
            return localVarFp.findAll(dictionary, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(dictionary: string, id: number, options?: any): AxiosPromise<RestResponseGeneralDictionaryItem> {
            return localVarFp.read(dictionary, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAll operation in DictionariesApi.
 * @export
 * @interface DictionariesApiFindAllRequest
 */
export interface DictionariesApiFindAllRequest {
    /**
     * 
     * @type {string}
     * @memberof DictionariesApiFindAll
     */
    readonly dictionary: string

    /**
     * 
     * @type {string}
     * @memberof DictionariesApiFindAll
     */
    readonly code?: string
}

/**
 * Request parameters for read operation in DictionariesApi.
 * @export
 * @interface DictionariesApiReadRequest
 */
export interface DictionariesApiReadRequest {
    /**
     * 
     * @type {string}
     * @memberof DictionariesApiRead
     */
    readonly dictionary: string

    /**
     * 
     * @type {number}
     * @memberof DictionariesApiRead
     */
    readonly id: number
}

/**
 * DictionariesApi - object-oriented interface
 * @export
 * @class DictionariesApi
 * @extends {BaseAPI}
 */
export class DictionariesApi extends BaseAPI {
    /**
     * 
     * @summary Get dictionary items
     * @param {DictionariesApiFindAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    public findAll(requestParameters: DictionariesApiFindAllRequest, options?: AxiosRequestConfig) {
        return DictionariesApiFp(this.configuration).findAll(requestParameters.dictionary, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dictionary item
     * @param {DictionariesApiReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    public read(requestParameters: DictionariesApiReadRequest, options?: AxiosRequestConfig) {
        return DictionariesApiFp(this.configuration).read(requestParameters.dictionary, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbacks: async (feedback: Array<Feedback>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('createFeedbacks', 'feedback', feedback)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedbacks: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAllFeedbacks', 'requestQuery', requestQuery)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getFeedback', 'uuid', uuid)
            const localVarPath = `/feedbacks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('markAsRead', 'uuid', uuid)
            const localVarPath = `/feedbacks/{uuid}/read`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback: async (uuid: string, feedback: Feedback, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateFeedback', 'uuid', uuid)
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('updateFeedback', 'feedback', feedback)
            const localVarPath = `/feedbacks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbacks(feedback: Array<Feedback>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedbacks(feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFeedbacks(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFeedbacks(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedback(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedback(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsRead(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsRead(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedback(uuid: string, feedback: Feedback, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedback(uuid, feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbacks(feedback: Array<Feedback>, options?: any): AxiosPromise<RestResponseListFeedback> {
            return localVarFp.createFeedbacks(feedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedbacks(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListFeedback> {
            return localVarFp.getAllFeedbacks(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(uuid: string, options?: any): AxiosPromise<RestResponseFeedback> {
            return localVarFp.getFeedback(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(uuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.markAsRead(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback(uuid: string, feedback: Feedback, options?: any): AxiosPromise<RestResponseFeedback> {
            return localVarFp.updateFeedback(uuid, feedback, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFeedbacks operation in FeedbackApi.
 * @export
 * @interface FeedbackApiCreateFeedbacksRequest
 */
export interface FeedbackApiCreateFeedbacksRequest {
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof FeedbackApiCreateFeedbacks
     */
    readonly feedback: Array<Feedback>
}

/**
 * Request parameters for getAllFeedbacks operation in FeedbackApi.
 * @export
 * @interface FeedbackApiGetAllFeedbacksRequest
 */
export interface FeedbackApiGetAllFeedbacksRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof FeedbackApiGetAllFeedbacks
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getFeedback operation in FeedbackApi.
 * @export
 * @interface FeedbackApiGetFeedbackRequest
 */
export interface FeedbackApiGetFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiGetFeedback
     */
    readonly uuid: string
}

/**
 * Request parameters for markAsRead operation in FeedbackApi.
 * @export
 * @interface FeedbackApiMarkAsReadRequest
 */
export interface FeedbackApiMarkAsReadRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiMarkAsRead
     */
    readonly uuid: string
}

/**
 * Request parameters for updateFeedback operation in FeedbackApi.
 * @export
 * @interface FeedbackApiUpdateFeedbackRequest
 */
export interface FeedbackApiUpdateFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiUpdateFeedback
     */
    readonly uuid: string

    /**
     * 
     * @type {Feedback}
     * @memberof FeedbackApiUpdateFeedback
     */
    readonly feedback: Feedback
}

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @summary Create a new list of feedbacks with items
     * @param {FeedbackApiCreateFeedbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createFeedbacks(requestParameters: FeedbackApiCreateFeedbacksRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createFeedbacks(requestParameters.feedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all feedbacks with all items
     * @param {FeedbackApiGetAllFeedbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getAllFeedbacks(requestParameters: FeedbackApiGetAllFeedbacksRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getAllFeedbacks(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feedback by UUID with all items
     * @param {FeedbackApiGetFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getFeedback(requestParameters: FeedbackApiGetFeedbackRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getFeedback(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an existing feedback as read
     * @param {FeedbackApiMarkAsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public markAsRead(requestParameters: FeedbackApiMarkAsReadRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).markAsRead(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing feedback
     * @param {FeedbackApiUpdateFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public updateFeedback(requestParameters: FeedbackApiUpdateFeedbackRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).updateFeedback(requestParameters.uuid, requestParameters.feedback, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('delete1', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} versions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5: async (path: string, fileName: string, versions: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('delete5', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('delete5', 'fileName', fileName)
            // verify required parameter 'versions' is not null or undefined
            assertParamExists('delete5', 'versions', versions)
            const localVarPath = `/files/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (versions) {
                localVarQueryParameter['versions'] = versions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('download1', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}/download`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('get', 'requestQuery', requestQuery)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('get2', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4: async (path: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('get4', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('get4', 'fileName', fileName)
            const localVarPath = `/files/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions: async (path: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getAllVersions', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getAllVersions', 'fileName', fileName)
            const localVarPath = `/files/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (uploadMetadata?: any, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (uploadMetadata !== undefined) { 
                localVarFormParams.append('uploadMetadata', uploadMetadata as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} versions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete5(path: string, fileName: string, versions: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete5(path, fileName, versions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download1(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download1(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get4(path: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get4(path, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVersions(path: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVersions(path, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(uploadMetadata?: any, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(uploadMetadata, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(fileUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete1(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} versions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(path: string, fileName: string, versions: Array<number>, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete5(path, fileName, versions, options).then((request) => request(axios, basePath));
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1(fileUuid: string, options?: any): AxiosPromise<any> {
            return localVarFp.download1(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.get(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(fileUuid: string, options?: any): AxiosPromise<RestResponseFile> {
            return localVarFp.get2(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(path: string, fileName: string, options?: any): AxiosPromise<RestResponseFile> {
            return localVarFp.get4(path, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(path: string, fileName: string, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.getAllVersions(path, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(uploadMetadata?: any, files?: Array<any>, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.upload(uploadMetadata, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for delete1 operation in FileApi.
 * @export
 * @interface FileApiDelete1Request
 */
export interface FileApiDelete1Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiDelete1
     */
    readonly fileUuid: string
}

/**
 * Request parameters for delete5 operation in FileApi.
 * @export
 * @interface FileApiDelete5Request
 */
export interface FileApiDelete5Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiDelete5
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiDelete5
     */
    readonly fileName: string

    /**
     * 
     * @type {Array<number>}
     * @memberof FileApiDelete5
     */
    readonly versions: Array<number>
}

/**
 * Request parameters for download1 operation in FileApi.
 * @export
 * @interface FileApiDownload1Request
 */
export interface FileApiDownload1Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiDownload1
     */
    readonly fileUuid: string
}

/**
 * Request parameters for get operation in FileApi.
 * @export
 * @interface FileApiGetRequest
 */
export interface FileApiGetRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof FileApiGet
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for get2 operation in FileApi.
 * @export
 * @interface FileApiGet2Request
 */
export interface FileApiGet2Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiGet2
     */
    readonly fileUuid: string
}

/**
 * Request parameters for get4 operation in FileApi.
 * @export
 * @interface FileApiGet4Request
 */
export interface FileApiGet4Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiGet4
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiGet4
     */
    readonly fileName: string
}

/**
 * Request parameters for getAllVersions operation in FileApi.
 * @export
 * @interface FileApiGetAllVersionsRequest
 */
export interface FileApiGetAllVersionsRequest {
    /**
     * 
     * @type {string}
     * @memberof FileApiGetAllVersions
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiGetAllVersions
     */
    readonly fileName: string
}

/**
 * Request parameters for upload operation in FileApi.
 * @export
 * @interface FileApiUploadRequest
 */
export interface FileApiUploadRequest {
    /**
     * 
     * @type {any}
     * @memberof FileApiUpload
     */
    readonly uploadMetadata?: any

    /**
     * 
     * @type {Array<any>}
     * @memberof FileApiUpload
     */
    readonly files?: Array<any>
}

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Delete existing file
     * @summary Delete existing File by its uuid
     * @param {FileApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public delete1(requestParameters: FileApiDelete1Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).delete1(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing files
     * @summary Delete existing Files by its path, name and versions
     * @param {FileApiDelete5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public delete5(requestParameters: FileApiDelete5Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).delete5(requestParameters.path, requestParameters.fileName, requestParameters.versions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download File
     * @summary Download File
     * @param {FileApiDownload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public download1(requestParameters: FileApiDownload1Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).download1(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Files information with the latest version applying search, filter and sorting
     * @summary Get Files information with the latest version applying search, filter and sorting
     * @param {FileApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get(requestParameters: FileApiGetRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get File information with the latest version by its uuid
     * @summary Get File information with the latest version by its uuid
     * @param {FileApiGet2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get2(requestParameters: FileApiGet2Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get2(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Files information with the latest version by file name and path
     * @summary Get Files information with the latest version by file name and path
     * @param {FileApiGet4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get4(requestParameters: FileApiGet4Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get4(requestParameters.path, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all information about File with All Versions by its name and path
     * @summary Get all information about File with All Versions by its name and path
     * @param {FileApiGetAllVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getAllVersions(requestParameters: FileApiGetAllVersionsRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).getAllVersions(requestParameters.path, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload Files
     * @summary Upload Files
     * @param {FileApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public upload(requestParameters: FileApiUploadRequest = {}, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).upload(requestParameters.uploadMetadata, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotesApi - axios parameter creator
 * @export
 */
export const NotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/notes/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (folder: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('createFolder', 'folder', folder)
            const localVarPath = `/notes/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote: async (note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'note' is not null or undefined
            assertParamExists('createNote', 'note', note)
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find Notes by Owner
         * @param {string} folderId 
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFolder1: async (folderId: string, ownerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('findByFolder1', 'folderId', folderId)
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('findByFolder1', 'ownerId', ownerId)
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (ownerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('get1', 'ownerId', ownerId)
            const localVarPath = `/notes/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (id: string, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update2', 'id', id)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('update2', 'note', note)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (id: string, folder: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update3', 'id', id)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('update3', 'folder', folder)
            const localVarPath = `/notes/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(folder: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNote(note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNote(note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find Notes by Owner
         * @param {string} folderId 
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByFolder1(folderId: string, ownerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByFolder1(folderId, ownerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(ownerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(ownerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(id: string, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(id, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(id: string, folder: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(id, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(folder: Folder, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.createFolder(folder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote(note: Note, options?: any): AxiosPromise<RestResponseNote> {
            return localVarFp.createNote(note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find Notes by Owner
         * @param {string} folderId 
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFolder1(folderId: string, ownerId: string, options?: any): AxiosPromise<RestResponseListNote> {
            return localVarFp.findByFolder1(folderId, ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(ownerId: string, options?: any): AxiosPromise<RestResponseListFolder> {
            return localVarFp.get1(ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(id: string, note: Note, options?: any): AxiosPromise<RestResponseNote> {
            return localVarFp.update2(id, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(id: string, folder: Folder, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.update3(id, folder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in NotesApi.
 * @export
 * @interface NotesApiDeleteRequest
 */
export interface NotesApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof NotesApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for createFolder operation in NotesApi.
 * @export
 * @interface NotesApiCreateFolderRequest
 */
export interface NotesApiCreateFolderRequest {
    /**
     * 
     * @type {Folder}
     * @memberof NotesApiCreateFolder
     */
    readonly folder: Folder
}

/**
 * Request parameters for createNote operation in NotesApi.
 * @export
 * @interface NotesApiCreateNoteRequest
 */
export interface NotesApiCreateNoteRequest {
    /**
     * 
     * @type {Note}
     * @memberof NotesApiCreateNote
     */
    readonly note: Note
}

/**
 * Request parameters for delete2 operation in NotesApi.
 * @export
 * @interface NotesApiDelete2Request
 */
export interface NotesApiDelete2Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiDelete2
     */
    readonly id: string
}

/**
 * Request parameters for findByFolder1 operation in NotesApi.
 * @export
 * @interface NotesApiFindByFolder1Request
 */
export interface NotesApiFindByFolder1Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiFindByFolder1
     */
    readonly folderId: string

    /**
     * 
     * @type {string}
     * @memberof NotesApiFindByFolder1
     */
    readonly ownerId: string
}

/**
 * Request parameters for get1 operation in NotesApi.
 * @export
 * @interface NotesApiGet1Request
 */
export interface NotesApiGet1Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiGet1
     */
    readonly ownerId: string
}

/**
 * Request parameters for update2 operation in NotesApi.
 * @export
 * @interface NotesApiUpdate2Request
 */
export interface NotesApiUpdate2Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiUpdate2
     */
    readonly id: string

    /**
     * 
     * @type {Note}
     * @memberof NotesApiUpdate2
     */
    readonly note: Note
}

/**
 * Request parameters for update3 operation in NotesApi.
 * @export
 * @interface NotesApiUpdate3Request
 */
export interface NotesApiUpdate3Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiUpdate3
     */
    readonly id: string

    /**
     * 
     * @type {Folder}
     * @memberof NotesApiUpdate3
     */
    readonly folder: Folder
}

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Folder
     * @param {NotesApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public _delete(requestParameters: NotesApiDeleteRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Folder
     * @param {NotesApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public createFolder(requestParameters: NotesApiCreateFolderRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).createFolder(requestParameters.folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Note
     * @param {NotesApiCreateNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public createNote(requestParameters: NotesApiCreateNoteRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).createNote(requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Note
     * @param {NotesApiDelete2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public delete2(requestParameters: NotesApiDelete2Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).delete2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find Notes by Owner
     * @param {NotesApiFindByFolder1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public findByFolder1(requestParameters: NotesApiFindByFolder1Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).findByFolder1(requestParameters.folderId, requestParameters.ownerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find a Folder by Owner
     * @param {NotesApiGet1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public get1(requestParameters: NotesApiGet1Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).get1(requestParameters.ownerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Note
     * @param {NotesApiUpdate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public update2(requestParameters: NotesApiUpdate2Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).update2(requestParameters.id, requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Folder
     * @param {NotesApiUpdate3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public update3(requestParameters: NotesApiUpdate3Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).update3(requestParameters.id, requestParameters.folder, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectiveSharingApi - axios parameter creator
 * @export
 */
export const ObjectiveSharingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared objectives by their manager
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedObjectivesForColleague: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getSharedObjectivesForColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/review-types/objective/sharing`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if colleague objectives is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isColleagueShareObjectives: async (cycleUuid: string, colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('isColleagueShareObjectives', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('isColleagueShareObjectives', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/objective/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareObjectives: async (cycleUuid: string, colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('shareObjectives', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('shareObjectives', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/objective/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop sharing colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSharingObjectives: async (cycleUuid: string, colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('stopSharingObjectives', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('stopSharingObjectives', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/objective/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectiveSharingApi - functional programming interface
 * @export
 */
export const ObjectiveSharingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectiveSharingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all shared objectives by their manager
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedObjectivesForColleague(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedObjectivesForColleague(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if colleague objectives is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isColleagueShareObjectives(cycleUuid: string, colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isColleagueShareObjectives(cycleUuid, colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareObjectives(cycleUuid: string, colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareObjectives(cycleUuid, colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop sharing colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopSharingObjectives(cycleUuid: string, colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopSharingObjectives(cycleUuid, colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ObjectiveSharingApi - factory interface
 * @export
 */
export const ObjectiveSharingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectiveSharingApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all shared objectives by their manager
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedObjectivesForColleague(colleagueUuid: string, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getSharedObjectivesForColleague(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if colleague objectives is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isColleagueShareObjectives(cycleUuid: string, colleagueUuid: string, options?: any): AxiosPromise<RestResponseBoolean> {
            return localVarFp.isColleagueShareObjectives(cycleUuid, colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareObjectives(cycleUuid: string, colleagueUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.shareObjectives(cycleUuid, colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop sharing colleague objectives
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSharingObjectives(cycleUuid: string, colleagueUuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.stopSharingObjectives(cycleUuid, colleagueUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSharedObjectivesForColleague operation in ObjectiveSharingApi.
 * @export
 * @interface ObjectiveSharingApiGetSharedObjectivesForColleagueRequest
 */
export interface ObjectiveSharingApiGetSharedObjectivesForColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiGetSharedObjectivesForColleague
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for isColleagueShareObjectives operation in ObjectiveSharingApi.
 * @export
 * @interface ObjectiveSharingApiIsColleagueShareObjectivesRequest
 */
export interface ObjectiveSharingApiIsColleagueShareObjectivesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiIsColleagueShareObjectives
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiIsColleagueShareObjectives
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for shareObjectives operation in ObjectiveSharingApi.
 * @export
 * @interface ObjectiveSharingApiShareObjectivesRequest
 */
export interface ObjectiveSharingApiShareObjectivesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiShareObjectives
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiShareObjectives
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for stopSharingObjectives operation in ObjectiveSharingApi.
 * @export
 * @interface ObjectiveSharingApiStopSharingObjectivesRequest
 */
export interface ObjectiveSharingApiStopSharingObjectivesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiStopSharingObjectives
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ObjectiveSharingApiStopSharingObjectives
     */
    readonly colleagueUuid: string
}

/**
 * ObjectiveSharingApi - object-oriented interface
 * @export
 * @class ObjectiveSharingApi
 * @extends {BaseAPI}
 */
export class ObjectiveSharingApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared objectives by their manager
     * @param {ObjectiveSharingApiGetSharedObjectivesForColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveSharingApi
     */
    public getSharedObjectivesForColleague(requestParameters: ObjectiveSharingApiGetSharedObjectivesForColleagueRequest, options?: AxiosRequestConfig) {
        return ObjectiveSharingApiFp(this.configuration).getSharedObjectivesForColleague(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if colleague objectives is shared
     * @param {ObjectiveSharingApiIsColleagueShareObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveSharingApi
     */
    public isColleagueShareObjectives(requestParameters: ObjectiveSharingApiIsColleagueShareObjectivesRequest, options?: AxiosRequestConfig) {
        return ObjectiveSharingApiFp(this.configuration).isColleagueShareObjectives(requestParameters.cycleUuid, requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share colleague objectives
     * @param {ObjectiveSharingApiShareObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveSharingApi
     */
    public shareObjectives(requestParameters: ObjectiveSharingApiShareObjectivesRequest, options?: AxiosRequestConfig) {
        return ObjectiveSharingApiFp(this.configuration).shareObjectives(requestParameters.cycleUuid, requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop sharing colleague objectives
     * @param {ObjectiveSharingApiStopSharingObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveSharingApi
     */
    public stopSharingObjectives(requestParameters: ObjectiveSharingApiStopSharingObjectivesRequest, options?: AxiosRequestConfig) {
        return ObjectiveSharingApiFp(this.configuration).stopSharingObjectives(requestParameters.cycleUuid, requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrgObjectiveApi - axios parameter creator
 * @export
 */
export const OrgObjectiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndPublishOrgObjectives: async (orgObjective: Array<OrgObjective>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgObjective' is not null or undefined
            assertParamExists('createAndPublishOrgObjectives', 'orgObjective', orgObjective)
            const localVarPath = `/org-objectives/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgObjective, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgObjectives: async (orgObjective: Array<OrgObjective>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgObjective' is not null or undefined
            assertParamExists('createOrgObjectives', 'orgObjective', orgObjective)
            const localVarPath = `/org-objectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgObjective, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAuditLogReport', 'requestQuery', requestQuery)
            const localVarPath = `/audit-logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgObjectiveApi - functional programming interface
 * @export
 */
export const OrgObjectiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgObjectiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndPublishOrgObjectives(orgObjective: Array<OrgObjective>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndPublishOrgObjectives(orgObjective, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgObjectives(orgObjective: Array<OrgObjective>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgObjectives(orgObjective, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListAuditOrgObjectiveReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrgObjectiveApi - factory interface
 * @export
 */
export const OrgObjectiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgObjectiveApiFp(configuration)
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndPublishOrgObjectives(orgObjective: Array<OrgObjective>, options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.createAndPublishOrgObjectives(orgObjective, options).then((request) => request(axios, basePath));
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgObjectives(orgObjective: Array<OrgObjective>, options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.createOrgObjectives(orgObjective, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListAuditOrgObjectiveReport> {
            return localVarFp.getAuditLogReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.getOrgObjectives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.getPublishedOrgObjectives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.publishOrgObjectives(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAndPublishOrgObjectives operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiCreateAndPublishOrgObjectivesRequest
 */
export interface OrgObjectiveApiCreateAndPublishOrgObjectivesRequest {
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof OrgObjectiveApiCreateAndPublishOrgObjectives
     */
    readonly orgObjective: Array<OrgObjective>
}

/**
 * Request parameters for createOrgObjectives operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiCreateOrgObjectivesRequest
 */
export interface OrgObjectiveApiCreateOrgObjectivesRequest {
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof OrgObjectiveApiCreateOrgObjectives
     */
    readonly orgObjective: Array<OrgObjective>
}

/**
 * Request parameters for getAuditLogReport operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiGetAuditLogReportRequest
 */
export interface OrgObjectiveApiGetAuditLogReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof OrgObjectiveApiGetAuditLogReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * OrgObjectiveApi - object-oriented interface
 * @export
 * @class OrgObjectiveApi
 * @extends {BaseAPI}
 */
export class OrgObjectiveApi extends BaseAPI {
    /**
     * 
     * @summary Create and publish organisation objectives
     * @param {OrgObjectiveApiCreateAndPublishOrgObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public createAndPublishOrgObjectives(requestParameters: OrgObjectiveApiCreateAndPublishOrgObjectivesRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).createAndPublishOrgObjectives(requestParameters.orgObjective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organisation objectives created
     * @summary Create new organisation objectives
     * @param {OrgObjectiveApiCreateOrgObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public createOrgObjectives(requestParameters: OrgObjectiveApiCreateOrgObjectivesRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).createOrgObjectives(requestParameters.orgObjective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get audit log of organisation objective actions
     * @param {OrgObjectiveApiGetAuditLogReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getAuditLogReport(requestParameters: OrgObjectiveApiGetAuditLogReportRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getAuditLogReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getPublishedOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getPublishedOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public publishOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).publishOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganisationDictionaryApi - axios parameter creator
 * @export
 */
export const OrganisationDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (organisationDictionary: OrganisationDictionary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationDictionary' is not null or undefined
            assertParamExists('create2', 'organisationDictionary', organisationDictionary)
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationDictionary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('delete7', 'code', code)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganisationDictionaries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganisationDictionary: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('findOrganisationDictionary', 'code', code)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: async (code: string, organisationDictionary: OrganisationDictionary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('update4', 'code', code)
            // verify required parameter 'organisationDictionary' is not null or undefined
            assertParamExists('update4', 'organisationDictionary', organisationDictionary)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationDictionary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationDictionaryApi - functional programming interface
 * @export
 */
export const OrganisationDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(organisationDictionary: OrganisationDictionary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(organisationDictionary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete7(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete7(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganisationDictionaries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganisationDictionaries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganisationDictionary(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganisationDictionary(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update4(code: string, organisationDictionary: OrganisationDictionary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update4(code, organisationDictionary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganisationDictionaryApi - factory interface
 * @export
 */
export const OrganisationDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationDictionaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(organisationDictionary: OrganisationDictionary, options?: any): AxiosPromise<RestResponseOrganisationDictionary> {
            return localVarFp.create2(organisationDictionary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(code: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.delete7(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganisationDictionaries(options?: any): AxiosPromise<RestResponseListOrganisationDictionary> {
            return localVarFp.findAllOrganisationDictionaries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganisationDictionary(code: string, options?: any): AxiosPromise<RestResponseOrganisationDictionary> {
            return localVarFp.findOrganisationDictionary(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(code: string, organisationDictionary: OrganisationDictionary, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.update4(code, organisationDictionary, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create2 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiCreate2Request
 */
export interface OrganisationDictionaryApiCreate2Request {
    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof OrganisationDictionaryApiCreate2
     */
    readonly organisationDictionary: OrganisationDictionary
}

/**
 * Request parameters for delete7 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiDelete7Request
 */
export interface OrganisationDictionaryApiDelete7Request {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiDelete7
     */
    readonly code: string
}

/**
 * Request parameters for findOrganisationDictionary operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiFindOrganisationDictionaryRequest
 */
export interface OrganisationDictionaryApiFindOrganisationDictionaryRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiFindOrganisationDictionary
     */
    readonly code: string
}

/**
 * Request parameters for update4 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiUpdate4Request
 */
export interface OrganisationDictionaryApiUpdate4Request {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiUpdate4
     */
    readonly code: string

    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof OrganisationDictionaryApiUpdate4
     */
    readonly organisationDictionary: OrganisationDictionary
}

/**
 * OrganisationDictionaryApi - object-oriented interface
 * @export
 * @class OrganisationDictionaryApi
 * @extends {BaseAPI}
 */
export class OrganisationDictionaryApi extends BaseAPI {
    /**
     * 
     * @summary Create organisation dictionary
     * @param {OrganisationDictionaryApiCreate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public create2(requestParameters: OrganisationDictionaryApiCreate2Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).create2(requestParameters.organisationDictionary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organisation dictionary
     * @param {OrganisationDictionaryApiDelete7Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public delete7(requestParameters: OrganisationDictionaryApiDelete7Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).delete7(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organisation dictionaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public findAllOrganisationDictionaries(options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).findAllOrganisationDictionaries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organisation dictionary by code
     * @param {OrganisationDictionaryApiFindOrganisationDictionaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public findOrganisationDictionary(requestParameters: OrganisationDictionaryApiFindOrganisationDictionaryRequest, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).findOrganisationDictionary(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organisation dictionary
     * @param {OrganisationDictionaryApiUpdate4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public update4(requestParameters: OrganisationDictionaryApiUpdate4Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).update4(requestParameters.code, requestParameters.organisationDictionary, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PdpApi - axios parameter creator
 * @export
 */
export const PdpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (pDPGoal: Array<PDPGoal>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pDPGoal' is not null or undefined
            assertParamExists('create1', 'pDPGoal', pDPGoal)
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pDPGoal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal: async (goalUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalUuid' is not null or undefined
            assertParamExists('deleteGoal', 'goalUuid', goalUuid)
            const localVarPath = `/pdp/goals/{goalUuid}`
                .replace(`{${"goalUuid"}}`, encodeURIComponent(String(goalUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTemplate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pdp/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal: async (number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getGoal', 'number', number)
            const localVarPath = `/pdp/goals/numbers/{number}`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal1: async (goalUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalUuid' is not null or undefined
            assertParamExists('getGoal1', 'goalUuid', goalUuid)
            const localVarPath = `/pdp/goals/{goalUuid}`
                .replace(`{${"goalUuid"}}`, encodeURIComponent(String(goalUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5: async (pDPGoal: Array<PDPGoal>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pDPGoal' is not null or undefined
            assertParamExists('update5', 'pDPGoal', pDPGoal)
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pDPGoal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PdpApi - functional programming interface
 * @export
 */
export const PdpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PdpApiAxiosParamCreator(configuration)
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(pDPGoal: Array<PDPGoal>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPDPGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(pDPGoal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoal(goalUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoal(goalUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTemplate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTemplate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoal(number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoal(number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoal1(goalUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoal1(goalUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoals(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoals(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update5(pDPGoal: Array<PDPGoal>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPDPGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update5(pDPGoal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PdpApi - factory interface
 * @export
 */
export const PdpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PdpApiFp(configuration)
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(pDPGoal: Array<PDPGoal>, options?: any): AxiosPromise<RestResponseListPDPGoal> {
            return localVarFp.create1(pDPGoal, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(goalUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteGoal(goalUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTemplate(options?: any): AxiosPromise<any> {
            return localVarFp.downloadTemplate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(number: number, options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoal(number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal1(goalUuid: string, options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoal1(goalUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoals(options).then((request) => request(axios, basePath));
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(pDPGoal: Array<PDPGoal>, options?: any): AxiosPromise<RestResponseListPDPGoal> {
            return localVarFp.update5(pDPGoal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create1 operation in PdpApi.
 * @export
 * @interface PdpApiCreate1Request
 */
export interface PdpApiCreate1Request {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PdpApiCreate1
     */
    readonly pDPGoal: Array<PDPGoal>
}

/**
 * Request parameters for deleteGoal operation in PdpApi.
 * @export
 * @interface PdpApiDeleteGoalRequest
 */
export interface PdpApiDeleteGoalRequest {
    /**
     * 
     * @type {string}
     * @memberof PdpApiDeleteGoal
     */
    readonly goalUuid: string
}

/**
 * Request parameters for getGoal operation in PdpApi.
 * @export
 * @interface PdpApiGetGoalRequest
 */
export interface PdpApiGetGoalRequest {
    /**
     * 
     * @type {number}
     * @memberof PdpApiGetGoal
     */
    readonly number: number
}

/**
 * Request parameters for getGoal1 operation in PdpApi.
 * @export
 * @interface PdpApiGetGoal1Request
 */
export interface PdpApiGetGoal1Request {
    /**
     * 
     * @type {string}
     * @memberof PdpApiGetGoal1
     */
    readonly goalUuid: string
}

/**
 * Request parameters for update5 operation in PdpApi.
 * @export
 * @interface PdpApiUpdate5Request
 */
export interface PdpApiUpdate5Request {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PdpApiUpdate5
     */
    readonly pDPGoal: Array<PDPGoal>
}

/**
 * PdpApi - object-oriented interface
 * @export
 * @class PdpApi
 * @extends {BaseAPI}
 */
export class PdpApi extends BaseAPI {
    /**
     * PDP created
     * @summary Create a PDP
     * @param {PdpApiCreate1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public create1(requestParameters: PdpApiCreate1Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).create1(requestParameters.pDPGoal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing PDP Goal
     * @summary Delete existing PDP Goal from a Plan by its uuid
     * @param {PdpApiDeleteGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public deleteGoal(requestParameters: PdpApiDeleteGoalRequest, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).deleteGoal(requestParameters.goalUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download PDP template file
     * @summary Download PDP template file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public downloadTemplate(options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).downloadTemplate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a PDP Goal by its colleague and number
     * @param {PdpApiGetGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoal(requestParameters: PdpApiGetGoalRequest, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoal(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a PDP Goal by its uuid
     * @param {PdpApiGetGoal1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoal1(requestParameters: PdpApiGetGoal1Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoal1(requestParameters.goalUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of PDP Goals by its colleague
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoals(options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PDP updated
     * @summary Update a PDP
     * @param {PdpApiUpdate5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public update5(requestParameters: PdpApiUpdate5Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).update5(requestParameters.pDPGoal, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PerformanceCycleApi - axios parameter creator
 * @export
 */
export const PerformanceCycleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('create', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy1: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deploy1', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}/deploy`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3: async (uuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('get3', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (requestQuery: RequestQuery, includeMetadata?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAll', 'requestQuery', requestQuery)
            const localVarPath = `/pm-cycles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleague: async (colleagueUuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getMetadataByColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/metadata`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMetadata: async (uuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPmCycleMetadata', 'uuid', uuid)
            const localVarPath = `/pm-cycles/files/{uuid}/metadata`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish1: async (pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('publish1', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('start', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}/start`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (uuid: string, pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('update', 'uuid', uuid)
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('update', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateStatus', 'uuid', uuid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateStatus', 'status', status)
            const localVarPath = `/pm-cycles/{uuid}/statuses/{status}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerformanceCycleApi - functional programming interface
 * @export
 */
export const PerformanceCycleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PerformanceCycleApiAxiosParamCreator(configuration)
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploy1(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUUID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploy1(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3(uuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3(uuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(requestQuery: RequestQuery, includeMetadata?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(requestQuery, includeMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataByColleague(colleagueUuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataByColleague(colleagueUuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmCycleMetadata(uuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmCycleMetadata(uuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish1(pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish1(pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async start(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.start(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(uuid: string, pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(uuid, pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatus(uuid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PerformanceCycleApi - factory interface
 * @export
 */
export const PerformanceCycleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PerformanceCycleApiFp(configuration)
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.create(pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy1(uuid: string, options?: any): AxiosPromise<RestResponseUUID> {
            return localVarFp.deploy1(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(uuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleResponse> {
            return localVarFp.get3(uuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(requestQuery: RequestQuery, includeMetadata?: boolean, options?: any): AxiosPromise<RestResponseListPMCycle> {
            return localVarFp.getAll(requestQuery, includeMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleague(colleagueUuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleMetadataResponse> {
            return localVarFp.getMetadataByColleague(colleagueUuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMetadata(uuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleMetadataResponse> {
            return localVarFp.getPmCycleMetadata(uuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish1(pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.publish1(pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(uuid: string, options?: any): AxiosPromise<RestResponseObject> {
            return localVarFp.start(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(uuid: string, pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.update(uuid, pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED', options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.updateStatus(uuid, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiCreateRequest
 */
export interface PerformanceCycleApiCreateRequest {
    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiCreate
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for deploy1 operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiDeploy1Request
 */
export interface PerformanceCycleApiDeploy1Request {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeploy1
     */
    readonly uuid: string
}

/**
 * Request parameters for get3 operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGet3Request
 */
export interface PerformanceCycleApiGet3Request {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGet3
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGet3
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getAll operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetAllRequest
 */
export interface PerformanceCycleApiGetAllRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof PerformanceCycleApiGetAll
     */
    readonly requestQuery: RequestQuery

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetAll
     */
    readonly includeMetadata?: boolean
}

/**
 * Request parameters for getMetadataByColleague operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetMetadataByColleagueRequest
 */
export interface PerformanceCycleApiGetMetadataByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetMetadataByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetMetadataByColleague
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getPmCycleMetadata operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetPmCycleMetadataRequest
 */
export interface PerformanceCycleApiGetPmCycleMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetPmCycleMetadata
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetPmCycleMetadata
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for publish1 operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiPublish1Request
 */
export interface PerformanceCycleApiPublish1Request {
    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiPublish1
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for start operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiStartRequest
 */
export interface PerformanceCycleApiStartRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiStart
     */
    readonly uuid: string
}

/**
 * Request parameters for update operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateRequest
 */
export interface PerformanceCycleApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdate
     */
    readonly uuid: string

    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiUpdate
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for updateStatus operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateStatusRequest
 */
export interface PerformanceCycleApiUpdateStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdateStatus
     */
    readonly uuid: string

    /**
     * 
     * @type {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED'}
     * @memberof PerformanceCycleApiUpdateStatus
     */
    readonly status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED'
}

/**
 * PerformanceCycleApi - object-oriented interface
 * @export
 * @class PerformanceCycleApi
 * @extends {BaseAPI}
 */
export class PerformanceCycleApi extends BaseAPI {
    /**
     * Performance cycle created
     * @summary Create performance cycle
     * @param {PerformanceCycleApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public create(requestParameters: PerformanceCycleApiCreateRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).create(requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle deployed
     * @summary Deploy performance cycle
     * @param {PerformanceCycleApiDeploy1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public deploy1(requestParameters: PerformanceCycleApiDeploy1Request, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).deploy1(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle by UUID
     * @param {PerformanceCycleApiGet3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public get3(requestParameters: PerformanceCycleApiGet3Request, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).get3(requestParameters.uuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all performance cycles
     * @param {PerformanceCycleApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getAll(requestParameters: PerformanceCycleApiGetAllRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getAll(requestParameters.requestQuery, requestParameters.includeMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get full metadata for colleague
     * @param {PerformanceCycleApiGetMetadataByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getMetadataByColleague(requestParameters: PerformanceCycleApiGetMetadataByColleagueRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getMetadataByColleague(requestParameters.colleagueUuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle metadata by file UUID
     * @param {PerformanceCycleApiGetPmCycleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getPmCycleMetadata(requestParameters: PerformanceCycleApiGetPmCycleMetadataRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getPmCycleMetadata(requestParameters.uuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle published
     * @summary Publish performance cycle
     * @param {PerformanceCycleApiPublish1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public publish1(requestParameters: PerformanceCycleApiPublish1Request, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).publish1(requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle started
     * @summary Start performance cycle
     * @param {PerformanceCycleApiStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public start(requestParameters: PerformanceCycleApiStartRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).start(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle edited
     * @summary Updates an existing performance cycle
     * @param {PerformanceCycleApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public update(requestParameters: PerformanceCycleApiUpdateRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).update(requestParameters.uuid, requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update performance cycle status
     * @param {PerformanceCycleApiUpdateStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public updateStatus(requestParameters: PerformanceCycleApiUpdateStatusRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).updateStatus(requestParameters.uuid, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessesApi - axios parameter creator
 * @export
 */
export const ProcessesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., TYPE_1, TYPE_2, TYPE_4
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (processKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processKey' is not null or undefined
            assertParamExists('getMetadata', 'processKey', processKey)
            const localVarPath = `/processes/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (processKey !== undefined) {
                localVarQueryParameter['process-key'] = processKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProcessByKey: async (processKey: string, params: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processKey' is not null or undefined
            assertParamExists('runProcessByKey', 'processKey', processKey)
            // verify required parameter 'params' is not null or undefined
            assertParamExists('runProcessByKey', 'params', params)
            const localVarPath = `/processes/keys/{process-key}`
                .replace(`{${"process-key"}}`, encodeURIComponent(String(processKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessesApi - functional programming interface
 * @export
 */
export const ProcessesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., TYPE_1, TYPE_2, TYPE_4
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(processKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycleMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(processKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runProcessByKey(processKey: string, params: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runProcessByKey(processKey, params, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessesApi - factory interface
 * @export
 */
export const ProcessesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., TYPE_1, TYPE_2, TYPE_4
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(processKey: string, options?: any): AxiosPromise<RestResponsePMCycleMetadata> {
            return localVarFp.getMetadata(processKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProcessByKey(processKey: string, params: object, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.runProcessByKey(processKey, params, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadata operation in ProcessesApi.
 * @export
 * @interface ProcessesApiGetMetadataRequest
 */
export interface ProcessesApiGetMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessesApiGetMetadata
     */
    readonly processKey: string
}

/**
 * Request parameters for runProcessByKey operation in ProcessesApi.
 * @export
 * @interface ProcessesApiRunProcessByKeyRequest
 */
export interface ProcessesApiRunProcessByKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessesApiRunProcessByKey
     */
    readonly processKey: string

    /**
     * 
     * @type {object}
     * @memberof ProcessesApiRunProcessByKey
     */
    readonly params: object
}

/**
 * ProcessesApi - object-oriented interface
 * @export
 * @class ProcessesApi
 * @extends {BaseAPI}
 */
export class ProcessesApi extends BaseAPI {
    /**
     * 
     * @summary Get process metadata by process key, e.g., TYPE_1, TYPE_2, TYPE_4
     * @param {ProcessesApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public getMetadata(requestParameters: ProcessesApiGetMetadataRequest, options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).getMetadata(requestParameters.processKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run process metadata by process key with parameters
     * @param {ProcessesApiRunProcessByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public runProcessByKey(requestParameters: ProcessesApiRunProcessByKeyRequest, options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).runProcessByKey(requestParameters.processKey, requestParameters.params, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileAttributes: async (colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('createProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'typedAttribute' is not null or undefined
            assertParamExists('createProfileAttributes', 'typedAttribute', typedAttribute)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileAttributes: async (colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('deleteProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'typedAttribute' is not null or undefined
            assertParamExists('deleteProfileAttributes', 'typedAttribute', typedAttribute)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequest: async (requestUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestUuid' is not null or undefined
            assertParamExists('getImportRequest', 'requestUuid', requestUuid)
            const localVarPath = `/colleagues/requests/{requestUuid}`
                .replace(`{${"requestUuid"}}`, encodeURIComponent(String(requestUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequestErrors: async (requestUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestUuid' is not null or undefined
            assertParamExists('getImportRequestErrors', 'requestUuid', requestUuid)
            const localVarPath = `/colleagues/requests/{requestUuid}/errors`
                .replace(`{${"requestUuid"}}`, encodeURIComponent(String(requestUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByColleagueUuid: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getProfileByColleagueUuid', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importColleagues: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileAttributes: async (colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'typedAttribute' is not null or undefined
            assertParamExists('updateProfileAttributes', 'typedAttribute', typedAttribute)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTypedAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileAttributes(colleagueUuid, typedAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTypedAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfileAttributes(colleagueUuid, typedAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportRequest(requestUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseImportRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportRequest(requestUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportRequestErrors(requestUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListImportError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportRequestErrors(requestUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileByColleagueUuid(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseColleagueProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileByColleagueUuid(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importColleagues(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseImportReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importColleagues(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTypedAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileAttributes(colleagueUuid, typedAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: any): AxiosPromise<RestResponseListTypedAttribute> {
            return localVarFp.createProfileAttributes(colleagueUuid, typedAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: any): AxiosPromise<RestResponseListTypedAttribute> {
            return localVarFp.deleteProfileAttributes(colleagueUuid, typedAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequest(requestUuid: string, options?: any): AxiosPromise<RestResponseImportRequest> {
            return localVarFp.getImportRequest(requestUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequestErrors(requestUuid: string, options?: any): AxiosPromise<RestResponseListImportError> {
            return localVarFp.getImportRequestErrors(requestUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByColleagueUuid(colleagueUuid: string, options?: any): AxiosPromise<RestResponseColleagueProfile> {
            return localVarFp.getProfileByColleagueUuid(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importColleagues(file?: any, options?: any): AxiosPromise<RestResponseImportReport> {
            return localVarFp.importColleagues(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<TypedAttribute>} typedAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileAttributes(colleagueUuid: string, typedAttribute: Array<TypedAttribute>, options?: any): AxiosPromise<RestResponseListTypedAttribute> {
            return localVarFp.updateProfileAttributes(colleagueUuid, typedAttribute, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiCreateProfileAttributesRequest
 */
export interface ProfileApiCreateProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiCreateProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof ProfileApiCreateProfileAttributes
     */
    readonly typedAttribute: Array<TypedAttribute>
}

/**
 * Request parameters for deleteProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiDeleteProfileAttributesRequest
 */
export interface ProfileApiDeleteProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiDeleteProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof ProfileApiDeleteProfileAttributes
     */
    readonly typedAttribute: Array<TypedAttribute>
}

/**
 * Request parameters for getImportRequest operation in ProfileApi.
 * @export
 * @interface ProfileApiGetImportRequestRequest
 */
export interface ProfileApiGetImportRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetImportRequest
     */
    readonly requestUuid: string
}

/**
 * Request parameters for getImportRequestErrors operation in ProfileApi.
 * @export
 * @interface ProfileApiGetImportRequestErrorsRequest
 */
export interface ProfileApiGetImportRequestErrorsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetImportRequestErrors
     */
    readonly requestUuid: string
}

/**
 * Request parameters for getProfileByColleagueUuid operation in ProfileApi.
 * @export
 * @interface ProfileApiGetProfileByColleagueUuidRequest
 */
export interface ProfileApiGetProfileByColleagueUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetProfileByColleagueUuid
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for importColleagues operation in ProfileApi.
 * @export
 * @interface ProfileApiImportColleaguesRequest
 */
export interface ProfileApiImportColleaguesRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfileApiImportColleagues
     */
    readonly file?: any
}

/**
 * Request parameters for updateProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiUpdateProfileAttributesRequest
 */
export interface ProfileApiUpdateProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiUpdateProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<TypedAttribute>}
     * @memberof ProfileApiUpdateProfileAttributes
     */
    readonly typedAttribute: Array<TypedAttribute>
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Profile attributes created
     * @summary Create new profile attributes
     * @param {ProfileApiCreateProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public createProfileAttributes(requestParameters: ProfileApiCreateProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).createProfileAttributes(requestParameters.colleagueUuid, requestParameters.typedAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing profile attributes
     * @summary Delete existing profile attributes
     * @param {ProfileApiDeleteProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public deleteProfileAttributes(requestParameters: ProfileApiDeleteProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).deleteProfileAttributes(requestParameters.colleagueUuid, requestParameters.typedAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get import request by uuid
     * @param {ProfileApiGetImportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getImportRequest(requestParameters: ProfileApiGetImportRequestRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getImportRequest(requestParameters.requestUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get import request errors by request uuid
     * @param {ProfileApiGetImportRequestErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getImportRequestErrors(requestParameters: ProfileApiGetImportRequestErrorsRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getImportRequestErrors(requestParameters.requestUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profile by colleague uuid
     * @summary Get profile by colleague uuid
     * @param {ProfileApiGetProfileByColleagueUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfileByColleagueUuid(requestParameters: ProfileApiGetProfileByColleagueUuidRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfileByColleagueUuid(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start import colleagues process
     * @param {ProfileApiImportColleaguesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public importColleagues(requestParameters: ProfileApiImportColleaguesRequest = {}, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).importColleagues(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing profile attributes
     * @summary Update existing profile attributes
     * @param {ProfileApiUpdateProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileAttributes(requestParameters: ProfileApiUpdateProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileAttributes(requestParameters.colleagueUuid, requestParameters.typedAttribute, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RatingApi - axios parameter creator
 * @export
 */
export const RatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overall: async (whatRating: string, howRating: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whatRating' is not null or undefined
            assertParamExists('overall', 'whatRating', whatRating)
            // verify required parameter 'howRating' is not null or undefined
            assertParamExists('overall', 'howRating', howRating)
            const localVarPath = `/reports/overall-rating`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (whatRating !== undefined) {
                localVarQueryParameter['what_rating'] = whatRating;
            }

            if (howRating !== undefined) {
                localVarQueryParameter['how_rating'] = howRating;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingApi - functional programming interface
 * @export
 */
export const RatingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overall(whatRating: string, howRating: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overall(whatRating, howRating, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RatingApi - factory interface
 * @export
 */
export const RatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingApiFp(configuration)
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overall(whatRating: string, howRating: string, options?: any): AxiosPromise<RestResponseMapStringString> {
            return localVarFp.overall(whatRating, howRating, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for overall operation in RatingApi.
 * @export
 * @interface RatingApiOverallRequest
 */
export interface RatingApiOverallRequest {
    /**
     * 
     * @type {string}
     * @memberof RatingApiOverall
     */
    readonly whatRating: string

    /**
     * 
     * @type {string}
     * @memberof RatingApiOverall
     */
    readonly howRating: string
}

/**
 * RatingApi - object-oriented interface
 * @export
 * @class RatingApi
 * @extends {BaseAPI}
 */
export class RatingApi extends BaseAPI {
    /**
     * 
     * @summary Get overall rating
     * @param {RatingApiOverallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public overall(requestParameters: RatingApiOverallRequest, options?: AxiosRequestConfig) {
        return RatingApiFp(this.configuration).overall(requestParameters.whatRating, requestParameters.howRating, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Linked Objectives Report Data by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportData: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getLinkedObjectivesReportData', 'requestQuery', requestQuery)
            const localVarPath = `/reports/linked-objective-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportFile: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getLinkedObjectivesReportFile', 'requestQuery', requestQuery)
            const localVarPath = `/reports/linked-objective-report/formats/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Linked Objectives Report Data by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedObjectivesReportData(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedObjectivesReportData(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedObjectivesReportFile(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedObjectivesReportFile(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Linked Objectives Report Data by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportData(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseReport> {
            return localVarFp.getLinkedObjectivesReportData(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportFile(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getLinkedObjectivesReportFile(requestQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLinkedObjectivesReportData operation in ReportApi.
 * @export
 * @interface ReportApiGetLinkedObjectivesReportDataRequest
 */
export interface ReportApiGetLinkedObjectivesReportDataRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetLinkedObjectivesReportData
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getLinkedObjectivesReportFile operation in ReportApi.
 * @export
 * @interface ReportApiGetLinkedObjectivesReportFileRequest
 */
export interface ReportApiGetLinkedObjectivesReportFileRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetLinkedObjectivesReportFile
     */
    readonly requestQuery: RequestQuery
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * 
     * @summary Get a Linked Objectives Report Data by year of cycle and statuses of review
     * @param {ReportApiGetLinkedObjectivesReportDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getLinkedObjectivesReportData(requestParameters: ReportApiGetLinkedObjectivesReportDataRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getLinkedObjectivesReportData(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Linked Objectives Report by year of cycle and statuses of review
     * @param {ReportApiGetLinkedObjectivesReportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getLinkedObjectivesReportFile(requestParameters: ReportApiGetLinkedObjectivesReportFileRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getLinkedObjectivesReportFile(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewApi - axios parameter creator
 * @export
 */
export const ReviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('createReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('createReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createReview', 'type', type)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('createReview', 'number', number)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('createReview', 'review', review)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/numbers/{number}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('delete3', 'fileUuid', fileUuid)
            const localVarPath = `/reviews/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('deleteReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('deleteReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteReview', 'type', type)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('deleteReview', 'number', number)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/numbers/{number}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('download', 'fileUuid', fileUuid)
            const localVarPath = `/reviews/files/{fileUuid}/download`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullTeamView: async (managerUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerUuid' is not null or undefined
            assertParamExists('getFullTeamView', 'managerUuid', managerUuid)
            const localVarPath = `/managers/{managerUuid}/full-team-reviews`
                .replace(`{${"managerUuid"}}`, encodeURIComponent(String(managerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getReview', 'type', type)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getReview', 'number', number)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/numbers/{number}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getReviewByUuid', 'uuid', uuid)
            const localVarPath = `/reviews/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getReviews', 'type', type)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByColleague: async (colleagueUuid: string, cycleUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviewsByColleague', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReviewsByColleague', 'cycleUuid', cycleUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleague: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviewsFilesByColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/reviews/files`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamView: async (managerUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerUuid' is not null or undefined
            assertParamExists('getTeamView', 'managerUuid', managerUuid)
            const localVarPath = `/managers/{managerUuid}/reviews`
                .replace(`{${"managerUuid"}}`, encodeURIComponent(String(managerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineByColleague: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getTimelineByColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/timeline`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateReview', 'type', type)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('updateReview', 'number', number)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('updateReview', 'review', review)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/numbers/{number}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {Array<Review>} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviews: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', review: Array<Review>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateReviews', 'type', type)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('updateReviews', 'review', review)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus: async (colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReviewsStatus', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReviewsStatus', 'cycleUuid', cycleUuid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateReviewsStatus', 'type', type)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateReviewsStatus', 'status', status)
            // verify required parameter 'updateReviewsStatusRequest' is not null or undefined
            assertParamExists('updateReviewsStatus', 'updateReviewsStatusRequest', updateReviewsStatusRequest)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-types/{type}/statuses/{status}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReviewsStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload Review Files
         * @summary Upload Review Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1: async (uploadMetadata?: any, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (uploadMetadata !== undefined) { 
                localVarFormParams.append('uploadMetadata', uploadMetadata as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewApi - functional programming interface
 * @export
 */
export const ReviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewApiAxiosParamCreator(configuration)
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(colleagueUuid, cycleUuid, type, number, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(colleagueUuid, cycleUuid, type, number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullTeamView(managerUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullTeamView(managerUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReview(colleagueUuid, cycleUuid, type, number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewByUuid(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewByUuid(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviews(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews(colleagueUuid, cycleUuid, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsByColleague(colleagueUuid: string, cycleUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsByColleague(colleagueUuid, cycleUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsFilesByColleague(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsFilesByColleague(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamView(managerUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamView(managerUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelineByColleague(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTimelinePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelineByColleague(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(colleagueUuid, cycleUuid, type, number, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {Array<Review>} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviews(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', review: Array<Review>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviews(colleagueUuid, cycleUuid, type, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviewsStatus(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMTimelinePointStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviewsStatus(colleagueUuid, cycleUuid, type, status, updateReviewsStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload Review Files
         * @summary Upload Review Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload1(uploadMetadata?: any, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload1(uploadMetadata, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewApi - factory interface
 * @export
 */
export const ReviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewApiFp(configuration)
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.createReview(colleagueUuid, cycleUuid, type, number, review, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(fileUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete3(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteReview(colleagueUuid, cycleUuid, type, number, options).then((request) => request(axios, basePath));
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(fileUuid: string, options?: any): AxiosPromise<any> {
            return localVarFp.download(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullTeamView(managerUuid: string, options?: any): AxiosPromise<RestResponseListColleagueView> {
            return localVarFp.getFullTeamView(managerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReview(colleagueUuid, cycleUuid, type, number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid(uuid: string, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReviewByUuid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getReviews(colleagueUuid, cycleUuid, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByColleague(colleagueUuid: string, cycleUuid: string, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getReviewsByColleague(colleagueUuid, cycleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleague(colleagueUuid: string, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.getReviewsFilesByColleague(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamView(managerUuid: string, options?: any): AxiosPromise<RestResponseListColleagueView> {
            return localVarFp.getTeamView(managerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineByColleague(colleagueUuid: string, options?: any): AxiosPromise<RestResponseListTimelinePoint> {
            return localVarFp.getTimelineByColleague(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', number: number, review: Review, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.updateReview(colleagueUuid, cycleUuid, type, number, review, options).then((request) => request(axios, basePath));
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {Array<Review>} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviews(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', review: Array<Review>, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.updateReviews(colleagueUuid, cycleUuid, type, review, options).then((request) => request(axios, basePath));
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'OBJECTIVE' | 'MYR' | 'EYR'} type 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus(colleagueUuid: string, cycleUuid: string, type: 'OBJECTIVE' | 'MYR' | 'EYR', status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: any): AxiosPromise<RestResponsePMTimelinePointStatus> {
            return localVarFp.updateReviewsStatus(colleagueUuid, cycleUuid, type, status, updateReviewsStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload Review Files
         * @summary Upload Review Files
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1(uploadMetadata?: any, files?: Array<any>, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.upload1(uploadMetadata, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReview operation in ReviewApi.
 * @export
 * @interface ReviewApiCreateReviewRequest
 */
export interface ReviewApiCreateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiCreateReview
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {number}
     * @memberof ReviewApiCreateReview
     */
    readonly number: number

    /**
     * 
     * @type {Review}
     * @memberof ReviewApiCreateReview
     */
    readonly review: Review
}

/**
 * Request parameters for delete3 operation in ReviewApi.
 * @export
 * @interface ReviewApiDelete3Request
 */
export interface ReviewApiDelete3Request {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDelete3
     */
    readonly fileUuid: string
}

/**
 * Request parameters for deleteReview operation in ReviewApi.
 * @export
 * @interface ReviewApiDeleteReviewRequest
 */
export interface ReviewApiDeleteReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiDeleteReview
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {number}
     * @memberof ReviewApiDeleteReview
     */
    readonly number: number
}

/**
 * Request parameters for download operation in ReviewApi.
 * @export
 * @interface ReviewApiDownloadRequest
 */
export interface ReviewApiDownloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDownload
     */
    readonly fileUuid: string
}

/**
 * Request parameters for getFullTeamView operation in ReviewApi.
 * @export
 * @interface ReviewApiGetFullTeamViewRequest
 */
export interface ReviewApiGetFullTeamViewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetFullTeamView
     */
    readonly managerUuid: string
}

/**
 * Request parameters for getReview operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewRequest
 */
export interface ReviewApiGetReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiGetReview
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {number}
     * @memberof ReviewApiGetReview
     */
    readonly number: number
}

/**
 * Request parameters for getReviewByUuid operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewByUuidRequest
 */
export interface ReviewApiGetReviewByUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewByUuid
     */
    readonly uuid: string
}

/**
 * Request parameters for getReviews operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsRequest
 */
export interface ReviewApiGetReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiGetReviews
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'
}

/**
 * Request parameters for getReviewsByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsByColleagueRequest
 */
export interface ReviewApiGetReviewsByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly cycleUuid: string
}

/**
 * Request parameters for getReviewsFilesByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsFilesByColleagueRequest
 */
export interface ReviewApiGetReviewsFilesByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsFilesByColleague
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for getTeamView operation in ReviewApi.
 * @export
 * @interface ReviewApiGetTeamViewRequest
 */
export interface ReviewApiGetTeamViewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetTeamView
     */
    readonly managerUuid: string
}

/**
 * Request parameters for getTimelineByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetTimelineByColleagueRequest
 */
export interface ReviewApiGetTimelineByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetTimelineByColleague
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for updateReview operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewRequest
 */
export interface ReviewApiUpdateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiUpdateReview
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {number}
     * @memberof ReviewApiUpdateReview
     */
    readonly number: number

    /**
     * 
     * @type {Review}
     * @memberof ReviewApiUpdateReview
     */
    readonly review: Review
}

/**
 * Request parameters for updateReviews operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewsRequest
 */
export interface ReviewApiUpdateReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiUpdateReviews
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {Array<Review>}
     * @memberof ReviewApiUpdateReviews
     */
    readonly review: Array<Review>
}

/**
 * Request parameters for updateReviewsStatus operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewsStatusRequest
 */
export interface ReviewApiUpdateReviewsStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'OBJECTIVE' | 'MYR' | 'EYR'}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly type: 'OBJECTIVE' | 'MYR' | 'EYR'

    /**
     * 
     * @type {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED'}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'COMPLETED' | 'OVERDUE' | 'STARTED' | 'NOT_STARTED' | 'NOT_CREATED'

    /**
     * 
     * @type {UpdateReviewsStatusRequest}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly updateReviewsStatusRequest: UpdateReviewsStatusRequest
}

/**
 * Request parameters for upload1 operation in ReviewApi.
 * @export
 * @interface ReviewApiUpload1Request
 */
export interface ReviewApiUpload1Request {
    /**
     * 
     * @type {any}
     * @memberof ReviewApiUpload1
     */
    readonly uploadMetadata?: any

    /**
     * 
     * @type {Array<any>}
     * @memberof ReviewApiUpload1
     */
    readonly files?: Array<any>
}

/**
 * ReviewApi - object-oriented interface
 * @export
 * @class ReviewApi
 * @extends {BaseAPI}
 */
export class ReviewApi extends BaseAPI {
    /**
     * Review created
     * @summary Create a review
     * @param {ReviewApiCreateReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public createReview(requestParameters: ReviewApiCreateReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).createReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.number, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Review File by its uuid
     * @param {ReviewApiDelete3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public delete3(requestParameters: ReviewApiDelete3Request, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).delete3(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing review
     * @summary Delete existing review
     * @param {ReviewApiDeleteReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public deleteReview(requestParameters: ReviewApiDeleteReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).deleteReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download Review File
     * @summary Download Review File
     * @param {ReviewApiDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public download(requestParameters: ReviewApiDownloadRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).download(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of full team reviews by managerUuid
     * @param {ReviewApiGetFullTeamViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getFullTeamView(requestParameters: ReviewApiGetFullTeamViewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getFullTeamView(requestParameters.managerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
     * @param {ReviewApiGetReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReview(requestParameters: ReviewApiGetReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a review by its identifier
     * @param {ReviewApiGetReviewByUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewByUuid(requestParameters: ReviewApiGetReviewByUuidRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewByUuid(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
     * @param {ReviewApiGetReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviews(requestParameters: ReviewApiGetReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviews(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by its cycleUuid, colleagueUuid
     * @param {ReviewApiGetReviewsByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewsByColleague(requestParameters: ReviewApiGetReviewsByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewsByColleague(requestParameters.colleagueUuid, requestParameters.cycleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by colleagueUuid
     * @param {ReviewApiGetReviewsFilesByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewsFilesByColleague(requestParameters: ReviewApiGetReviewsFilesByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewsFilesByColleague(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of colleagues reviews by managerUuid
     * @param {ReviewApiGetTeamViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getTeamView(requestParameters: ReviewApiGetTeamViewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getTeamView(requestParameters.managerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cycle timeline for colleague
     * @param {ReviewApiGetTimelineByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getTimelineByColleague(requestParameters: ReviewApiGetTimelineByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getTimelineByColleague(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing review
     * @summary Update existing review
     * @param {ReviewApiUpdateReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReview(requestParameters: ReviewApiUpdateReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.number, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update list of reviews
     * @summary Update list of reviews
     * @param {ReviewApiUpdateReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReviews(requestParameters: ReviewApiUpdateReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReviews(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update status of existing reviews
     * @summary Update status of existing reviews
     * @param {ReviewApiUpdateReviewsStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReviewsStatus(requestParameters: ReviewApiUpdateReviewsStatusRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReviewsStatus(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.type, requestParameters.status, requestParameters.updateReviewsStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload Review Files
     * @summary Upload Review Files
     * @param {ReviewApiUpload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public upload1(requestParameters: ReviewApiUpload1Request = {}, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).upload1(requestParameters.uploadMetadata, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpringRestEventListenerApi - axios parameter creator
 * @export
 */
export const SpringRestEventListenerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handle: async (event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('handle', 'event', event)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpringRestEventListenerApi - functional programming interface
 * @export
 */
export const SpringRestEventListenerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpringRestEventListenerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handle(event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handle(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpringRestEventListenerApi - factory interface
 * @export
 */
export const SpringRestEventListenerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpringRestEventListenerApiFp(configuration)
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handle(event: Event, options?: any): AxiosPromise<void> {
            return localVarFp.handle(event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for handle operation in SpringRestEventListenerApi.
 * @export
 * @interface SpringRestEventListenerApiHandleRequest
 */
export interface SpringRestEventListenerApiHandleRequest {
    /**
     * 
     * @type {Event}
     * @memberof SpringRestEventListenerApiHandle
     */
    readonly event: Event
}

/**
 * SpringRestEventListenerApi - object-oriented interface
 * @export
 * @class SpringRestEventListenerApi
 * @extends {BaseAPI}
 */
export class SpringRestEventListenerApi extends BaseAPI {
    /**
     * 
     * @param {SpringRestEventListenerApiHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpringRestEventListenerApi
     */
    public handle(requestParameters: SpringRestEventListenerApiHandleRequest, options?: AxiosRequestConfig) {
        return SpringRestEventListenerApiFp(this.configuration).handle(requestParameters.event, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TipApi - axios parameter creator
 * @export
 */
export const TipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (tip: Tip, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tip' is not null or undefined
            assertParamExists('create3', 'tip', tip)
            const localVarPath = `/tips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tip, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (uuid: string, withHistory?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('delete4', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withHistory !== undefined) {
                localVarQueryParameter['withHistory'] = withHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('publish', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}/publish`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read1: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('read1', 'requestQuery', requestQuery)
            const localVarPath = `/tips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read2: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('read2', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHistory: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('readHistory', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}/history`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipApi - functional programming interface
 * @export
 */
export const TipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TipApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(tip: Tip, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(tip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(uuid: string, withHistory?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete4(uuid, withHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read1(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read1(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read2(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read2(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readHistory(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readHistory(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TipApi - factory interface
 * @export
 */
export const TipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TipApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(tip: Tip, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.create3(tip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(uuid: string, withHistory?: boolean, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete4(uuid, withHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(uuid: string, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.publish(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read1(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListTip> {
            return localVarFp.read1(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read2(uuid: string, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.read2(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHistory(uuid: string, options?: any): AxiosPromise<RestResponseListTip> {
            return localVarFp.readHistory(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create3 operation in TipApi.
 * @export
 * @interface TipApiCreate3Request
 */
export interface TipApiCreate3Request {
    /**
     * 
     * @type {Tip}
     * @memberof TipApiCreate3
     */
    readonly tip: Tip
}

/**
 * Request parameters for delete4 operation in TipApi.
 * @export
 * @interface TipApiDelete4Request
 */
export interface TipApiDelete4Request {
    /**
     * 
     * @type {string}
     * @memberof TipApiDelete4
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof TipApiDelete4
     */
    readonly withHistory?: boolean
}

/**
 * Request parameters for publish operation in TipApi.
 * @export
 * @interface TipApiPublishRequest
 */
export interface TipApiPublishRequest {
    /**
     * 
     * @type {string}
     * @memberof TipApiPublish
     */
    readonly uuid: string
}

/**
 * Request parameters for read1 operation in TipApi.
 * @export
 * @interface TipApiRead1Request
 */
export interface TipApiRead1Request {
    /**
     * 
     * @type {RequestQuery}
     * @memberof TipApiRead1
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for read2 operation in TipApi.
 * @export
 * @interface TipApiRead2Request
 */
export interface TipApiRead2Request {
    /**
     * 
     * @type {string}
     * @memberof TipApiRead2
     */
    readonly uuid: string
}

/**
 * Request parameters for readHistory operation in TipApi.
 * @export
 * @interface TipApiReadHistoryRequest
 */
export interface TipApiReadHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof TipApiReadHistory
     */
    readonly uuid: string
}

/**
 * TipApi - object-oriented interface
 * @export
 * @class TipApi
 * @extends {BaseAPI}
 */
export class TipApi extends BaseAPI {
    /**
     * 
     * @summary Create a new tip or create a new version of an existing tip
     * @param {TipApiCreate3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public create3(requestParameters: TipApiCreate3Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).create3(requestParameters.tip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Tip
     * @param {TipApiDelete4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public delete4(requestParameters: TipApiDelete4Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).delete4(requestParameters.uuid, requestParameters.withHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish tip
     * @param {TipApiPublishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public publish(requestParameters: TipApiPublishRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).publish(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tips
     * @param {TipApiRead1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public read1(requestParameters: TipApiRead1Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).read1(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tip by uuid
     * @param {TipApiRead2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public read2(requestParameters: TipApiRead2Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).read2(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tip history
     * @param {TipApiReadHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public readHistory(requestParameters: TipApiReadHistoryRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).readHistory(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by colleague uuid
         * @summary Get user by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByColleagueUuid: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getUserByColleagueUuid', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/users/{colleagueUuid}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by iam id (TPX)
         * @summary Get user by iam id (TPX)
         * @param {string} iamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIamId: async (iamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iamId' is not null or undefined
            assertParamExists('getUserByIamId', 'iamId', iamId)
            const localVarPath = `/users/iam-ids/{iamId}`
                .replace(`{${"iamId"}}`, encodeURIComponent(String(iamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user by colleague uuid
         * @summary Get user by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByColleagueUuid(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByColleagueUuid(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user by iam id (TPX)
         * @summary Get user by iam id (TPX)
         * @param {string} iamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIamId(iamId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIamId(iamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<RestResponseUser> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by colleague uuid
         * @summary Get user by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByColleagueUuid(colleagueUuid: string, options?: any): AxiosPromise<RestResponseUser> {
            return localVarFp.getUserByColleagueUuid(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by iam id (TPX)
         * @summary Get user by iam id (TPX)
         * @param {string} iamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIamId(iamId: string, options?: any): AxiosPromise<RestResponseUser> {
            return localVarFp.getUserByIamId(iamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUserByColleagueUuid operation in UserApi.
 * @export
 * @interface UserApiGetUserByColleagueUuidRequest
 */
export interface UserApiGetUserByColleagueUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserByColleagueUuid
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for getUserByIamId operation in UserApi.
 * @export
 * @interface UserApiGetUserByIamIdRequest
 */
export interface UserApiGetUserByIamIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserByIamId
     */
    readonly iamId: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get user info for current authenticated user
     * @summary Get me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by colleague uuid
     * @summary Get user by colleague uuid
     * @param {UserApiGetUserByColleagueUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByColleagueUuid(requestParameters: UserApiGetUserByColleagueUuidRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByColleagueUuid(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by iam id (TPX)
     * @summary Get user by iam id (TPX)
     * @param {UserApiGetUserByIamIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByIamId(requestParameters: UserApiGetUserByIamIdRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByIamId(requestParameters.iamId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enable / Disable an account
         * @summary Enable / Disable an account
         * @param {ChangeAccountStatusRequest} changeAccountStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountStatus: async (changeAccountStatusRequest: ChangeAccountStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeAccountStatusRequest' is not null or undefined
            assertParamExists('changeAccountStatus', 'changeAccountStatusRequest', changeAccountStatusRequest)
            const localVarPath = `/user-management/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeAccountStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Account
         * @summary Create an Account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/user-management/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users, their status and access levels
         * @summary Get users, their status and access levels
         * @param {number} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (nextPageToken?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-management/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available access levels & metadata
         * @summary Get available access levels & metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-management/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add access to an account
         * @summary Add access to an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRole: async (roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('grantRole', 'roleRequest', roleRequest)
            const localVarPath = `/user-management/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove access from an account
         * @summary Remove access from an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeRole: async (roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('revokeRole', 'roleRequest', roleRequest)
            const localVarPath = `/user-management/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication additional-auth-jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization-App", configuration)

            // authentication bearer-jwt-identity required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Enable / Disable an account
         * @summary Enable / Disable an account
         * @param {ChangeAccountStatusRequest} changeAccountStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccountStatus(changeAccountStatusRequest: ChangeAccountStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAccountStatus(changeAccountStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an Account
         * @summary Create an Account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get users, their status and access levels
         * @summary Get users, their status and access levels
         * @param {number} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(nextPageToken?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtendedRestResponseListAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(nextPageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Available access levels & metadata
         * @summary Get available access levels & metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add access to an account
         * @summary Add access to an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantRole(roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantRole(roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove access from an account
         * @summary Remove access from an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeRole(roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeRole(roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * Enable / Disable an account
         * @summary Enable / Disable an account
         * @param {ChangeAccountStatusRequest} changeAccountStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountStatus(changeAccountStatusRequest: ChangeAccountStatusRequest, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.changeAccountStatus(changeAccountStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Account
         * @summary Create an Account
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users, their status and access levels
         * @summary Get users, their status and access levels
         * @param {number} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(nextPageToken?: number, options?: any): AxiosPromise<ExtendedRestResponseListAccount> {
            return localVarFp.getAccounts(nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Available access levels & metadata
         * @summary Get available access levels & metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): AxiosPromise<RestResponseListRole> {
            return localVarFp.getRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Add access to an account
         * @summary Add access to an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRole(roleRequest: RoleRequest, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.grantRole(roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove access from an account
         * @summary Remove access from an account
         * @param {RoleRequest} roleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeRole(roleRequest: RoleRequest, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.revokeRole(roleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changeAccountStatus operation in UserManagementApi.
 * @export
 * @interface UserManagementApiChangeAccountStatusRequest
 */
export interface UserManagementApiChangeAccountStatusRequest {
    /**
     * 
     * @type {ChangeAccountStatusRequest}
     * @memberof UserManagementApiChangeAccountStatus
     */
    readonly changeAccountStatusRequest: ChangeAccountStatusRequest
}

/**
 * Request parameters for createAccount operation in UserManagementApi.
 * @export
 * @interface UserManagementApiCreateAccountRequest
 */
export interface UserManagementApiCreateAccountRequest {
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof UserManagementApiCreateAccount
     */
    readonly createAccountRequest: CreateAccountRequest
}

/**
 * Request parameters for getAccounts operation in UserManagementApi.
 * @export
 * @interface UserManagementApiGetAccountsRequest
 */
export interface UserManagementApiGetAccountsRequest {
    /**
     * 
     * @type {number}
     * @memberof UserManagementApiGetAccounts
     */
    readonly nextPageToken?: number
}

/**
 * Request parameters for grantRole operation in UserManagementApi.
 * @export
 * @interface UserManagementApiGrantRoleRequest
 */
export interface UserManagementApiGrantRoleRequest {
    /**
     * 
     * @type {RoleRequest}
     * @memberof UserManagementApiGrantRole
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for revokeRole operation in UserManagementApi.
 * @export
 * @interface UserManagementApiRevokeRoleRequest
 */
export interface UserManagementApiRevokeRoleRequest {
    /**
     * 
     * @type {RoleRequest}
     * @memberof UserManagementApiRevokeRole
     */
    readonly roleRequest: RoleRequest
}

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
    /**
     * Enable / Disable an account
     * @summary Enable / Disable an account
     * @param {UserManagementApiChangeAccountStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public changeAccountStatus(requestParameters: UserManagementApiChangeAccountStatusRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).changeAccountStatus(requestParameters.changeAccountStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Account
     * @summary Create an Account
     * @param {UserManagementApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public createAccount(requestParameters: UserManagementApiCreateAccountRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).createAccount(requestParameters.createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users, their status and access levels
     * @summary Get users, their status and access levels
     * @param {UserManagementApiGetAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getAccounts(requestParameters: UserManagementApiGetAccountsRequest = {}, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getAccounts(requestParameters.nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available access levels & metadata
     * @summary Get available access levels & metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getRoles(options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add access to an account
     * @summary Add access to an account
     * @param {UserManagementApiGrantRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public grantRole(requestParameters: UserManagementApiGrantRoleRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).grantRole(requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove access from an account
     * @summary Remove access from an account
     * @param {UserManagementApiRevokeRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public revokeRole(requestParameters: UserManagementApiRevokeRoleRequest, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).revokeRole(requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


