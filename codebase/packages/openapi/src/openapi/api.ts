/* tslint:disable */
/* eslint-disable */
/**
 * PMA API
 * Documentation PMA API v1.0
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {Array<string>}
     * @memberof Address
     */
    'lines'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'target'?: string;
    /**
     * 
     * @type {Array<ErrorDetail>}
     * @memberof ApiError
     */
    'details'?: Array<ErrorDetail>;
}
/**
 * 
 * @export
 * @interface AuditOrgObjectiveReport
 */
export interface AuditOrgObjectiveReport {
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof AuditOrgObjectiveReport
     */
    'updatedBy'?: ColleagueSimple;
    /**
     * 
     * @type {string}
     * @memberof AuditOrgObjectiveReport
     */
    'updatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditOrgObjectiveReport
     */
    'action'?: AuditOrgObjectiveReportActionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AuditOrgObjectiveReportActionEnum {
    SaveAsDraft = 'SAVE_AS_DRAFT',
    Publish = 'PUBLISH',
    Unpublish = 'UNPUBLISH'
}

/**
 * 
 * @export
 * @interface BusinessGroup
 */
export interface BusinessGroup {
    /**
     * 
     * @type {string}
     * @memberof BusinessGroup
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessGroup
     */
    'name'?: string;
    /**
     * 
     * @type {Set<Department>}
     * @memberof BusinessGroup
     */
    'departments'?: Set<Department>;
}
/**
 * 
 * @export
 * @interface CalibrationColleague
 */
export interface CalibrationColleague {
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof CalibrationColleague
     */
    'colleague'?: ColleagueSimple;
    /**
     * 
     * @type {string}
     * @memberof CalibrationColleague
     */
    'sessionUuid'?: string;
}
/**
 * 
 * @export
 * @interface CalibrationSession
 */
export interface CalibrationSession {
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'status'?: CalibrationSessionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalibrationSession
     */
    'ownerUuid'?: string;
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationSession
     */
    'participants'?: RequestQuery;
}

/**
    * @export
    * @enum {string}
    */
export enum CalibrationSessionStatusEnum {
    Created = 'CREATED',
    Started = 'STARTED',
    Updated = 'UPDATED',
    Completed = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface Colleague
 */
export interface Colleague {
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'colleagueUUID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'employeeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Colleague
     */
    'countryCode'?: string;
    /**
     * 
     * @type {Effectivity}
     * @memberof Colleague
     */
    'effectivity'?: Effectivity;
    /**
     * 
     * @type {ExternalSystems}
     * @memberof Colleague
     */
    'externalSystems'?: ExternalSystems;
    /**
     * 
     * @type {Profile}
     * @memberof Colleague
     */
    'profile'?: Profile;
    /**
     * 
     * @type {Contact}
     * @memberof Colleague
     */
    'contact'?: Contact;
    /**
     * 
     * @type {ServiceDates}
     * @memberof Colleague
     */
    'serviceDates'?: ServiceDates;
    /**
     * 
     * @type {Array<WorkRelationship>}
     * @memberof Colleague
     */
    'workRelationships'?: Array<WorkRelationship>;
    /**
     * 
     * @type {Array<Skill>}
     * @memberof Colleague
     */
    'skills'?: Array<Skill>;
}
/**
 * 
 * @export
 * @interface ColleagueChangeEventPayload
 */
export interface ColleagueChangeEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'eventType'?: ColleagueChangeEventPayloadEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'effectiveTo'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ColleagueChangeEventPayload
     */
    'changedAttributes'?: Array<string>;
    /**
     * 
     * @type {Colleague}
     * @memberof ColleagueChangeEventPayload
     */
    'previous'?: Colleague;
    /**
     * 
     * @type {Colleague}
     * @memberof ColleagueChangeEventPayload
     */
    'current'?: Colleague;
    /**
     * 
     * @type {string}
     * @memberof ColleagueChangeEventPayload
     */
    'colleagueUUID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ColleagueChangeEventPayload
     */
    'subcategories'?: Array<ColleagueChangeEventPayloadSubcategoriesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ColleagueChangeEventPayloadEventTypeEnum {
    Joiner = 'Joiner',
    FutureJoiner = 'FutureJoiner',
    FutureJoinerModification = 'FutureJoinerModification',
    Leaver = 'Leaver',
    FutureLeaver = 'FutureLeaver',
    FutureLeaverCancelled = 'FutureLeaverCancelled',
    Modification = 'Modification',
    FutureModification = 'FutureModification',
    SourceSystemModification = 'SourceSystemModification',
    Deletion = 'Deletion'
}
/**
    * @export
    * @enum {string}
    */
export enum ColleagueChangeEventPayloadSubcategoriesEnum {
    NewJoiner = 'newJoiner',
    ImportedInCf = 'importedInCF',
    Reinstatement = 'reinstatement',
    DepartmentUpdate = 'departmentUpdate',
    JobUpdate = 'jobUpdate',
    PositionUpdate = 'positionUpdate',
    ProfileUpdate = 'profileUpdate',
    ContactUpdate = 'contactUpdate',
    SkillsUpdate = 'skillsUpdate',
    ExternalSystemsUpdate = 'externalSystemsUpdate',
    ContractUpdate = 'contractUpdate',
    WorkRelationshipUpdate = 'workRelationshipUpdate',
    Other = 'other',
    SourceSystemUpdate = 'sourceSystemUpdate'
}

/**
 * 
 * @export
 * @interface ColleagueEntity
 */
export interface ColleagueEntity {
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'email'?: string;
    /**
     * 
     * @type {WorkLevel}
     * @memberof ColleagueEntity
     */
    'workLevel'?: WorkLevel;
    /**
     * 
     * @type {PrimaryEntity}
     * @memberof ColleagueEntity
     */
    'primaryEntity'?: PrimaryEntity;
    /**
     * 
     * @type {Country}
     * @memberof ColleagueEntity
     */
    'country'?: Country;
    /**
     * 
     * @type {Department}
     * @memberof ColleagueEntity
     */
    'department'?: Department;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'salaryFrequency'?: string;
    /**
     * 
     * @type {Job}
     * @memberof ColleagueEntity
     */
    'job'?: Job;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'iamSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'iamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'managerUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'employmentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'hireDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'leavingDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ColleagueEntity
     */
    'manager'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'locationId'?: string;
    /**
     * 
     * @type {LegalEntity}
     * @memberof ColleagueEntity
     */
    'legalEntity'?: LegalEntity;
    /**
     * 
     * @type {Array<Skill>}
     * @memberof ColleagueEntity
     */
    'skills'?: Array<Skill>;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'colleagueType'?: ColleagueEntityColleagueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueEntity
     */
    'md5sum'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ColleagueEntityColleagueTypeEnum {
    Employee = 'EMPLOYEE',
    External = 'EXTERNAL',
    Contractor = 'CONTRACTOR'
}

/**
 * 
 * @export
 * @interface ColleagueFilterOptions
 */
export interface ColleagueFilterOptions {
    /**
     * 
     * @type {Set<Function>}
     * @memberof ColleagueFilterOptions
     */
    'functions'?: Set<Function>;
    /**
     * 
     * @type {Set<Department>}
     * @memberof ColleagueFilterOptions
     */
    'departments'?: Set<Department>;
    /**
     * 
     * @type {Set<Country>}
     * @memberof ColleagueFilterOptions
     */
    'countries'?: Set<Country>;
    /**
     * 
     * @type {Set<LegalEntity>}
     * @memberof ColleagueFilterOptions
     */
    'legal-entities'?: Set<LegalEntity>;
    /**
     * 
     * @type {Set<BusinessGroup>}
     * @memberof ColleagueFilterOptions
     */
    'business-groups'?: Set<BusinessGroup>;
    /**
     * 
     * @type {Set<ColleagueSimple>}
     * @memberof ColleagueFilterOptions
     */
    'line-managers'?: Set<ColleagueSimple>;
    /**
     * 
     * @type {Set<WorkLevel>}
     * @memberof ColleagueFilterOptions
     */
    'work-levels'?: Set<WorkLevel>;
}
/**
 * 
 * @export
 * @interface ColleagueProfile
 */
export interface ColleagueProfile {
    /**
     * 
     * @type {Colleague}
     * @memberof ColleagueProfile
     */
    'colleague'?: Colleague;
    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof ColleagueProfile
     */
    'profileAttributes'?: Array<OwnersTypedAttributeUUID>;
    /**
     * 
     * @type {Tenant}
     * @memberof ColleagueProfile
     */
    'tenant'?: Tenant;
}
/**
 * 
 * @export
 * @interface ColleagueReportTargeting
 */
export interface ColleagueReportTargeting {
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueReportTargeting
     */
    'businessType'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueReportTargeting
     */
    'lineManager'?: ColleagueSimple;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ColleagueReportTargeting
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ColleagueReview
 */
export interface ColleagueReview {
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueReview
     */
    'colleague'?: ColleagueSimple;
    /**
     * 
     * @type {Review}
     * @memberof ColleagueReview
     */
    'review'?: Review;
}
/**
 * 
 * @export
 * @interface ColleagueSimple
 */
export interface ColleagueSimple {
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueSimple
     */
    'businessType'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueSimple
     */
    'lineManager'?: ColleagueSimple;
}
/**
 * 
 * @export
 * @interface ColleagueTenant
 */
export interface ColleagueTenant {
    /**
     * 
     * @type {string}
     * @memberof ColleagueTenant
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {Tenant}
     * @memberof ColleagueTenant
     */
    'tenant'?: Tenant;
}
/**
 * 
 * @export
 * @interface ColleagueView
 */
export interface ColleagueView {
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColleagueView
     */
    'businessType'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof ColleagueView
     */
    'lineManager'?: ColleagueSimple;
    /**
     * 
     * @type {Array<SimplifiedReview>}
     * @memberof ColleagueView
     */
    'reviews'?: Array<SimplifiedReview>;
    /**
     * 
     * @type {Array<TimelinePoint>}
     * @memberof ColleagueView
     */
    'timeline'?: Array<TimelinePoint>;
}
/**
 * 
 * @export
 * @interface CompositePMCycleMetadataResponse
 */
export interface CompositePMCycleMetadataResponse {
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof CompositePMCycleMetadataResponse
     */
    'metadata'?: PMCycleMetadata;
    /**
     * 
     * @type {Array<PMForm>}
     * @memberof CompositePMCycleMetadataResponse
     */
    'forms'?: Array<PMForm>;
}
/**
 * 
 * @export
 * @interface CompositePMCycleResponse
 */
export interface CompositePMCycleResponse {
    /**
     * 
     * @type {PMCycle}
     * @memberof CompositePMCycleResponse
     */
    'cycle'?: PMCycle;
    /**
     * 
     * @type {Array<PMForm>}
     * @memberof CompositePMCycleResponse
     */
    'forms'?: Array<PMForm>;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'property'?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'operand'?: ConditionOperandEnum;
    /**
     * 
     * @type {object}
     * @memberof Condition
     */
    'value'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConditionOperandEnum {
    Equals = 'EQUALS',
    NotEquals = 'NOT_EQUALS',
    Contains = 'CONTAINS',
    NotContains = 'NOT_CONTAINS',
    In = 'IN',
    NotIn = 'NOT_IN',
    LessThan = 'LESS_THAN',
    LessThanEquals = 'LESS_THAN_EQUALS',
    GreaterThan = 'GREATER_THAN',
    GreaterThanEquals = 'GREATER_THAN_EQUALS',
    Like = 'LIKE',
    Null = 'NULL'
}

/**
 * 
 * @export
 * @interface ConditionGroup
 */
export interface ConditionGroup {
    /**
     * 
     * @type {Array<Condition>}
     * @memberof ConditionGroup
     */
    'filters'?: Array<Condition>;
    /**
     * 
     * @type {string}
     * @memberof ConditionGroup
     */
    '_type'?: ConditionGroupTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ConditionGroupTypeEnum {
    Or = 'OR',
    And = 'AND'
}

/**
 * 
 * @export
 * @interface ConfigEntry
 */
export interface ConfigEntry {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'name'?: string;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof ConfigEntry
     */
    'type'?: GeneralDictionaryItem;
    /**
     * 
     * @type {number}
     * @memberof ConfigEntry
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'parentUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'compositeKey'?: string;
}
/**
 * 
 * @export
 * @interface ConfigEntryResponse
 */
export interface ConfigEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof ConfigEntryResponse
     */
    'type'?: GeneralDictionaryItem;
    /**
     * 
     * @type {number}
     * @memberof ConfigEntryResponse
     */
    'version'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigEntryResponse
     */
    'root'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryResponse
     */
    'compositeKey'?: string;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'workPhoneNumber'?: string;
    /**
     * 
     * @type {Array<Address>}
     * @memberof Contact
     */
    'addresses'?: Array<Address>;
}
/**
 * 
 * @export
 * @interface ContentEntry
 */
export interface ContentEntry {
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentEntry
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'status'?: ContentEntryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'contentEntryType'?: ContentEntryContentEntryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentEntry
     */
    'createdTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ContentEntry
     */
    'properties'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum ContentEntryStatusEnum {
    Draft = 'DRAFT',
    Published = 'PUBLISHED',
    Unpublished = 'UNPUBLISHED'
}
/**
    * @export
    * @enum {string}
    */
export enum ContentEntryContentEntryTypeEnum {
    General = 'GENERAL',
    Menu = 'MENU'
}

/**
 * 
 * @export
 * @interface ContractType
 */
export interface ContractType {
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'sourceCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'sourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractType
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface DecisionInfo
 */
export interface DecisionInfo {
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DecisionInfo
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'resourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'deploymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'versionTag'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'diagramResourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DecisionInfo
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'businessType'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentInfo
 */
export interface DeploymentInfo {
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'deploymentTime'?: string;
}
/**
 * 
 * @export
 * @interface Effectivity
 */
export interface Effectivity {
    /**
     * 
     * @type {string}
     * @memberof Effectivity
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof Effectivity
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentHealth
 */
export interface EnvironmentHealth {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentHealth
     */
    'status'?: EnvironmentHealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentHealth
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EnvironmentHealth
     */
    'build'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EnvironmentHealth
     */
    'os'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum EnvironmentHealthStatusEnum {
    Ok = 'Ok',
    Fail = 'Fail',
    Degraded = 'Degraded'
}

/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventId'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Event
     */
    'eventProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {Event}
     * @memberof Event
     */
    'callbackEvent'?: Event;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventPriority'?: EventEventPriorityEnum;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventCreationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'callbackServiceURL'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EventEventPriorityEnum {
    Highest = 'HIGHEST',
    HighH = 'HIGH_H',
    High = 'HIGH',
    HighL = 'HIGH_L',
    NormalH = 'NORMAL_H',
    Normal = 'NORMAL',
    NormalL = 'NORMAL_L',
    LowH = 'LOW_H',
    Low = 'LOW',
    LowL = 'LOW_L',
    Lowest = 'LOWEST'
}

/**
 * 
 * @export
 * @interface ExternalSystems
 */
export interface ExternalSystems {
    /**
     * 
     * @type {string}
     * @memberof ExternalSystems
     */
    'sourceSystem'?: string;
    /**
     * 
     * @type {IamSourceSystem}
     * @memberof ExternalSystems
     */
    'iam'?: IamSourceSystem;
}
/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'uuid'?: string;
    /**
     * Author. Colleague from whom feedback is written or requested.
     * @type {string}
     * @memberof Feedback
     */
    'colleagueUuid': string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof Feedback
     */
    'colleagueProfile'?: ColleagueProfile;
    /**
     * Colleague to whom feedback is given.
     * @type {string}
     * @memberof Feedback
     */
    'targetColleagueUuid': string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof Feedback
     */
    'targetColleagueProfile'?: ColleagueProfile;
    /**
     * Target type: GOAL, OBJECTIVE, VALUE_BEHAVIOR, OTHER.
     * @type {string}
     * @memberof Feedback
     */
    'targetType'?: FeedbackTargetTypeEnum;
    /**
     * Object identifier that is feedback given on/to or requested about/from.
     * @type {string}
     * @memberof Feedback
     */
    'targetId'?: string;
    /**
     * Checkbox. False for Unread feedback.
     * @type {boolean}
     * @memberof Feedback
     */
    'read'?: boolean;
    /**
     * Status: DRAFT, SUBMITTED, PENDING, COMPLETED.
     * @type {string}
     * @memberof Feedback
     */
    'status': FeedbackStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'createdTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'updatedTime'?: string;
    /**
     * 
     * @type {Set<FeedbackItem>}
     * @memberof Feedback
     */
    'feedbackItems'?: Set<FeedbackItem>;
}

/**
    * @export
    * @enum {string}
    */
export enum FeedbackTargetTypeEnum {
    Goal = 'GOAL',
    Objective = 'OBJECTIVE',
    ValueBehavior = 'VALUE_BEHAVIOR',
    Other = 'OTHER'
}
/**
    * @export
    * @enum {string}
    */
export enum FeedbackStatusEnum {
    Draft = 'DRAFT',
    Submitted = 'SUBMITTED',
    Pending = 'PENDING',
    Completed = 'COMPLETED'
}

/**
 * The Feedback Item. Answers for questions, comments or free form feedback.
 * @export
 * @interface FeedbackItem
 */
export interface FeedbackItem {
    /**
     * 
     * @type {string}
     * @memberof FeedbackItem
     */
    'uuid'?: string;
    /**
     * Item code. For example, whatWellDone, whatFocusOn, comment or question1, etc.
     * @type {string}
     * @memberof FeedbackItem
     */
    'code': string;
    /**
     * Body of feedback item. Answer for question or comment.
     * @type {string}
     * @memberof FeedbackItem
     */
    'content'?: string;
    /**
     * Link to feedback
     * @type {string}
     * @memberof FeedbackItem
     */
    'feedbackUuid'?: string;
}
/**
 * 
 * @export
 * @interface FileType
 */
export interface FileType {
    /**
     * 
     * @type {number}
     * @memberof FileType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'ownerColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'parentFolderUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'name'?: string;
    /**
     * 
     * @type {Set<BusinessGroup>}
     * @memberof Function
     */
    'businessGroups'?: Set<BusinessGroup>;
    /**
     * 
     * @type {Set<Department>}
     * @memberof Function
     */
    'departments'?: Set<Department>;
}
/**
 * 
 * @export
 * @interface GeneralDictionaryItem
 */
export interface GeneralDictionaryItem {
    /**
     * 
     * @type {number}
     * @memberof GeneralDictionaryItem
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GeneralDictionaryItem
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeneralDictionaryItem
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Grade
 */
export interface Grade {
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'type'?: HealthTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'status'?: HealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'checked'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Health
     */
    'error'?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum HealthTypeEnum {
    Service = 'SERVICE',
    Component = 'COMPONENT',
    Dependency = 'DEPENDENCY'
}
/**
    * @export
    * @enum {string}
    */
export enum HealthStatusEnum {
    Ok = 'Ok',
    Fail = 'Fail',
    Degraded = 'Degraded'
}

/**
 * 
 * @export
 * @interface IamSourceSystem
 */
export interface IamSourceSystem {
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamSourceSystem
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface ImportError
 */
export interface ImportError {
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'requestUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'fieldSetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ImportReport
 */
export interface ImportReport {
    /**
     * 
     * @type {string}
     * @memberof ImportReport
     */
    'requestUuid'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof ImportReport
     */
    'imported'?: Set<string>;
    /**
     * 
     * @type {Set<ImportError>}
     * @memberof ImportReport
     */
    'skipped'?: Set<ImportError>;
    /**
     * 
     * @type {Set<ImportError>}
     * @memberof ImportReport
     */
    'warn'?: Set<ImportError>;
}
/**
 * 
 * @export
 * @interface ImportRequest
 */
export interface ImportRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'status'?: ImportRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequest
     */
    'lastUpdateTime'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ImportRequestStatusEnum {
    Registered = 'REGISTERED',
    InProgress = 'IN_PROGRESS',
    Processed = 'PROCESSED',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'costCategory'?: string;
}
/**
 * 
 * @export
 * @interface LegalEmployer
 */
export interface LegalEmployer {
    /**
     * 
     * @type {number}
     * @memberof LegalEmployer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LegalEmployer
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface LegalEntity
 */
export interface LegalEntity {
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegalEntity
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'fileName'?: string;
    /**
     * 
     * @type {FileType}
     * @memberof ModelFile
     */
    'type'?: FileType;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'status'?: ModelFileStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'fileDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'uuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'version'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'fileLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createdTime'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelFile
     */
    'fileContent'?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelFileStatusEnum {
    Draft = 'DRAFT',
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}

/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'ownerColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'referenceColleagueUuid'?: string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof Note
     */
    'referenceColleagueProfile'?: ColleagueProfile;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'status'?: NoteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'folderUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'content'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NoteStatusEnum {
    Created = 'CREATED',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface OrgHierarchy
 */
export interface OrgHierarchy {
    /**
     * 
     * @type {string}
     * @memberof OrgHierarchy
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgHierarchy
     */
    'name'?: string;
    /**
     * 
     * @type {Set<Function>}
     * @memberof OrgHierarchy
     */
    'functions'?: Set<Function>;
}
/**
 * 
 * @export
 * @interface OrgMapping
 */
export interface OrgMapping {
    /**
     * 
     * @type {LegalEntity}
     * @memberof OrgMapping
     */
    'legalEntity'?: LegalEntity;
    /**
     * 
     * @type {Function}
     * @memberof OrgMapping
     */
    'function'?: Function;
    /**
     * 
     * @type {BusinessGroup}
     * @memberof OrgMapping
     */
    'businessGroup'?: BusinessGroup;
    /**
     * 
     * @type {Department}
     * @memberof OrgMapping
     */
    'department'?: Department;
}
/**
 * 
 * @export
 * @interface OrgMappingImportReport
 */
export interface OrgMappingImportReport {
    /**
     * 
     * @type {string}
     * @memberof OrgMappingImportReport
     */
    'requestUuid'?: string;
    /**
     * 
     * @type {Array<OrgMapping>}
     * @memberof OrgMappingImportReport
     */
    'importedOrgMapping'?: Array<OrgMapping>;
    /**
     * 
     * @type {Array<ImportError>}
     * @memberof OrgMappingImportReport
     */
    'warn'?: Array<ImportError>;
}
/**
 * 
 * @export
 * @interface OrgObjective
 */
export interface OrgObjective {
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'uuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgObjective
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'status'?: OrgObjectiveStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgObjective
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgObjective
     */
    'version'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgObjectiveStatusEnum {
    Draft = 'DRAFT',
    Published = 'PUBLISHED',
    Unpublished = 'UNPUBLISHED'
}

/**
 * 
 * @export
 * @interface OrganisationDictionary
 */
export interface OrganisationDictionary {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionary
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionary
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganisationDictionary
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface OverallHealth
 */
export interface OverallHealth {
    /**
     * 
     * @type {string}
     * @memberof OverallHealth
     */
    'status'?: OverallHealthStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OverallHealth
     */
    'version'?: string;
    /**
     * 
     * @type {Array<Health>}
     * @memberof OverallHealth
     */
    'component'?: Array<Health>;
}

/**
    * @export
    * @enum {string}
    */
export enum OverallHealthStatusEnum {
    Ok = 'Ok',
    Fail = 'Fail',
    Degraded = 'Degraded'
}

/**
 * 
 * @export
 * @interface OwnersTypedAttributeUUID
 */
export interface OwnersTypedAttributeUUID {
    /**
     * 
     * @type {string}
     * @memberof OwnersTypedAttributeUUID
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnersTypedAttributeUUID
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnersTypedAttributeUUID
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnersTypedAttributeUUID
     */
    'type'?: OwnersTypedAttributeUUIDTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OwnersTypedAttributeUUIDTypeEnum {
    String = 'STRING',
    Date = 'DATE',
    Number = 'NUMBER',
    Boolean = 'BOOLEAN'
}

/**
 * 
 * @export
 * @interface PDPGoal
 */
export interface PDPGoal {
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof PDPGoal
     */
    'number'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PDPGoal
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'achievementDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PDPGoal
     */
    'status'?: PDPGoalStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PDPGoalStatusEnum {
    Draft = 'DRAFT',
    Published = 'PUBLISHED',
    Unpublished = 'UNPUBLISHED'
}

/**
 * 
 * @export
 * @interface PDPResponse
 */
export interface PDPResponse {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PDPResponse
     */
    'goals'?: Array<PDPGoal>;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PDPResponse
     */
    'form'?: PMFormElement;
}
/**
 * 
 * @export
 * @interface PMColleagueCycle
 */
export interface PMColleagueCycle {
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'cycleUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'status'?: PMColleagueCycleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMColleagueCycle
     */
    'endTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMColleagueCycle
     */
    'properties'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum PMColleagueCycleStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Completed = 'COMPLETED',
    Draft = 'DRAFT',
    Failed = 'FAILED',
    Registered = 'REGISTERED',
    Started = 'STARTED',
    Suspended = 'SUSPENDED',
    Terminated = 'TERMINATED',
    Scheduled = 'SCHEDULED',
    Finishing = 'FINISHING',
    Finished = 'FINISHED'
}

/**
 * 
 * @export
 * @interface PMCycle
 */
export interface PMCycle {
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'entryConfigKey'?: string;
    /**
     * 
     * @type {any}
     * @memberof PMCycle
     */
    'template'?: any;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'name'?: string;
    /**
     * 
     * @type {ColleagueSimple}
     * @memberof PMCycle
     */
    'createdBy'?: ColleagueSimple;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'status'?: PMCycleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'type'?: PMCycleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycle
     */
    'endTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMCycle
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof PMCycle
     */
    'metadata'?: PMCycleMetadata;
}

/**
    * @export
    * @enum {string}
    */
export enum PMCycleStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Completed = 'COMPLETED',
    Draft = 'DRAFT',
    Failed = 'FAILED',
    Registered = 'REGISTERED',
    Started = 'STARTED',
    Suspended = 'SUSPENDED',
    Terminated = 'TERMINATED',
    Scheduled = 'SCHEDULED',
    Finishing = 'FINISHING',
    Finished = 'FINISHED'
}
/**
    * @export
    * @enum {string}
    */
export enum PMCycleTypeEnum {
    Fiscal = 'FISCAL',
    Hiring = 'HIRING'
}

/**
 * 
 * @export
 * @interface PMCycleElement
 */
export interface PMCycleElement {
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'type'?: PMCycleElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMCycleElement
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMCycleElement
     */
    'cycleType'?: PMCycleElementCycleTypeEnum;
    /**
     * 
     * @type {Array<PMTimelinePointElement | PMReviewElement>}
     * @memberof PMCycleElement
     */
    'timelinePoints'?: Array<PMTimelinePointElement | PMReviewElement>;
}

/**
    * @export
    * @enum {string}
    */
export enum PMCycleElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}
/**
    * @export
    * @enum {string}
    */
export enum PMCycleElementCycleTypeEnum {
    Fiscal = 'FISCAL',
    Hiring = 'HIRING'
}

/**
 * 
 * @export
 * @interface PMCycleMetadata
 */
export interface PMCycleMetadata {
    /**
     * 
     * @type {PMCycleElement}
     * @memberof PMCycleMetadata
     */
    'cycle'?: PMCycleElement;
}
/**
 * 
 * @export
 * @interface PMCycleUpdateFormRequest
 */
export interface PMCycleUpdateFormRequest {
    /**
     * 
     * @type {PMFormRequest}
     * @memberof PMCycleUpdateFormRequest
     */
    'changeFrom'?: PMFormRequest;
    /**
     * 
     * @type {PMFormRequest}
     * @memberof PMCycleUpdateFormRequest
     */
    'changeTo'?: PMFormRequest;
}
/**
 * 
 * @export
 * @interface PMForm
 */
export interface PMForm {
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'type'?: PMFormTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMForm
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMForm
     */
    'json'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PMFormTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface PMFormElement
 */
export interface PMFormElement {
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'type'?: PMFormElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMFormElement
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PMFormElement
     */
    'key'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PMFormElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface PMFormRequest
 */
export interface PMFormRequest {
    /**
     * 
     * @type {string}
     * @memberof PMFormRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMFormRequest
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface PMReviewElement
 */
export interface PMReviewElement extends PMTimelinePointElement {
    /**
     * 
     * @type {string}
     * @memberof PMReviewElement
     */
    'reviewType'?: PMReviewElementReviewTypeEnum;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PMReviewElement
     */
    'form'?: PMFormElement;
}

/**
    * @export
    * @enum {string}
    */
export enum PMReviewElementReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR',
    Quarter = 'QUARTER',
    Calibration = 'CALIBRATION'
}

/**
 * 
 * @export
 * @interface PMReviewElementAllOf
 */
export interface PMReviewElementAllOf {
    /**
     * 
     * @type {string}
     * @memberof PMReviewElementAllOf
     */
    'reviewType'?: PMReviewElementAllOfReviewTypeEnum;
    /**
     * 
     * @type {PMFormElement}
     * @memberof PMReviewElementAllOf
     */
    'form'?: PMFormElement;
}

/**
    * @export
    * @enum {string}
    */
export enum PMReviewElementAllOfReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR',
    Quarter = 'QUARTER',
    Calibration = 'CALIBRATION'
}

/**
 * 
 * @export
 * @interface PMTimelinePointElement
 */
export interface PMTimelinePointElement {
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PMTimelinePointElement
     */
    'type'?: PMTimelinePointElementTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PMTimelinePointElement
     */
    'properties'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum PMTimelinePointElementTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}

/**
 * 
 * @export
 * @interface PercentageCount
 */
export interface PercentageCount {
    /**
     * 
     * @type {number}
     * @memberof PercentageCount
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PercentageCount
     */
    'percentage'?: number;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'teamName'?: string;
}
/**
 * 
 * @export
 * @interface PrimaryEntity
 */
export interface PrimaryEntity {
    /**
     * 
     * @type {string}
     * @memberof PrimaryEntity
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryEntity
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInfo
 */
export interface ProcessInfo {
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessInfo
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'resourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'deploymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'versionTag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'diagramResourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInfo
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'dateOfBirth'?: string;
}
/**
 * 
 * @export
 * @interface ReportStatistics
 */
export interface ReportStatistics {
    /**
     * 
     * @type {string}
     * @memberof ReportStatistics
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: PercentageCount; }}
     * @memberof ReportStatistics
     */
    'statistics'?: { [key: string]: PercentageCount; };
    /**
     * 
     * @type {number}
     * @memberof ReportStatistics
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface RequestQuery
 */
export interface RequestQuery {
    /**
     * 
     * @type {Array<Sort>}
     * @memberof RequestQuery
     */
    'sort'?: Array<Sort>;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof RequestQuery
     */
    'filters'?: Array<Condition>;
    /**
     * 
     * @type {number}
     * @memberof RequestQuery
     */
    '_start'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestQuery
     */
    '_limit'?: number;
    /**
     * 
     * @type {Array<ConditionGroup>}
     * @memberof RequestQuery
     */
    '_groups'?: Array<ConditionGroup>;
    /**
     * 
     * @type {string}
     * @memberof RequestQuery
     */
    '_search'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestQuery
     */
    '_sort'?: string;
}
/**
 * 
 * @export
 * @interface RestResponseBoolean
 */
export interface RestResponseBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseBoolean
     */
    'success'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseBoolean
     */
    'data'?: boolean;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseBoolean
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseCalibrationSession
 */
export interface RestResponseCalibrationSession {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseCalibrationSession
     */
    'success'?: boolean;
    /**
     * 
     * @type {CalibrationSession}
     * @memberof RestResponseCalibrationSession
     */
    'data'?: CalibrationSession;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseCalibrationSession
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseColleagueFilterOptions
 */
export interface RestResponseColleagueFilterOptions {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseColleagueFilterOptions
     */
    'success'?: boolean;
    /**
     * 
     * @type {ColleagueFilterOptions}
     * @memberof RestResponseColleagueFilterOptions
     */
    'data'?: ColleagueFilterOptions;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseColleagueFilterOptions
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseColleagueProfile
 */
export interface RestResponseColleagueProfile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseColleagueProfile
     */
    'success'?: boolean;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof RestResponseColleagueProfile
     */
    'data'?: ColleagueProfile;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseColleagueProfile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseCompositePMCycleMetadataResponse
 */
export interface RestResponseCompositePMCycleMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {CompositePMCycleMetadataResponse}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'data'?: CompositePMCycleMetadataResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseCompositePMCycleMetadataResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseCompositePMCycleResponse
 */
export interface RestResponseCompositePMCycleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {CompositePMCycleResponse}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'data'?: CompositePMCycleResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseCompositePMCycleResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseConfigEntryResponse
 */
export interface RestResponseConfigEntryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseConfigEntryResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ConfigEntryResponse}
     * @memberof RestResponseConfigEntryResponse
     */
    'data'?: ConfigEntryResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseConfigEntryResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseContentEntry
 */
export interface RestResponseContentEntry {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseContentEntry
     */
    'success'?: boolean;
    /**
     * 
     * @type {ContentEntry}
     * @memberof RestResponseContentEntry
     */
    'data'?: ContentEntry;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseContentEntry
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseDeploymentInfo
 */
export interface RestResponseDeploymentInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseDeploymentInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {DeploymentInfo}
     * @memberof RestResponseDeploymentInfo
     */
    'data'?: DeploymentInfo;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseDeploymentInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseFeedback
 */
export interface RestResponseFeedback {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseFeedback
     */
    'success'?: boolean;
    /**
     * 
     * @type {Feedback}
     * @memberof RestResponseFeedback
     */
    'data'?: Feedback;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseFeedback
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseFile
 */
export interface RestResponseFile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseFile
     */
    'success'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof RestResponseFile
     */
    'data'?: any;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseFile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseFolder
 */
export interface RestResponseFolder {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseFolder
     */
    'success'?: boolean;
    /**
     * 
     * @type {Folder}
     * @memberof RestResponseFolder
     */
    'data'?: Folder;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseFolder
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseGeneralDictionaryItem
 */
export interface RestResponseGeneralDictionaryItem {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'success'?: boolean;
    /**
     * 
     * @type {GeneralDictionaryItem}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'data'?: GeneralDictionaryItem;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseGeneralDictionaryItem
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseImportReport
 */
export interface RestResponseImportReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseImportReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {ImportReport}
     * @memberof RestResponseImportReport
     */
    'data'?: ImportReport;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseImportReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseImportRequest
 */
export interface RestResponseImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseImportRequest
     */
    'success'?: boolean;
    /**
     * 
     * @type {ImportRequest}
     * @memberof RestResponseImportRequest
     */
    'data'?: ImportRequest;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseImportRequest
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseInteger
 */
export interface RestResponseInteger {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseInteger
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RestResponseInteger
     */
    'data'?: number;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseInteger
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListAuditOrgObjectiveReport
 */
export interface RestResponseListAuditOrgObjectiveReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<AuditOrgObjectiveReport>}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'data'?: Array<AuditOrgObjectiveReport>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListAuditOrgObjectiveReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListCalibrationColleague
 */
export interface RestResponseListCalibrationColleague {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListCalibrationColleague
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<CalibrationColleague>}
     * @memberof RestResponseListCalibrationColleague
     */
    'data'?: Array<CalibrationColleague>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListCalibrationColleague
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListCalibrationSession
 */
export interface RestResponseListCalibrationSession {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListCalibrationSession
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<CalibrationSession>}
     * @memberof RestResponseListCalibrationSession
     */
    'data'?: Array<CalibrationSession>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListCalibrationSession
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueEntity
 */
export interface RestResponseListColleagueEntity {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueEntity
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueEntity>}
     * @memberof RestResponseListColleagueEntity
     */
    'data'?: Array<ColleagueEntity>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueEntity
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueProfile
 */
export interface RestResponseListColleagueProfile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueProfile
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueProfile>}
     * @memberof RestResponseListColleagueProfile
     */
    'data'?: Array<ColleagueProfile>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueProfile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueReportTargeting
 */
export interface RestResponseListColleagueReportTargeting {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueReportTargeting
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueReportTargeting>}
     * @memberof RestResponseListColleagueReportTargeting
     */
    'data'?: Array<ColleagueReportTargeting>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueReportTargeting
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueReview
 */
export interface RestResponseListColleagueReview {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueReview
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueReview>}
     * @memberof RestResponseListColleagueReview
     */
    'data'?: Array<ColleagueReview>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueReview
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueSimple
 */
export interface RestResponseListColleagueSimple {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueSimple
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueSimple>}
     * @memberof RestResponseListColleagueSimple
     */
    'data'?: Array<ColleagueSimple>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueSimple
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueTenant
 */
export interface RestResponseListColleagueTenant {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueTenant
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueTenant>}
     * @memberof RestResponseListColleagueTenant
     */
    'data'?: Array<ColleagueTenant>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueTenant
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListColleagueView
 */
export interface RestResponseListColleagueView {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListColleagueView
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ColleagueView>}
     * @memberof RestResponseListColleagueView
     */
    'data'?: Array<ColleagueView>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListColleagueView
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListConfigEntryResponse
 */
export interface RestResponseListConfigEntryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListConfigEntryResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ConfigEntryResponse>}
     * @memberof RestResponseListConfigEntryResponse
     */
    'data'?: Array<ConfigEntryResponse>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListConfigEntryResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListContentEntry
 */
export interface RestResponseListContentEntry {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListContentEntry
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ContentEntry>}
     * @memberof RestResponseListContentEntry
     */
    'data'?: Array<ContentEntry>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListContentEntry
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListDecisionInfo
 */
export interface RestResponseListDecisionInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListDecisionInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<DecisionInfo>}
     * @memberof RestResponseListDecisionInfo
     */
    'data'?: Array<DecisionInfo>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListDecisionInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListDeploymentInfo
 */
export interface RestResponseListDeploymentInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListDeploymentInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<DeploymentInfo>}
     * @memberof RestResponseListDeploymentInfo
     */
    'data'?: Array<DeploymentInfo>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListDeploymentInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFeedback
 */
export interface RestResponseListFeedback {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFeedback
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof RestResponseListFeedback
     */
    'data'?: Array<Feedback>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFeedback
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFile
 */
export interface RestResponseListFile {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFile
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof RestResponseListFile
     */
    'data'?: Array<any>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFile
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListFolder
 */
export interface RestResponseListFolder {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListFolder
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof RestResponseListFolder
     */
    'data'?: Array<Folder>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListFolder
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListGeneralDictionaryItem
 */
export interface RestResponseListGeneralDictionaryItem {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<GeneralDictionaryItem>}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'data'?: Array<GeneralDictionaryItem>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListGeneralDictionaryItem
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListImportError
 */
export interface RestResponseListImportError {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListImportError
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ImportError>}
     * @memberof RestResponseListImportError
     */
    'data'?: Array<ImportError>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListImportError
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListNote
 */
export interface RestResponseListNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Note>}
     * @memberof RestResponseListNote
     */
    'data'?: Array<Note>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOrgMapping
 */
export interface RestResponseListOrgMapping {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOrgMapping
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OrgMapping>}
     * @memberof RestResponseListOrgMapping
     */
    'data'?: Array<OrgMapping>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOrgMapping
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOrgObjective
 */
export interface RestResponseListOrgObjective {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOrgObjective
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof RestResponseListOrgObjective
     */
    'data'?: Array<OrgObjective>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOrgObjective
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOrganisationDictionary
 */
export interface RestResponseListOrganisationDictionary {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOrganisationDictionary
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OrganisationDictionary>}
     * @memberof RestResponseListOrganisationDictionary
     */
    'data'?: Array<OrganisationDictionary>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOrganisationDictionary
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListOwnersTypedAttributeUUID
 */
export interface RestResponseListOwnersTypedAttributeUUID {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListOwnersTypedAttributeUUID
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof RestResponseListOwnersTypedAttributeUUID
     */
    'data'?: Array<OwnersTypedAttributeUUID>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListOwnersTypedAttributeUUID
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListPDPGoal
 */
export interface RestResponseListPDPGoal {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListPDPGoal
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof RestResponseListPDPGoal
     */
    'data'?: Array<PDPGoal>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListPDPGoal
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListPMColleagueCycle
 */
export interface RestResponseListPMColleagueCycle {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListPMColleagueCycle
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<PMColleagueCycle>}
     * @memberof RestResponseListPMColleagueCycle
     */
    'data'?: Array<PMColleagueCycle>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListPMColleagueCycle
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListPMCycle
 */
export interface RestResponseListPMCycle {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListPMCycle
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<PMCycle>}
     * @memberof RestResponseListPMCycle
     */
    'data'?: Array<PMCycle>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListPMCycle
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListProcessInfo
 */
export interface RestResponseListProcessInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListProcessInfo
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ProcessInfo>}
     * @memberof RestResponseListProcessInfo
     */
    'data'?: Array<ProcessInfo>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListProcessInfo
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListReportStatistics
 */
export interface RestResponseListReportStatistics {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListReportStatistics
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ReportStatistics>}
     * @memberof RestResponseListReportStatistics
     */
    'data'?: Array<ReportStatistics>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListReportStatistics
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListReview
 */
export interface RestResponseListReview {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListReview
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Review>}
     * @memberof RestResponseListReview
     */
    'data'?: Array<Review>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListReview
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListReviewNote
 */
export interface RestResponseListReviewNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListReviewNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<ReviewNote>}
     * @memberof RestResponseListReviewNote
     */
    'data'?: Array<ReviewNote>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListReviewNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListTimelinePoint
 */
export interface RestResponseListTimelinePoint {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListTimelinePoint
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<TimelinePoint>}
     * @memberof RestResponseListTimelinePoint
     */
    'data'?: Array<TimelinePoint>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListTimelinePoint
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseListTip
 */
export interface RestResponseListTip {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseListTip
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<Tip>}
     * @memberof RestResponseListTip
     */
    'data'?: Array<Tip>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseListTip
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseLocalDate
 */
export interface RestResponseLocalDate {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseLocalDate
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponseLocalDate
     */
    'data'?: string;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseLocalDate
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapStringListContentEntry
 */
export interface RestResponseMapStringListContentEntry {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapStringListContentEntry
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Array<ContentEntry>; }}
     * @memberof RestResponseMapStringListContentEntry
     */
    'data'?: { [key: string]: Array<ContentEntry>; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapStringListContentEntry
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapStringString
 */
export interface RestResponseMapStringString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapStringString
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RestResponseMapStringString
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapStringString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapStringTotalCount
 */
export interface RestResponseMapStringTotalCount {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapStringTotalCount
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: TotalCount; }}
     * @memberof RestResponseMapStringTotalCount
     */
    'data'?: { [key: string]: TotalCount; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapStringTotalCount
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapUUIDBoolean
 */
export interface RestResponseMapUUIDBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapUUIDBoolean
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof RestResponseMapUUIDBoolean
     */
    'data'?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapUUIDBoolean
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseMapUUIDString
 */
export interface RestResponseMapUUIDString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseMapUUIDString
     */
    'success'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RestResponseMapUUIDString
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseMapUUIDString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseNote
 */
export interface RestResponseNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {Note}
     * @memberof RestResponseNote
     */
    'data'?: Note;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseOrgHierarchy
 */
export interface RestResponseOrgHierarchy {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseOrgHierarchy
     */
    'success'?: boolean;
    /**
     * 
     * @type {OrgHierarchy}
     * @memberof RestResponseOrgHierarchy
     */
    'data'?: OrgHierarchy;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseOrgHierarchy
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseOrgMappingImportReport
 */
export interface RestResponseOrgMappingImportReport {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseOrgMappingImportReport
     */
    'success'?: boolean;
    /**
     * 
     * @type {OrgMappingImportReport}
     * @memberof RestResponseOrgMappingImportReport
     */
    'data'?: OrgMappingImportReport;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseOrgMappingImportReport
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseOrganisationDictionary
 */
export interface RestResponseOrganisationDictionary {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseOrganisationDictionary
     */
    'success'?: boolean;
    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof RestResponseOrganisationDictionary
     */
    'data'?: OrganisationDictionary;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseOrganisationDictionary
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePDPResponse
 */
export interface RestResponsePDPResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePDPResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {PDPResponse}
     * @memberof RestResponsePDPResponse
     */
    'data'?: PDPResponse;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePDPResponse
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMCycle
 */
export interface RestResponsePMCycle {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMCycle
     */
    'success'?: boolean;
    /**
     * 
     * @type {PMCycle}
     * @memberof RestResponsePMCycle
     */
    'data'?: PMCycle;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMCycle
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMCycleMetadata
 */
export interface RestResponsePMCycleMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMCycleMetadata
     */
    'success'?: boolean;
    /**
     * 
     * @type {PMCycleMetadata}
     * @memberof RestResponsePMCycleMetadata
     */
    'data'?: PMCycleMetadata;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMCycleMetadata
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponsePMReviewStatus
 */
export interface RestResponsePMReviewStatus {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponsePMReviewStatus
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponsePMReviewStatus
     */
    'data'?: RestResponsePMReviewStatusDataEnum;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponsePMReviewStatus
     */
    'errors'?: Array<ApiError>;
}

/**
    * @export
    * @enum {string}
    */
export enum RestResponsePMReviewStatusDataEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    WaitingForCompletion = 'WAITING_FOR_COMPLETION',
    RequestedToAmend = 'REQUESTED_TO_AMEND',
    Completed = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface RestResponseReview
 */
export interface RestResponseReview {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseReview
     */
    'success'?: boolean;
    /**
     * 
     * @type {Review}
     * @memberof RestResponseReview
     */
    'data'?: Review;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseReview
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseReviewNote
 */
export interface RestResponseReviewNote {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseReviewNote
     */
    'success'?: boolean;
    /**
     * 
     * @type {ReviewNote}
     * @memberof RestResponseReviewNote
     */
    'data'?: ReviewNote;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseReviewNote
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseSetString
 */
export interface RestResponseSetString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseSetString
     */
    'success'?: boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof RestResponseSetString
     */
    'data'?: Set<string>;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseSetString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseString
 */
export interface RestResponseString {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseString
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponseString
     */
    'data'?: string;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseString
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseTip
 */
export interface RestResponseTip {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseTip
     */
    'success'?: boolean;
    /**
     * 
     * @type {Tip}
     * @memberof RestResponseTip
     */
    'data'?: Tip;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseTip
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseUUID
 */
export interface RestResponseUUID {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseUUID
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestResponseUUID
     */
    'data'?: string;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseUUID
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseUser
 */
export interface RestResponseUser {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseUser
     */
    'success'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof RestResponseUser
     */
    'data'?: User;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseUser
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface RestResponseVoid
 */
export interface RestResponseVoid {
    /**
     * 
     * @type {boolean}
     * @memberof RestResponseVoid
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof RestResponseVoid
     */
    'data'?: object;
    /**
     * 
     * @type {Array<ApiError>}
     * @memberof RestResponseVoid
     */
    'errors'?: Array<ApiError>;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'type'?: ReviewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'status'?: ReviewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'tlPointUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'colleagueUuid'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Review
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'changeStatusReason'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof Review
     */
    'files'?: Array<any>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR',
    Quarter = 'QUARTER',
    Calibration = 'CALIBRATION'
}
/**
    * @export
    * @enum {string}
    */
export enum ReviewStatusEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    WaitingForCompletion = 'WAITING_FOR_COMPLETION',
    RequestedToAmend = 'REQUESTED_TO_AMEND',
    Completed = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface ReviewNote
 */
export interface ReviewNote {
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'ownerColleagueUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'referenceColleagueUuid'?: string;
    /**
     * 
     * @type {ColleagueProfile}
     * @memberof ReviewNote
     */
    'referenceColleagueProfile'?: ColleagueProfile;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'status'?: ReviewNoteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'folderUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewNote
     */
    'reviewUuid'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ReviewNoteStatusEnum {
    Created = 'CREATED',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface ServiceDates
 */
export interface ServiceDates {
    /**
     * 
     * @type {string}
     * @memberof ServiceDates
     */
    'hireDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDates
     */
    'leavingDate'?: string;
}
/**
 * 
 * @export
 * @interface SimplifiedReview
 */
export interface SimplifiedReview {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'type'?: SimplifiedReviewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'status'?: SimplifiedReviewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplifiedReview
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'tlPointUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedReview
     */
    'lastUpdatedTime'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SimplifiedReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR',
    Quarter = 'QUARTER',
    Calibration = 'CALIBRATION'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplifiedReviewStatusEnum {
    Draft = 'DRAFT',
    WaitingForApproval = 'WAITING_FOR_APPROVAL',
    Approved = 'APPROVED',
    Declined = 'DECLINED',
    WaitingForCompletion = 'WAITING_FOR_COMPLETION',
    RequestedToAmend = 'REQUESTED_TO_AMEND',
    Completed = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface Skill
 */
export interface Skill {
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'type'?: SkillTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SkillTypeEnum {
    Primary = 'PRIMARY',
    Secondary = 'SECONDARY'
}

/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sort
     */
    'order'?: SortOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SortOrderEnum {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TimelinePoint
 */
export interface TimelinePoint {
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'colleagueCycleUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'cycleUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'type'?: TimelinePointTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'endTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TimelinePoint
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'status'?: TimelinePointStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'summaryStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'reviewType'?: TimelinePointReviewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TimelinePoint
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TimelinePoint
     */
    'statistics'?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum TimelinePointTypeEnum {
    Element = 'ELEMENT',
    TimelinePoint = 'TIMELINE_POINT',
    Review = 'REVIEW',
    Form = 'FORM',
    Cycle = 'CYCLE'
}
/**
    * @export
    * @enum {string}
    */
export enum TimelinePointStatusEnum {
    Completed = 'COMPLETED',
    Overdue = 'OVERDUE',
    Started = 'STARTED',
    NotStarted = 'NOT_STARTED',
    Finishing = 'FINISHING',
    Scheduled = 'SCHEDULED'
}
/**
    * @export
    * @enum {string}
    */
export enum TimelinePointReviewTypeEnum {
    Objective = 'OBJECTIVE',
    Myr = 'MYR',
    Eyr = 'EYR',
    Quarter = 'QUARTER',
    Calibration = 'CALIBRATION'
}

/**
 * 
 * @export
 * @interface Tip
 */
export interface Tip {
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'uuid'?: string;
    /**
     * History management.
     * @type {number}
     * @memberof Tip
     */
    'version'?: number;
    /**
     * Link to frontend component or page.
     * @type {string}
     * @memberof Tip
     */
    'key': string;
    /**
     * Title.
     * @type {string}
     * @memberof Tip
     */
    'title': string;
    /**
     * Description.
     * @type {string}
     * @memberof Tip
     */
    'description': string;
    /**
     * 
     * @type {ConfigEntry}
     * @memberof Tip
     */
    'targetOrganisation': ConfigEntry;
    /**
     * Image link.
     * @type {string}
     * @memberof Tip
     */
    'imageLink': string;
    /**
     * Published checkbox.
     * @type {boolean}
     * @memberof Tip
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'createdTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tip
     */
    'updatedTime'?: string;
}
/**
 * 
 * @export
 * @interface TotalCount
 */
export interface TotalCount {
    /**
     * 
     * @type {number}
     * @memberof TotalCount
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof TotalCount
     */
    'percentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof TotalCount
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface UpdateReviewsStatusRequest
 */
export interface UpdateReviewsStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateReviewsStatusRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {Array<Review>}
     * @memberof UpdateReviewsStatusRequest
     */
    'reviews'?: Array<Review>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Colleague}
     * @memberof User
     */
    'colleague'?: Colleague;
    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof User
     */
    'profileAttributes'?: Array<OwnersTypedAttributeUUID>;
    /**
     * 
     * @type {Tenant}
     * @memberof User
     */
    'tenant'?: Tenant;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkLevel
 */
export interface WorkLevel {
    /**
     * 
     * @type {string}
     * @memberof WorkLevel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLevel
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface WorkRelationship
 */
export interface WorkRelationship {
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'locationUUID'?: string;
    /**
     * 
     * @type {ContractType}
     * @memberof WorkRelationship
     */
    'contractType'?: ContractType;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'colleagueType'?: WorkRelationshipColleagueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workingStatus'?: WorkRelationshipWorkingStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'type'?: WorkRelationshipTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'defaultExpenseAccount'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'peopleGroup'?: string;
    /**
     * 
     * @type {LegalEmployer}
     * @memberof WorkRelationship
     */
    'legalEmployer'?: LegalEmployer;
    /**
     * 
     * @type {Department}
     * @memberof WorkRelationship
     */
    'department'?: Department;
    /**
     * 
     * @type {Grade}
     * @memberof WorkRelationship
     */
    'grade'?: Grade;
    /**
     * 
     * @type {Position}
     * @memberof WorkRelationship
     */
    'position'?: Position;
    /**
     * 
     * @type {Job}
     * @memberof WorkRelationship
     */
    'job'?: Job;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'actionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'actionReasonCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'userStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workSchedule'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'employmentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'salaryFrequency'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workingHours'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'costCenter'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'assignmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'primaryEntity'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkRelationship
     */
    'workingInHiredCountry'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkRelationship
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'workLevel'?: WorkRelationshipWorkLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkRelationship
     */
    'managerUUID'?: string;
    /**
     * 
     * @type {Colleague}
     * @memberof WorkRelationship
     */
    'manager'?: Colleague;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipColleagueTypeEnum {
    Employee = 'EMPLOYEE',
    External = 'EXTERNAL',
    Contractor = 'CONTRACTOR'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipWorkingStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Suspended = 'SUSPENDED',
    InactivePaid = 'INACTIVE_PAID'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipTypeEnum {
    Primary = 'PRIMARY'
}
/**
    * @export
    * @enum {string}
    */
export enum WorkRelationshipWorkLevelEnum {
    Colleague = 'COLLEAGUE',
    Wl1 = 'WL1',
    Wl2 = 'WL2',
    Wl3 = 'WL3',
    Wl4 = 'WL4',
    Wl5 = 'WL5'
}


/**
 * CalibrationApi - axios parameter creator
 * @export
 */
export const CalibrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSessions: async (sessionUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('cancelSessions', 'sessionUuid', sessionUuid)
            const localVarPath = `/calibration/sessions/{sessionUuid}/cancel`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession: async (sessionUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('closeSession', 'sessionUuid', sessionUuid)
            const localVarPath = `/calibration/sessions/{sessionUuid}/close`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Review created
         * @summary Create a calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview1: async (colleagueUuid: string, cycleUuid: string, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('createReview1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('createReview1', 'cycleUuid', cycleUuid)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('createReview1', 'review', review)
            const localVarPath = `/calibration/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates Calibration Session
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (calibrationSession: CalibrationSession, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calibrationSession' is not null or undefined
            assertParamExists('createSession', 'calibrationSession', calibrationSession)
            const localVarPath = `/calibration/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calibrationSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing review
         * @summary Delete existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview1: async (colleagueUuid: string, cycleUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('deleteReview1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('deleteReview1', 'cycleUuid', cycleUuid)
            const localVarPath = `/calibration/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (sessionUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('deleteSession', 'sessionUuid', sessionUuid)
            const localVarPath = `/calibration/sessions/{sessionUuid}`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns calibration statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationStatistics: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getCalibrationStatistics', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get filters by permissions and selected filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagueFilterOptions: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getColleagueFilterOptions', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get colleagues for calibration by filter params
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagues: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getColleagues', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns calibration rating statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingStatistics: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getRatingStatistics', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/statistics/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview1: async (colleagueUuid: string, cycleUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReview1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReview1', 'cycleUuid', cycleUuid)
            const localVarPath = `/calibration/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a calibration review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid1: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getReviewByUuid1', 'uuid', uuid)
            const localVarPath = `/calibration/reviews/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews1: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviews1', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns calibration rating statistics by calibration session
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRatingStatistics: async (sessionUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('getSessionRatingStatistics', 'sessionUuid', sessionUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSessionRatingStatistics', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions/{sessionUuid}/statistics/ratings`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets reviews by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionReviews: async (sessionUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('getSessionReviews', 'sessionUuid', sessionUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSessionReviews', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions/{sessionUuid}/reviews`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns user\'s Calibration Sessions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSessions', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets colleagues by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions1: async (sessionUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('getSuggestions1', 'sessionUuid', sessionUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSuggestions1', 'requestQuery', requestQuery)
            const localVarPath = `/calibration/sessions/{sessionUuid}/colleagues`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSession: async (sessionUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('startSession', 'sessionUuid', sessionUuid)
            const localVarPath = `/calibration/sessions/{sessionUuid}/start`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing review
         * @summary Update existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview1: async (colleagueUuid: string, cycleUuid: string, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReview1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReview1', 'cycleUuid', cycleUuid)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('updateReview1', 'review', review)
            const localVarPath = `/calibration/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update status of existing calibration reviews
         * @summary Update status of existing calibration reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus1: async (colleagueUuid: string, cycleUuid: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReviewsStatus1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReviewsStatus1', 'cycleUuid', cycleUuid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateReviewsStatus1', 'status', status)
            // verify required parameter 'updateReviewsStatusRequest' is not null or undefined
            assertParamExists('updateReviewsStatus1', 'updateReviewsStatusRequest', updateReviewsStatusRequest)
            const localVarPath = `/calibration/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/statuses/{status}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReviewsStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession: async (sessionUuid: string, calibrationSession: CalibrationSession, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionUuid' is not null or undefined
            assertParamExists('updateSession', 'sessionUuid', sessionUuid)
            // verify required parameter 'calibrationSession' is not null or undefined
            assertParamExists('updateSession', 'calibrationSession', calibrationSession)
            const localVarPath = `/calibration/sessions/{sessionUuid}`
                .replace(`{${"sessionUuid"}}`, encodeURIComponent(String(sessionUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calibrationSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalibrationApi - functional programming interface
 * @export
 */
export const CalibrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalibrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels a Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSessions(sessionUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSessions(sessionUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeSession(sessionUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCalibrationSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeSession(sessionUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Review created
         * @summary Create a calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview1(colleagueUuid: string, cycleUuid: string, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview1(colleagueUuid, cycleUuid, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates Calibration Session
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(calibrationSession: CalibrationSession, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCalibrationSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(calibrationSession, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing review
         * @summary Delete existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview1(colleagueUuid: string, cycleUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview1(colleagueUuid, cycleUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(sessionUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(sessionUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns calibration statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalibrationStatistics(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringTotalCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalibrationStatistics(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get filters by permissions and selected filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColleagueFilterOptions(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseColleagueFilterOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColleagueFilterOptions(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get colleagues for calibration by filter params
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColleagues(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListCalibrationColleague>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColleagues(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns calibration rating statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingStatistics(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringTotalCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRatingStatistics(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReview1(colleagueUuid: string, cycleUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReview1(colleagueUuid, cycleUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a calibration review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewByUuid1(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewByUuid1(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviews1(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews1(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns calibration rating statistics by calibration session
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRatingStatistics(sessionUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringTotalCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRatingStatistics(sessionUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets reviews by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionReviews(sessionUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionReviews(sessionUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns user\'s Calibration Sessions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListCalibrationSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets colleagues by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions1(sessionUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestions1(sessionUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startSession(sessionUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCalibrationSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSession(sessionUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing review
         * @summary Update existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReview1(colleagueUuid: string, cycleUuid: string, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview1(colleagueUuid, cycleUuid, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update status of existing calibration reviews
         * @summary Update status of existing calibration reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviewsStatus1(colleagueUuid: string, cycleUuid: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMReviewStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviewsStatus1(colleagueUuid, cycleUuid, status, updateReviewsStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSession(sessionUuid: string, calibrationSession: CalibrationSession, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCalibrationSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSession(sessionUuid, calibrationSession, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CalibrationApi - factory interface
 * @export
 */
export const CalibrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalibrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels a Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSessions(sessionUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.cancelSessions(sessionUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession(sessionUuid: string, options?: any): AxiosPromise<RestResponseCalibrationSession> {
            return localVarFp.closeSession(sessionUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Review created
         * @summary Create a calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview1(colleagueUuid: string, cycleUuid: string, review: Review, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.createReview1(colleagueUuid, cycleUuid, review, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates Calibration Session
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(calibrationSession: CalibrationSession, options?: any): AxiosPromise<RestResponseCalibrationSession> {
            return localVarFp.createSession(calibrationSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing review
         * @summary Delete existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview1(colleagueUuid: string, cycleUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteReview1(colleagueUuid, cycleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(sessionUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteSession(sessionUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns calibration statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationStatistics(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseMapStringTotalCount> {
            return localVarFp.getCalibrationStatistics(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get filters by permissions and selected filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagueFilterOptions(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseColleagueFilterOptions> {
            return localVarFp.getColleagueFilterOptions(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get colleagues for calibration by filter params
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagues(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListCalibrationColleague> {
            return localVarFp.getColleagues(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns calibration rating statistics accessible for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingStatistics(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseMapStringTotalCount> {
            return localVarFp.getRatingStatistics(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview1(colleagueUuid: string, cycleUuid: string, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReview1(colleagueUuid, cycleUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a calibration review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid1(uuid: string, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReviewByUuid1(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns accessible Calibration Reviews for the user
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews1(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReview> {
            return localVarFp.getReviews1(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns calibration rating statistics by calibration session
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRatingStatistics(sessionUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseMapStringTotalCount> {
            return localVarFp.getSessionRatingStatistics(sessionUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets reviews by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionReviews(sessionUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReview> {
            return localVarFp.getSessionReviews(sessionUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns user\'s Calibration Sessions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListCalibrationSession> {
            return localVarFp.getSessions(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets colleagues by Calibration Sessions
         * @param {string} sessionUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions1(sessionUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueSimple> {
            return localVarFp.getSuggestions1(sessionUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Calibration Session
         * @param {string} sessionUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSession(sessionUuid: string, options?: any): AxiosPromise<RestResponseCalibrationSession> {
            return localVarFp.startSession(sessionUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing review
         * @summary Update existing calibration review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview1(colleagueUuid: string, cycleUuid: string, review: Review, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.updateReview1(colleagueUuid, cycleUuid, review, options).then((request) => request(axios, basePath));
        },
        /**
         * Update status of existing calibration reviews
         * @summary Update status of existing calibration reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus1(colleagueUuid: string, cycleUuid: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: any): AxiosPromise<RestResponsePMReviewStatus> {
            return localVarFp.updateReviewsStatus1(colleagueUuid, cycleUuid, status, updateReviewsStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Calibration Sessions for the user
         * @param {string} sessionUuid 
         * @param {CalibrationSession} calibrationSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(sessionUuid: string, calibrationSession: CalibrationSession, options?: any): AxiosPromise<RestResponseCalibrationSession> {
            return localVarFp.updateSession(sessionUuid, calibrationSession, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelSessions operation in CalibrationApi.
 * @export
 * @interface CalibrationApiCancelSessionsRequest
 */
export interface CalibrationApiCancelSessionsRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiCancelSessions
     */
    readonly sessionUuid: string
}

/**
 * Request parameters for closeSession operation in CalibrationApi.
 * @export
 * @interface CalibrationApiCloseSessionRequest
 */
export interface CalibrationApiCloseSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiCloseSession
     */
    readonly sessionUuid: string
}

/**
 * Request parameters for createReview1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiCreateReview1Request
 */
export interface CalibrationApiCreateReview1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiCreateReview1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof CalibrationApiCreateReview1
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {Review}
     * @memberof CalibrationApiCreateReview1
     */
    readonly review: Review
}

/**
 * Request parameters for createSession operation in CalibrationApi.
 * @export
 * @interface CalibrationApiCreateSessionRequest
 */
export interface CalibrationApiCreateSessionRequest {
    /**
     * 
     * @type {CalibrationSession}
     * @memberof CalibrationApiCreateSession
     */
    readonly calibrationSession: CalibrationSession
}

/**
 * Request parameters for deleteReview1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiDeleteReview1Request
 */
export interface CalibrationApiDeleteReview1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiDeleteReview1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof CalibrationApiDeleteReview1
     */
    readonly cycleUuid: string
}

/**
 * Request parameters for deleteSession operation in CalibrationApi.
 * @export
 * @interface CalibrationApiDeleteSessionRequest
 */
export interface CalibrationApiDeleteSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiDeleteSession
     */
    readonly sessionUuid: string
}

/**
 * Request parameters for getCalibrationStatistics operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetCalibrationStatisticsRequest
 */
export interface CalibrationApiGetCalibrationStatisticsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetCalibrationStatistics
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getColleagueFilterOptions operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetColleagueFilterOptionsRequest
 */
export interface CalibrationApiGetColleagueFilterOptionsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetColleagueFilterOptions
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getColleagues operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetColleaguesRequest
 */
export interface CalibrationApiGetColleaguesRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetColleagues
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getRatingStatistics operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetRatingStatisticsRequest
 */
export interface CalibrationApiGetRatingStatisticsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetRatingStatistics
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReview1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetReview1Request
 */
export interface CalibrationApiGetReview1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetReview1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetReview1
     */
    readonly cycleUuid: string
}

/**
 * Request parameters for getReviewByUuid1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetReviewByUuid1Request
 */
export interface CalibrationApiGetReviewByUuid1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetReviewByUuid1
     */
    readonly uuid: string
}

/**
 * Request parameters for getReviews1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetReviews1Request
 */
export interface CalibrationApiGetReviews1Request {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetReviews1
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getSessionRatingStatistics operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetSessionRatingStatisticsRequest
 */
export interface CalibrationApiGetSessionRatingStatisticsRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetSessionRatingStatistics
     */
    readonly sessionUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetSessionRatingStatistics
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getSessionReviews operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetSessionReviewsRequest
 */
export interface CalibrationApiGetSessionReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetSessionReviews
     */
    readonly sessionUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetSessionReviews
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getSessions operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetSessionsRequest
 */
export interface CalibrationApiGetSessionsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetSessions
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getSuggestions1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiGetSuggestions1Request
 */
export interface CalibrationApiGetSuggestions1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiGetSuggestions1
     */
    readonly sessionUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof CalibrationApiGetSuggestions1
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for startSession operation in CalibrationApi.
 * @export
 * @interface CalibrationApiStartSessionRequest
 */
export interface CalibrationApiStartSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiStartSession
     */
    readonly sessionUuid: string
}

/**
 * Request parameters for updateReview1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiUpdateReview1Request
 */
export interface CalibrationApiUpdateReview1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiUpdateReview1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof CalibrationApiUpdateReview1
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {Review}
     * @memberof CalibrationApiUpdateReview1
     */
    readonly review: Review
}

/**
 * Request parameters for updateReviewsStatus1 operation in CalibrationApi.
 * @export
 * @interface CalibrationApiUpdateReviewsStatus1Request
 */
export interface CalibrationApiUpdateReviewsStatus1Request {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiUpdateReviewsStatus1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof CalibrationApiUpdateReviewsStatus1
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'}
     * @memberof CalibrationApiUpdateReviewsStatus1
     */
    readonly status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'

    /**
     * 
     * @type {UpdateReviewsStatusRequest}
     * @memberof CalibrationApiUpdateReviewsStatus1
     */
    readonly updateReviewsStatusRequest: UpdateReviewsStatusRequest
}

/**
 * Request parameters for updateSession operation in CalibrationApi.
 * @export
 * @interface CalibrationApiUpdateSessionRequest
 */
export interface CalibrationApiUpdateSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CalibrationApiUpdateSession
     */
    readonly sessionUuid: string

    /**
     * 
     * @type {CalibrationSession}
     * @memberof CalibrationApiUpdateSession
     */
    readonly calibrationSession: CalibrationSession
}

/**
 * CalibrationApi - object-oriented interface
 * @export
 * @class CalibrationApi
 * @extends {BaseAPI}
 */
export class CalibrationApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a Calibration Session
     * @param {CalibrationApiCancelSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public cancelSessions(requestParameters: CalibrationApiCancelSessionsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).cancelSessions(requestParameters.sessionUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Calibration Session
     * @param {CalibrationApiCloseSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public closeSession(requestParameters: CalibrationApiCloseSessionRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).closeSession(requestParameters.sessionUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Review created
     * @summary Create a calibration review
     * @param {CalibrationApiCreateReview1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public createReview1(requestParameters: CalibrationApiCreateReview1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).createReview1(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates Calibration Session
     * @param {CalibrationApiCreateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public createSession(requestParameters: CalibrationApiCreateSessionRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).createSession(requestParameters.calibrationSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing review
     * @summary Delete existing calibration review
     * @param {CalibrationApiDeleteReview1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public deleteReview1(requestParameters: CalibrationApiDeleteReview1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).deleteReview1(requestParameters.colleagueUuid, requestParameters.cycleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Calibration Sessions for the user
     * @param {CalibrationApiDeleteSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public deleteSession(requestParameters: CalibrationApiDeleteSessionRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).deleteSession(requestParameters.sessionUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns calibration statistics accessible for the user
     * @param {CalibrationApiGetCalibrationStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getCalibrationStatistics(requestParameters: CalibrationApiGetCalibrationStatisticsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getCalibrationStatistics(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get filters by permissions and selected filters
     * @param {CalibrationApiGetColleagueFilterOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getColleagueFilterOptions(requestParameters: CalibrationApiGetColleagueFilterOptionsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getColleagueFilterOptions(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get colleagues for calibration by filter params
     * @param {CalibrationApiGetColleaguesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getColleagues(requestParameters: CalibrationApiGetColleaguesRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getColleagues(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns calibration rating statistics accessible for the user
     * @param {CalibrationApiGetRatingStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getRatingStatistics(requestParameters: CalibrationApiGetRatingStatisticsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getRatingStatistics(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns accessible Calibration Reviews for the user
     * @param {CalibrationApiGetReview1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getReview1(requestParameters: CalibrationApiGetReview1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getReview1(requestParameters.colleagueUuid, requestParameters.cycleUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a calibration review by its identifier
     * @param {CalibrationApiGetReviewByUuid1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getReviewByUuid1(requestParameters: CalibrationApiGetReviewByUuid1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getReviewByUuid1(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns accessible Calibration Reviews for the user
     * @param {CalibrationApiGetReviews1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getReviews1(requestParameters: CalibrationApiGetReviews1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getReviews1(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns calibration rating statistics by calibration session
     * @param {CalibrationApiGetSessionRatingStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getSessionRatingStatistics(requestParameters: CalibrationApiGetSessionRatingStatisticsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getSessionRatingStatistics(requestParameters.sessionUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets reviews by Calibration Sessions
     * @param {CalibrationApiGetSessionReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getSessionReviews(requestParameters: CalibrationApiGetSessionReviewsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getSessionReviews(requestParameters.sessionUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns user\'s Calibration Sessions
     * @param {CalibrationApiGetSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getSessions(requestParameters: CalibrationApiGetSessionsRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getSessions(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets colleagues by Calibration Sessions
     * @param {CalibrationApiGetSuggestions1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public getSuggestions1(requestParameters: CalibrationApiGetSuggestions1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).getSuggestions1(requestParameters.sessionUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Calibration Session
     * @param {CalibrationApiStartSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public startSession(requestParameters: CalibrationApiStartSessionRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).startSession(requestParameters.sessionUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing review
     * @summary Update existing calibration review
     * @param {CalibrationApiUpdateReview1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public updateReview1(requestParameters: CalibrationApiUpdateReview1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).updateReview1(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update status of existing calibration reviews
     * @summary Update status of existing calibration reviews
     * @param {CalibrationApiUpdateReviewsStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public updateReviewsStatus1(requestParameters: CalibrationApiUpdateReviewsStatus1Request, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).updateReviewsStatus1(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.status, requestParameters.updateReviewsStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Calibration Sessions for the user
     * @param {CalibrationApiUpdateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalibrationApi
     */
    public updateSession(requestParameters: CalibrationApiUpdateSessionRequest, options?: AxiosRequestConfig) {
        return CalibrationApiFp(this.configuration).updateSession(requestParameters.sessionUuid, requestParameters.calibrationSession, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CepApi - axios parameter creator
 * @export
 */
export const CepApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processColleagueChangeEvent: async (colleagueChangeEventPayload: ColleagueChangeEventPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueChangeEventPayload' is not null or undefined
            assertParamExists('processColleagueChangeEvent', 'colleagueChangeEventPayload', colleagueChangeEventPayload)
            const localVarPath = `/colleagues/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(colleagueChangeEventPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CepApi - functional programming interface
 * @export
 */
export const CepApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CepApiAxiosParamCreator(configuration)
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processColleagueChangeEvent(colleagueChangeEventPayload: ColleagueChangeEventPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processColleagueChangeEvent(colleagueChangeEventPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CepApi - factory interface
 * @export
 */
export const CepApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CepApiFp(configuration)
    return {
        /**
         * Consuming colleague changes events
         * @summary Consuming events
         * @param {ColleagueChangeEventPayload} colleagueChangeEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processColleagueChangeEvent(colleagueChangeEventPayload: ColleagueChangeEventPayload, options?: any): AxiosPromise<void> {
            return localVarFp.processColleagueChangeEvent(colleagueChangeEventPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for processColleagueChangeEvent operation in CepApi.
 * @export
 * @interface CepApiProcessColleagueChangeEventRequest
 */
export interface CepApiProcessColleagueChangeEventRequest {
    /**
     * 
     * @type {ColleagueChangeEventPayload}
     * @memberof CepApiProcessColleagueChangeEvent
     */
    readonly colleagueChangeEventPayload: ColleagueChangeEventPayload
}

/**
 * CepApi - object-oriented interface
 * @export
 * @class CepApi
 * @extends {BaseAPI}
 */
export class CepApi extends BaseAPI {
    /**
     * Consuming colleague changes events
     * @summary Consuming events
     * @param {CepApiProcessColleagueChangeEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepApi
     */
    public processColleagueChangeEvent(requestParameters: CepApiProcessColleagueChangeEventRequest, options?: AxiosRequestConfig) {
        return CepApiFp(this.configuration).processColleagueChangeEvent(requestParameters.colleagueChangeEventPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CmsApi - axios parameter creator
 * @export
 */
export const CmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: async (contentEntry: ContentEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentEntry' is not null or undefined
            assertParamExists('create5', 'contentEntry', contentEntry)
            const localVarPath = `/cms/content-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Content
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete8: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('delete8', 'uuid', uuid)
            const localVarPath = `/cms/content-entries/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find Content by key in path
         * @param {RequestQuery} rq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByRequestQuery: async (rq: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rq' is not null or undefined
            assertParamExists('findByRequestQuery', 'rq', rq)
            const localVarPath = `/cms/content-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rq !== undefined) {
                localVarQueryParameter['rq'] = rq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find Content Entries by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqContentEntries: async (keys?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cms/help-faqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keys) {
                localVarQueryParameter['keys'] = keys;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqUrls: async (keys?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cms/help-faq-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keys) {
                localVarQueryParameter['keys'] = keys;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6: async (contentEntry: ContentEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentEntry' is not null or undefined
            assertParamExists('update6', 'contentEntry', contentEntry)
            const localVarPath = `/cms/content-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CmsApi - functional programming interface
 * @export
 */
export const CmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create5(contentEntry: ContentEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseContentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create5(contentEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Content
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete8(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete8(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find Content by key in path
         * @param {RequestQuery} rq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByRequestQuery(rq: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListContentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByRequestQuery(rq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find Content Entries by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelpFaqContentEntries(keys?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringListContentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelpFaqContentEntries(keys, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelpFaqUrls(keys?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelpFaqUrls(keys, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update6(contentEntry: ContentEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseContentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update6(contentEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CmsApi - factory interface
 * @export
 */
export const CmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CmsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(contentEntry: ContentEntry, options?: any): AxiosPromise<RestResponseContentEntry> {
            return localVarFp.create5(contentEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Content
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete8(uuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete8(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find Content by key in path
         * @param {RequestQuery} rq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByRequestQuery(rq: RequestQuery, options?: any): AxiosPromise<RestResponseListContentEntry> {
            return localVarFp.findByRequestQuery(rq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find Content Entries by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqContentEntries(keys?: Array<string>, options?: any): AxiosPromise<RestResponseMapStringListContentEntry> {
            return localVarFp.getHelpFaqContentEntries(keys, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find URLs by keys
         * @param {Array<string>} [keys] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpFaqUrls(keys?: Array<string>, options?: any): AxiosPromise<RestResponseMapStringString> {
            return localVarFp.getHelpFaqUrls(keys, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Content
         * @param {ContentEntry} contentEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6(contentEntry: ContentEntry, options?: any): AxiosPromise<RestResponseContentEntry> {
            return localVarFp.update6(contentEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create5 operation in CmsApi.
 * @export
 * @interface CmsApiCreate5Request
 */
export interface CmsApiCreate5Request {
    /**
     * 
     * @type {ContentEntry}
     * @memberof CmsApiCreate5
     */
    readonly contentEntry: ContentEntry
}

/**
 * Request parameters for delete8 operation in CmsApi.
 * @export
 * @interface CmsApiDelete8Request
 */
export interface CmsApiDelete8Request {
    /**
     * 
     * @type {string}
     * @memberof CmsApiDelete8
     */
    readonly uuid: string
}

/**
 * Request parameters for findByRequestQuery operation in CmsApi.
 * @export
 * @interface CmsApiFindByRequestQueryRequest
 */
export interface CmsApiFindByRequestQueryRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof CmsApiFindByRequestQuery
     */
    readonly rq: RequestQuery
}

/**
 * Request parameters for getHelpFaqContentEntries operation in CmsApi.
 * @export
 * @interface CmsApiGetHelpFaqContentEntriesRequest
 */
export interface CmsApiGetHelpFaqContentEntriesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CmsApiGetHelpFaqContentEntries
     */
    readonly keys?: Array<string>
}

/**
 * Request parameters for getHelpFaqUrls operation in CmsApi.
 * @export
 * @interface CmsApiGetHelpFaqUrlsRequest
 */
export interface CmsApiGetHelpFaqUrlsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CmsApiGetHelpFaqUrls
     */
    readonly keys?: Array<string>
}

/**
 * Request parameters for update6 operation in CmsApi.
 * @export
 * @interface CmsApiUpdate6Request
 */
export interface CmsApiUpdate6Request {
    /**
     * 
     * @type {ContentEntry}
     * @memberof CmsApiUpdate6
     */
    readonly contentEntry: ContentEntry
}

/**
 * CmsApi - object-oriented interface
 * @export
 * @class CmsApi
 * @extends {BaseAPI}
 */
export class CmsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Content
     * @param {CmsApiCreate5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public create5(requestParameters: CmsApiCreate5Request, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).create5(requestParameters.contentEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Content
     * @param {CmsApiDelete8Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public delete8(requestParameters: CmsApiDelete8Request, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).delete8(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find Content by key in path
     * @param {CmsApiFindByRequestQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public findByRequestQuery(requestParameters: CmsApiFindByRequestQueryRequest, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).findByRequestQuery(requestParameters.rq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find Content Entries by keys
     * @param {CmsApiGetHelpFaqContentEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getHelpFaqContentEntries(requestParameters: CmsApiGetHelpFaqContentEntriesRequest = {}, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).getHelpFaqContentEntries(requestParameters.keys, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find URLs by keys
     * @param {CmsApiGetHelpFaqUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getHelpFaqUrls(requestParameters: CmsApiGetHelpFaqUrlsRequest = {}, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).getHelpFaqUrls(requestParameters.keys, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Content
     * @param {CmsApiUpdate6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public update6(requestParameters: CmsApiUpdate6Request, options?: AxiosRequestConfig) {
        return CmsApiFp(this.configuration).update6(requestParameters.contentEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ColleaguesApi - axios parameter creator
 * @export
 */
export const ColleaguesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Manual start for deleting expired data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/colleagues/delete-expired-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getSuggestions', 'requestQuery', requestQuery)
            const localVarPath = `/colleagues/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ColleaguesApi - functional programming interface
 * @export
 */
export const ColleaguesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ColleaguesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Manual start for deleting expired data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExpiredData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpiredData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestions(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ColleaguesApi - factory interface
 * @export
 */
export const ColleaguesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ColleaguesApiFp(configuration)
    return {
        /**
         * 
         * @summary Manual start for deleting expired data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredData(options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteExpiredData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Autocomplete search among colleagues by full name and manager ID
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueProfile> {
            return localVarFp.getSuggestions(requestQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSuggestions operation in ColleaguesApi.
 * @export
 * @interface ColleaguesApiGetSuggestionsRequest
 */
export interface ColleaguesApiGetSuggestionsRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ColleaguesApiGetSuggestions
     */
    readonly requestQuery: RequestQuery
}

/**
 * ColleaguesApi - object-oriented interface
 * @export
 * @class ColleaguesApi
 * @extends {BaseAPI}
 */
export class ColleaguesApi extends BaseAPI {
    /**
     * 
     * @summary Manual start for deleting expired data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColleaguesApi
     */
    public deleteExpiredData(options?: AxiosRequestConfig) {
        return ColleaguesApiFp(this.configuration).deleteExpiredData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Autocomplete search among colleagues by full name and manager ID
     * @param {ColleaguesApiGetSuggestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColleaguesApi
     */
    public getSuggestions(requestParameters: ColleaguesApiGetSuggestionsRequest, options?: AxiosRequestConfig) {
        return ColleaguesApiFp(this.configuration).getSuggestions(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultAttributes: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateDefaultAttributes', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/config/default/attributes/colleagues/{colleagueUuid}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefaultAttributes(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefaultAttributes(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Update default attributes for a colleague
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultAttributes(colleagueUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.updateDefaultAttributes(colleagueUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateDefaultAttributes operation in ConfigApi.
 * @export
 * @interface ConfigApiUpdateDefaultAttributesRequest
 */
export interface ConfigApiUpdateDefaultAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigApiUpdateDefaultAttributes
     */
    readonly colleagueUuid: string
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @summary Update default attributes for a colleague
     * @param {ConfigApiUpdateDefaultAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public updateDefaultAttributes(requestParameters: ConfigApiUpdateDefaultAttributesRequest, options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).updateDefaultAttributes(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigEntryApi - axios parameter creator
 * @export
 */
export const ConfigEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (configEntry: ConfigEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configEntry' is not null or undefined
            assertParamExists('create4', 'configEntry', configEntry)
            const localVarPath = `/config-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('delete7', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findColleaguesByCompositeKey: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('findColleaguesByCompositeKey', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('getPublishedEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructureByCompositeKey: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('getPublishedEntryConfigStructureByCompositeKey', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRoots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config-entries/roots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublished: async (compositeKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeKey' is not null or undefined
            assertParamExists('getUnpublished', 'compositeKey', compositeKey)
            const localVarPath = `/config-entries/unpublished`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (compositeKey !== undefined) {
                localVarQueryParameter['compositeKey'] = compositeKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('getUnpublishedEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/unpublished`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedRoots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config-entries/roots/unpublished`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('publishEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/publish`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEntryConfigStructure: async (entryUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('unpublishEntryConfigStructure', 'entryUuid', entryUuid)
            const localVarPath = `/config-entries/{entryUuid}/publish`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5: async (entryUuid: string, configEntry: ConfigEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryUuid' is not null or undefined
            assertParamExists('update5', 'entryUuid', entryUuid)
            // verify required parameter 'configEntry' is not null or undefined
            assertParamExists('update5', 'configEntry', configEntry)
            const localVarPath = `/config-entries/{entryUuid}`
                .replace(`{${"entryUuid"}}`, encodeURIComponent(String(entryUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigEntryApi - functional programming interface
 * @export
 */
export const ConfigEntryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigEntryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(configEntry: ConfigEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(configEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete7(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete7(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findColleaguesByCompositeKey(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findColleaguesByCompositeKey(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedEntryConfigStructureByCompositeKey(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedEntryConfigStructureByCompositeKey(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedRoots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedRoots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublished(compositeKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublished(compositeKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublishedEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublishedEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnpublishedRoots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListConfigEntryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnpublishedRoots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishEntryConfigStructure(entryUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishEntryConfigStructure(entryUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update5(entryUuid: string, configEntry: ConfigEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update5(entryUuid, configEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigEntryApi - factory interface
 * @export
 */
export const ConfigEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigEntryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create config entry
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(configEntry: ConfigEntry, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.create4(configEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(entryUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete7(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get colleagues by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findColleaguesByCompositeKey(compositeKey: string, options?: any): AxiosPromise<RestResponseListColleagueEntity> {
            return localVarFp.findColleaguesByCompositeKey(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseConfigEntryResponse> {
            return localVarFp.getPublishedEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published config entry structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedEntryConfigStructureByCompositeKey(compositeKey: string, options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getPublishedEntryConfigStructureByCompositeKey(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all published root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRoots(options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getPublishedRoots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unpublished structure by composite key
         * @param {string} compositeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublished(compositeKey: string, options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getUnpublished(compositeKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get unpublished config entry structure by root identifier
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseConfigEntryResponse> {
            return localVarFp.getUnpublishedEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all unpublished root config entries 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnpublishedRoots(options?: any): AxiosPromise<RestResponseListConfigEntryResponse> {
            return localVarFp.getUnpublishedRoots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.publishEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpublish config entry
         * @param {string} entryUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEntryConfigStructure(entryUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.unpublishEntryConfigStructure(entryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update config entry
         * @param {string} entryUuid 
         * @param {ConfigEntry} configEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(entryUuid: string, configEntry: ConfigEntry, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.update5(entryUuid, configEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create4 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiCreate4Request
 */
export interface ConfigEntryApiCreate4Request {
    /**
     * 
     * @type {ConfigEntry}
     * @memberof ConfigEntryApiCreate4
     */
    readonly configEntry: ConfigEntry
}

/**
 * Request parameters for delete7 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiDelete7Request
 */
export interface ConfigEntryApiDelete7Request {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiDelete7
     */
    readonly entryUuid: string
}

/**
 * Request parameters for findColleaguesByCompositeKey operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiFindColleaguesByCompositeKeyRequest
 */
export interface ConfigEntryApiFindColleaguesByCompositeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiFindColleaguesByCompositeKey
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getPublishedEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetPublishedEntryConfigStructureRequest
 */
export interface ConfigEntryApiGetPublishedEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetPublishedEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for getPublishedEntryConfigStructureByCompositeKey operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest
 */
export interface ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKey
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getUnpublished operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetUnpublishedRequest
 */
export interface ConfigEntryApiGetUnpublishedRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetUnpublished
     */
    readonly compositeKey: string
}

/**
 * Request parameters for getUnpublishedEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiGetUnpublishedEntryConfigStructureRequest
 */
export interface ConfigEntryApiGetUnpublishedEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiGetUnpublishedEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for publishEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiPublishEntryConfigStructureRequest
 */
export interface ConfigEntryApiPublishEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiPublishEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for unpublishEntryConfigStructure operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiUnpublishEntryConfigStructureRequest
 */
export interface ConfigEntryApiUnpublishEntryConfigStructureRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiUnpublishEntryConfigStructure
     */
    readonly entryUuid: string
}

/**
 * Request parameters for update5 operation in ConfigEntryApi.
 * @export
 * @interface ConfigEntryApiUpdate5Request
 */
export interface ConfigEntryApiUpdate5Request {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryApiUpdate5
     */
    readonly entryUuid: string

    /**
     * 
     * @type {ConfigEntry}
     * @memberof ConfigEntryApiUpdate5
     */
    readonly configEntry: ConfigEntry
}

/**
 * ConfigEntryApi - object-oriented interface
 * @export
 * @class ConfigEntryApi
 * @extends {BaseAPI}
 */
export class ConfigEntryApi extends BaseAPI {
    /**
     * 
     * @summary Create config entry
     * @param {ConfigEntryApiCreate4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public create4(requestParameters: ConfigEntryApiCreate4Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).create4(requestParameters.configEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete config entry
     * @param {ConfigEntryApiDelete7Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public delete7(requestParameters: ConfigEntryApiDelete7Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).delete7(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get colleagues by composite key
     * @param {ConfigEntryApiFindColleaguesByCompositeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public findColleaguesByCompositeKey(requestParameters: ConfigEntryApiFindColleaguesByCompositeKeyRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).findColleaguesByCompositeKey(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published config entry structure by root identifier
     * @param {ConfigEntryApiGetPublishedEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedEntryConfigStructure(requestParameters: ConfigEntryApiGetPublishedEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published config entry structure by composite key
     * @param {ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedEntryConfigStructureByCompositeKey(requestParameters: ConfigEntryApiGetPublishedEntryConfigStructureByCompositeKeyRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedEntryConfigStructureByCompositeKey(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all published root config entries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getPublishedRoots(options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getPublishedRoots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unpublished structure by composite key
     * @param {ConfigEntryApiGetUnpublishedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublished(requestParameters: ConfigEntryApiGetUnpublishedRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublished(requestParameters.compositeKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get unpublished config entry structure by root identifier
     * @param {ConfigEntryApiGetUnpublishedEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublishedEntryConfigStructure(requestParameters: ConfigEntryApiGetUnpublishedEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublishedEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all unpublished root config entries 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public getUnpublishedRoots(options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).getUnpublishedRoots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish config entry
     * @param {ConfigEntryApiPublishEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public publishEntryConfigStructure(requestParameters: ConfigEntryApiPublishEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).publishEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpublish config entry
     * @param {ConfigEntryApiUnpublishEntryConfigStructureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public unpublishEntryConfigStructure(requestParameters: ConfigEntryApiUnpublishEntryConfigStructureRequest, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).unpublishEntryConfigStructure(requestParameters.entryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update config entry
     * @param {ConfigEntryApiUpdate5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigEntryApi
     */
    public update5(requestParameters: ConfigEntryApiUpdate5Request, options?: AxiosRequestConfig) {
        return ConfigEntryApiFp(this.configuration).update5(requestParameters.entryUuid, requestParameters.configEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of deployed decision matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decisions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy multipart files
         * @param {string} deploymentName 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy1: async (deploymentName: string, files: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentName' is not null or undefined
            assertParamExists('deploy1', 'deploymentName', deploymentName)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('deploy1', 'files', files)
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (deploymentName !== undefined) { 
                localVarFormParams.append('deploymentName', deploymentName as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File deployed
         * @summary Deploy the last version of the file resource by path and filename
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByPathAndFilename: async (path: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deployByPathAndFilename', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deployByPathAndFilename', 'fileName', fileName)
            const localVarPath = `/files/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file-name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByUuid: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('deployByUuid', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}/deploy`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy process archive
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployProcess: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deployProcess', 'body', body)
            const localVarPath = `/processes/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of deployments (identifier/name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployments: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of deployed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set up removal time
         * @summary Set up removalTime for completed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemovalTime: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processes/set-removal-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undeploy deployment by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeploy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('undeploy', 'id', id)
            const localVarPath = `/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undeploy deployment by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployByName: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('undeployByName', 'name', name)
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undeploy all version of process by process key(name)
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployProcess: async (processName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processName' is not null or undefined
            assertParamExists('undeployProcess', 'processName', processName)
            const localVarPath = `/processes/{processName}`
                .replace(`{${"processName"}}`, encodeURIComponent(String(processName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of deployed decision matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decisions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDecisionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decisions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploy multipart files
         * @param {string} deploymentName 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploy1(deploymentName: string, files: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploy1(deploymentName, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * File deployed
         * @summary Deploy the last version of the file resource by path and filename
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployByPathAndFilename(path: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployByPathAndFilename(path, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployByUuid(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployByUuid(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploy process archive
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployProcess(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployProcess(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of deployments (identifier/name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployments(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployments(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of deployed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListProcessInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set up removal time
         * @summary Set up removalTime for completed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRemovalTime(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRemovalTime(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undeploy deployment by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeploy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeploy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undeploy deployment by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeployByName(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeployByName(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undeploy all version of process by process key(name)
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeployProcess(processName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeployProcess(processName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of deployed decision matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decisions(options?: any): AxiosPromise<RestResponseListDecisionInfo> {
            return localVarFp.decisions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy multipart files
         * @param {string} deploymentName 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy1(deploymentName: string, files: Array<any>, options?: any): AxiosPromise<RestResponseDeploymentInfo> {
            return localVarFp.deploy1(deploymentName, files, options).then((request) => request(axios, basePath));
        },
        /**
         * File deployed
         * @summary Deploy the last version of the file resource by path and filename
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByPathAndFilename(path: string, fileName: string, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.deployByPathAndFilename(path, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByUuid(fileUuid: string, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.deployByUuid(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy process archive
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployProcess(body: string, options?: any): AxiosPromise<RestResponseDeploymentInfo> {
            return localVarFp.deployProcess(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of deployments (identifier/name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployments(options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.deployments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of deployed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processes(options?: any): AxiosPromise<RestResponseListProcessInfo> {
            return localVarFp.processes(options).then((request) => request(axios, basePath));
        },
        /**
         * Set up removal time
         * @summary Set up removalTime for completed processes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemovalTime(options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.setRemovalTime(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undeploy deployment by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeploy(id: string, options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.undeploy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undeploy deployment by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployByName(name: string, options?: any): AxiosPromise<RestResponseListDeploymentInfo> {
            return localVarFp.undeployByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undeploy all version of process by process key(name)
         * @param {string} processName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployProcess(processName: string, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.undeployProcess(processName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deploy1 operation in DeploymentApi.
 * @export
 * @interface DeploymentApiDeploy1Request
 */
export interface DeploymentApiDeploy1Request {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiDeploy1
     */
    readonly deploymentName: string

    /**
     * 
     * @type {Array<any>}
     * @memberof DeploymentApiDeploy1
     */
    readonly files: Array<any>
}

/**
 * Request parameters for deployByPathAndFilename operation in DeploymentApi.
 * @export
 * @interface DeploymentApiDeployByPathAndFilenameRequest
 */
export interface DeploymentApiDeployByPathAndFilenameRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiDeployByPathAndFilename
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof DeploymentApiDeployByPathAndFilename
     */
    readonly fileName: string
}

/**
 * Request parameters for deployByUuid operation in DeploymentApi.
 * @export
 * @interface DeploymentApiDeployByUuidRequest
 */
export interface DeploymentApiDeployByUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiDeployByUuid
     */
    readonly fileUuid: string
}

/**
 * Request parameters for deployProcess operation in DeploymentApi.
 * @export
 * @interface DeploymentApiDeployProcessRequest
 */
export interface DeploymentApiDeployProcessRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiDeployProcess
     */
    readonly body: string
}

/**
 * Request parameters for undeploy operation in DeploymentApi.
 * @export
 * @interface DeploymentApiUndeployRequest
 */
export interface DeploymentApiUndeployRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiUndeploy
     */
    readonly id: string
}

/**
 * Request parameters for undeployByName operation in DeploymentApi.
 * @export
 * @interface DeploymentApiUndeployByNameRequest
 */
export interface DeploymentApiUndeployByNameRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiUndeployByName
     */
    readonly name: string
}

/**
 * Request parameters for undeployProcess operation in DeploymentApi.
 * @export
 * @interface DeploymentApiUndeployProcessRequest
 */
export interface DeploymentApiUndeployProcessRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentApiUndeployProcess
     */
    readonly processName: string
}

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Get list of deployed decision matrix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public decisions(options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).decisions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy multipart files
     * @param {DeploymentApiDeploy1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deploy1(requestParameters: DeploymentApiDeploy1Request, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deploy1(requestParameters.deploymentName, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File deployed
     * @summary Deploy the last version of the file resource by path and filename
     * @param {DeploymentApiDeployByPathAndFilenameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployByPathAndFilename(requestParameters: DeploymentApiDeployByPathAndFilenameRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deployByPathAndFilename(requestParameters.path, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File deployed
     * @summary Deploy file resource by uuid
     * @param {DeploymentApiDeployByUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployByUuid(requestParameters: DeploymentApiDeployByUuidRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deployByUuid(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy process archive
     * @param {DeploymentApiDeployProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployProcess(requestParameters: DeploymentApiDeployProcessRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deployProcess(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of deployments (identifier/name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployments(options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deployments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of deployed processes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public processes(options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).processes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set up removal time
     * @summary Set up removalTime for completed processes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public setRemovalTime(options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).setRemovalTime(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undeploy deployment by id
     * @param {DeploymentApiUndeployRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public undeploy(requestParameters: DeploymentApiUndeployRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).undeploy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undeploy deployment by name
     * @param {DeploymentApiUndeployByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public undeployByName(requestParameters: DeploymentApiUndeployByNameRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).undeployByName(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undeploy all version of process by process key(name)
     * @param {DeploymentApiUndeployProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public undeployProcess(requestParameters: DeploymentApiUndeployProcessRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).undeployProcess(requestParameters.processName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiagnosticApi - axios parameter creator
 * @export
 */
export const DiagnosticApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return information about server/node/instance including: version, build, os, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_environment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHc: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_working`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosticApi - functional programming interface
 * @export
 */
export const DiagnosticApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosticApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return information about server/node/instance including: version, build, os, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHc(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHc(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverallHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverallHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReady(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorking(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorking(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiagnosticApi - factory interface
 * @export
 */
export const DiagnosticApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosticApiFp(configuration)
    return {
        /**
         * 
         * @summary Return information about server/node/instance including: version, build, os, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(options?: any): AxiosPromise<EnvironmentHealth> {
            return localVarFp.getEnvironment(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHc(options?: any): AxiosPromise<Health> {
            return localVarFp.getHc(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLive(options?: any): AxiosPromise<Health> {
            return localVarFp.getLive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the status of API domain and all its components and dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallHealthCheck(options?: any): AxiosPromise<OverallHealth> {
            return localVarFp.getOverallHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response if this instance is able to receive traffic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady(options?: any): AxiosPromise<Health> {
            return localVarFp.getReady(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a summary of the health check results for API Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Health> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a successful response in the case that the API Domain is in a healthy working state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking(options?: any): AxiosPromise<Health> {
            return localVarFp.getWorking(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosticApi - object-oriented interface
 * @export
 * @class DiagnosticApi
 * @extends {BaseAPI}
 */
export class DiagnosticApi extends BaseAPI {
    /**
     * 
     * @summary Return information about server/node/instance including: version, build, os, etc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getEnvironment(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getEnvironment(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response if this instance is able to receive traffic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getHc(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getHc(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response in the case that the API Domain is in a healthy working state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getLive(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getLive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the status of API domain and all its components and dependencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getOverallHealthCheck(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getOverallHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response if this instance is able to receive traffic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getReady(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getReady(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a summary of the health check results for API Domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a successful response in the case that the API Domain is in a healthy working state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticApi
     */
    public getWorking(options?: AxiosRequestConfig) {
        return DiagnosticApiFp(this.configuration).getWorking(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DictionariesApi - axios parameter creator
 * @export
 */
export const DictionariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (dictionary: string, code?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictionary' is not null or undefined
            assertParamExists('findAll', 'dictionary', dictionary)
            const localVarPath = `/dictionaries/{dictionary}`
                .replace(`{${"dictionary"}}`, encodeURIComponent(String(dictionary)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read2: async (dictionary: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictionary' is not null or undefined
            assertParamExists('read2', 'dictionary', dictionary)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('read2', 'id', id)
            const localVarPath = `/dictionaries/{dictionary}/{id}`
                .replace(`{${"dictionary"}}`, encodeURIComponent(String(dictionary)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DictionariesApi - functional programming interface
 * @export
 */
export const DictionariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DictionariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(dictionary: string, code?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListGeneralDictionaryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(dictionary, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read2(dictionary: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseGeneralDictionaryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read2(dictionary, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DictionariesApi - factory interface
 * @export
 */
export const DictionariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DictionariesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get dictionary items
         * @param {string} dictionary 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(dictionary: string, code?: string, options?: any): AxiosPromise<RestResponseListGeneralDictionaryItem> {
            return localVarFp.findAll(dictionary, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dictionary item
         * @param {string} dictionary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read2(dictionary: string, id: number, options?: any): AxiosPromise<RestResponseGeneralDictionaryItem> {
            return localVarFp.read2(dictionary, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAll operation in DictionariesApi.
 * @export
 * @interface DictionariesApiFindAllRequest
 */
export interface DictionariesApiFindAllRequest {
    /**
     * 
     * @type {string}
     * @memberof DictionariesApiFindAll
     */
    readonly dictionary: string

    /**
     * 
     * @type {string}
     * @memberof DictionariesApiFindAll
     */
    readonly code?: string
}

/**
 * Request parameters for read2 operation in DictionariesApi.
 * @export
 * @interface DictionariesApiRead2Request
 */
export interface DictionariesApiRead2Request {
    /**
     * 
     * @type {string}
     * @memberof DictionariesApiRead2
     */
    readonly dictionary: string

    /**
     * 
     * @type {number}
     * @memberof DictionariesApiRead2
     */
    readonly id: number
}

/**
 * DictionariesApi - object-oriented interface
 * @export
 * @class DictionariesApi
 * @extends {BaseAPI}
 */
export class DictionariesApi extends BaseAPI {
    /**
     * 
     * @summary Get dictionary items
     * @param {DictionariesApiFindAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    public findAll(requestParameters: DictionariesApiFindAllRequest, options?: AxiosRequestConfig) {
        return DictionariesApiFp(this.configuration).findAll(requestParameters.dictionary, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dictionary item
     * @param {DictionariesApiRead2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    public read2(requestParameters: DictionariesApiRead2Request, options?: AxiosRequestConfig) {
        return DictionariesApiFp(this.configuration).read2(requestParameters.dictionary, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbacks: async (feedback: Array<Feedback>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('createFeedbacks', 'feedback', feedback)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedbacks: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAllFeedbacks', 'requestQuery', requestQuery)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getFeedback', 'uuid', uuid)
            const localVarPath = `/feedbacks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get given feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGivenFeedbackCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedbacks/given-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get requested feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestedFeedbackCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedbacks/requested-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('markAsRead', 'uuid', uuid)
            const localVarPath = `/feedbacks/{uuid}/read`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback: async (uuid: string, feedback: Feedback, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateFeedback', 'uuid', uuid)
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('updateFeedback', 'feedback', feedback)
            const localVarPath = `/feedbacks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbacks(feedback: Array<Feedback>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedbacks(feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFeedbacks(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFeedbacks(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedback(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedback(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get given feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGivenFeedbackCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseInteger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGivenFeedbackCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get requested feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestedFeedbackCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseInteger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestedFeedbackCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsRead(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsRead(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedback(uuid: string, feedback: Feedback, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedback(uuid, feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new list of feedbacks with items
         * @param {Array<Feedback>} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbacks(feedback: Array<Feedback>, options?: any): AxiosPromise<RestResponseListFeedback> {
            return localVarFp.createFeedbacks(feedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all feedbacks with all items
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFeedbacks(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListFeedback> {
            return localVarFp.getAllFeedbacks(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feedback by UUID with all items
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(uuid: string, options?: any): AxiosPromise<RestResponseFeedback> {
            return localVarFp.getFeedback(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get given feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGivenFeedbackCount(options?: any): AxiosPromise<RestResponseInteger> {
            return localVarFp.getGivenFeedbackCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get requested feedbacks count for colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestedFeedbackCount(options?: any): AxiosPromise<RestResponseInteger> {
            return localVarFp.getRequestedFeedbackCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an existing feedback as read
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(uuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.markAsRead(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing feedback
         * @param {string} uuid 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback(uuid: string, feedback: Feedback, options?: any): AxiosPromise<RestResponseFeedback> {
            return localVarFp.updateFeedback(uuid, feedback, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFeedbacks operation in FeedbackApi.
 * @export
 * @interface FeedbackApiCreateFeedbacksRequest
 */
export interface FeedbackApiCreateFeedbacksRequest {
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof FeedbackApiCreateFeedbacks
     */
    readonly feedback: Array<Feedback>
}

/**
 * Request parameters for getAllFeedbacks operation in FeedbackApi.
 * @export
 * @interface FeedbackApiGetAllFeedbacksRequest
 */
export interface FeedbackApiGetAllFeedbacksRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof FeedbackApiGetAllFeedbacks
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getFeedback operation in FeedbackApi.
 * @export
 * @interface FeedbackApiGetFeedbackRequest
 */
export interface FeedbackApiGetFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiGetFeedback
     */
    readonly uuid: string
}

/**
 * Request parameters for markAsRead operation in FeedbackApi.
 * @export
 * @interface FeedbackApiMarkAsReadRequest
 */
export interface FeedbackApiMarkAsReadRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiMarkAsRead
     */
    readonly uuid: string
}

/**
 * Request parameters for updateFeedback operation in FeedbackApi.
 * @export
 * @interface FeedbackApiUpdateFeedbackRequest
 */
export interface FeedbackApiUpdateFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiUpdateFeedback
     */
    readonly uuid: string

    /**
     * 
     * @type {Feedback}
     * @memberof FeedbackApiUpdateFeedback
     */
    readonly feedback: Feedback
}

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @summary Create a new list of feedbacks with items
     * @param {FeedbackApiCreateFeedbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createFeedbacks(requestParameters: FeedbackApiCreateFeedbacksRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createFeedbacks(requestParameters.feedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all feedbacks with all items
     * @param {FeedbackApiGetAllFeedbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getAllFeedbacks(requestParameters: FeedbackApiGetAllFeedbacksRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getAllFeedbacks(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feedback by UUID with all items
     * @param {FeedbackApiGetFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getFeedback(requestParameters: FeedbackApiGetFeedbackRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getFeedback(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get given feedbacks count for colleague
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getGivenFeedbackCount(options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getGivenFeedbackCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get requested feedbacks count for colleague
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getRequestedFeedbackCount(options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getRequestedFeedbackCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an existing feedback as read
     * @param {FeedbackApiMarkAsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public markAsRead(requestParameters: FeedbackApiMarkAsReadRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).markAsRead(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing feedback
     * @param {FeedbackApiUpdateFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public updateFeedback(requestParameters: FeedbackApiUpdateFeedbackRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).updateFeedback(requestParameters.uuid, requestParameters.feedback, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('delete5', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6: async (path: string, fileName: string, versions?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('delete6', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('delete6', 'fileName', fileName)
            const localVarPath = `/files/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (versions) {
                localVarQueryParameter['versions'] = versions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('download', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}/download`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('get2', 'requestQuery', requestQuery)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('get3', 'fileUuid', fileUuid)
            const localVarPath = `/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4: async (path: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('get4', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('get4', 'fileName', fileName)
            const localVarPath = `/files/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions: async (path: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getAllVersions', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getAllVersions', 'fileName', fileName)
            const localVarPath = `/files/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} uploadMetadata 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (uploadMetadata: any, files: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadMetadata' is not null or undefined
            assertParamExists('upload', 'uploadMetadata', uploadMetadata)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('upload', 'files', files)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (uploadMetadata !== undefined) { 
                localVarFormParams.append('uploadMetadata', uploadMetadata as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete5(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete5(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete6(path: string, fileName: string, versions?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete6(path, fileName, versions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get4(path: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get4(path, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVersions(path: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVersions(path, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} uploadMetadata 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(uploadMetadata: any, files: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(uploadMetadata, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Delete existing file
         * @summary Delete existing File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(fileUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete5(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing files
         * @summary Delete existing Files by its path, name and versions
         * @param {string} path 
         * @param {string} fileName 
         * @param {Array<number>} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(path: string, fileName: string, versions?: Array<number>, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete6(path, fileName, versions, options).then((request) => request(axios, basePath));
        },
        /**
         * Download File
         * @summary Download File
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(fileUuid: string, options?: any): AxiosPromise<any> {
            return localVarFp.download(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Files information with the latest version applying search, filter and sorting
         * @summary Get Files information with the latest version applying search, filter and sorting
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.get2(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Get File information with the latest version by its uuid
         * @summary Get File information with the latest version by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(fileUuid: string, options?: any): AxiosPromise<RestResponseFile> {
            return localVarFp.get3(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Files information with the latest version by file name and path
         * @summary Get Files information with the latest version by file name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(path: string, fileName: string, options?: any): AxiosPromise<RestResponseFile> {
            return localVarFp.get4(path, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all information about File with All Versions by its name and path
         * @summary Get all information about File with All Versions by its name and path
         * @param {string} path 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(path: string, fileName: string, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.getAllVersions(path, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload Files
         * @summary Upload Files
         * @param {any} uploadMetadata 
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(uploadMetadata: any, files: Array<any>, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.upload(uploadMetadata, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for delete5 operation in FileApi.
 * @export
 * @interface FileApiDelete5Request
 */
export interface FileApiDelete5Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiDelete5
     */
    readonly fileUuid: string
}

/**
 * Request parameters for delete6 operation in FileApi.
 * @export
 * @interface FileApiDelete6Request
 */
export interface FileApiDelete6Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiDelete6
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiDelete6
     */
    readonly fileName: string

    /**
     * 
     * @type {Array<number>}
     * @memberof FileApiDelete6
     */
    readonly versions?: Array<number>
}

/**
 * Request parameters for download operation in FileApi.
 * @export
 * @interface FileApiDownloadRequest
 */
export interface FileApiDownloadRequest {
    /**
     * 
     * @type {string}
     * @memberof FileApiDownload
     */
    readonly fileUuid: string
}

/**
 * Request parameters for get2 operation in FileApi.
 * @export
 * @interface FileApiGet2Request
 */
export interface FileApiGet2Request {
    /**
     * 
     * @type {RequestQuery}
     * @memberof FileApiGet2
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for get3 operation in FileApi.
 * @export
 * @interface FileApiGet3Request
 */
export interface FileApiGet3Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiGet3
     */
    readonly fileUuid: string
}

/**
 * Request parameters for get4 operation in FileApi.
 * @export
 * @interface FileApiGet4Request
 */
export interface FileApiGet4Request {
    /**
     * 
     * @type {string}
     * @memberof FileApiGet4
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiGet4
     */
    readonly fileName: string
}

/**
 * Request parameters for getAllVersions operation in FileApi.
 * @export
 * @interface FileApiGetAllVersionsRequest
 */
export interface FileApiGetAllVersionsRequest {
    /**
     * 
     * @type {string}
     * @memberof FileApiGetAllVersions
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof FileApiGetAllVersions
     */
    readonly fileName: string
}

/**
 * Request parameters for upload operation in FileApi.
 * @export
 * @interface FileApiUploadRequest
 */
export interface FileApiUploadRequest {
    /**
     * 
     * @type {any}
     * @memberof FileApiUpload
     */
    readonly uploadMetadata: any

    /**
     * 
     * @type {Array<any>}
     * @memberof FileApiUpload
     */
    readonly files: Array<any>
}

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Delete existing file
     * @summary Delete existing File by its uuid
     * @param {FileApiDelete5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public delete5(requestParameters: FileApiDelete5Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).delete5(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing files
     * @summary Delete existing Files by its path, name and versions
     * @param {FileApiDelete6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public delete6(requestParameters: FileApiDelete6Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).delete6(requestParameters.path, requestParameters.fileName, requestParameters.versions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download File
     * @summary Download File
     * @param {FileApiDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public download(requestParameters: FileApiDownloadRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).download(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Files information with the latest version applying search, filter and sorting
     * @summary Get Files information with the latest version applying search, filter and sorting
     * @param {FileApiGet2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get2(requestParameters: FileApiGet2Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get2(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get File information with the latest version by its uuid
     * @summary Get File information with the latest version by its uuid
     * @param {FileApiGet3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get3(requestParameters: FileApiGet3Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get3(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Files information with the latest version by file name and path
     * @summary Get Files information with the latest version by file name and path
     * @param {FileApiGet4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public get4(requestParameters: FileApiGet4Request, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).get4(requestParameters.path, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all information about File with All Versions by its name and path
     * @summary Get all information about File with All Versions by its name and path
     * @param {FileApiGetAllVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getAllVersions(requestParameters: FileApiGetAllVersionsRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).getAllVersions(requestParameters.path, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload Files
     * @summary Upload Files
     * @param {FileApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public upload(requestParameters: FileApiUploadRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).upload(requestParameters.uploadMetadata, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotesApi - axios parameter creator
 * @export
 */
export const NotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (folder: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('createFolder', 'folder', folder)
            const localVarPath = `/notes/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote: async (note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'note' is not null or undefined
            assertParamExists('createNote', 'note', note)
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete3', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete4', 'id', id)
            const localVarPath = `/notes/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find Notes by Folder
         * @param {string} ownerId 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByOwner1: async (ownerId: string, folderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('findByOwner1', 'ownerId', ownerId)
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('findByOwner1', 'folderId', folderId)
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (ownerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('get1', 'ownerId', ownerId)
            const localVarPath = `/notes/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (id: string, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update3', 'id', id)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('update3', 'note', note)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: async (id: string, folder: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update4', 'id', id)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('update4', 'folder', folder)
            const localVarPath = `/notes/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(folder: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNote(note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNote(note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete4(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find Notes by Folder
         * @param {string} ownerId 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByOwner1(ownerId: string, folderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByOwner1(ownerId, folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(ownerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(ownerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(id: string, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(id, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update4(id: string, folder: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update4(id, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Folder
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(folder: Folder, options?: any): AxiosPromise<RestResponseFolder> {
            return localVarFp.createFolder(folder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote(note: Note, options?: any): AxiosPromise<RestResponseNote> {
            return localVarFp.createNote(note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Note
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Folder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find Notes by Folder
         * @param {string} ownerId 
         * @param {string} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByOwner1(ownerId: string, folderId: string, options?: any): AxiosPromise<RestResponseListNote> {
            return localVarFp.findByOwner1(ownerId, folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find a Folder by Owner
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(ownerId: string, options?: any): AxiosPromise<RestResponseListFolder> {
            return localVarFp.get1(ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Note
         * @param {string} id 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(id: string, note: Note, options?: any): AxiosPromise<RestResponseNote> {
            return localVarFp.update3(id, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Folder
         * @param {string} id 
         * @param {Folder} folder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(id: string, folder: Folder, options?: any): AxiosPromise<RestResponseFolder> {
            return localVarFp.update4(id, folder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFolder operation in NotesApi.
 * @export
 * @interface NotesApiCreateFolderRequest
 */
export interface NotesApiCreateFolderRequest {
    /**
     * 
     * @type {Folder}
     * @memberof NotesApiCreateFolder
     */
    readonly folder: Folder
}

/**
 * Request parameters for createNote operation in NotesApi.
 * @export
 * @interface NotesApiCreateNoteRequest
 */
export interface NotesApiCreateNoteRequest {
    /**
     * 
     * @type {Note}
     * @memberof NotesApiCreateNote
     */
    readonly note: Note
}

/**
 * Request parameters for delete3 operation in NotesApi.
 * @export
 * @interface NotesApiDelete3Request
 */
export interface NotesApiDelete3Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiDelete3
     */
    readonly id: string
}

/**
 * Request parameters for delete4 operation in NotesApi.
 * @export
 * @interface NotesApiDelete4Request
 */
export interface NotesApiDelete4Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiDelete4
     */
    readonly id: string
}

/**
 * Request parameters for findByOwner1 operation in NotesApi.
 * @export
 * @interface NotesApiFindByOwner1Request
 */
export interface NotesApiFindByOwner1Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiFindByOwner1
     */
    readonly ownerId: string

    /**
     * 
     * @type {string}
     * @memberof NotesApiFindByOwner1
     */
    readonly folderId: string
}

/**
 * Request parameters for get1 operation in NotesApi.
 * @export
 * @interface NotesApiGet1Request
 */
export interface NotesApiGet1Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiGet1
     */
    readonly ownerId: string
}

/**
 * Request parameters for update3 operation in NotesApi.
 * @export
 * @interface NotesApiUpdate3Request
 */
export interface NotesApiUpdate3Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiUpdate3
     */
    readonly id: string

    /**
     * 
     * @type {Note}
     * @memberof NotesApiUpdate3
     */
    readonly note: Note
}

/**
 * Request parameters for update4 operation in NotesApi.
 * @export
 * @interface NotesApiUpdate4Request
 */
export interface NotesApiUpdate4Request {
    /**
     * 
     * @type {string}
     * @memberof NotesApiUpdate4
     */
    readonly id: string

    /**
     * 
     * @type {Folder}
     * @memberof NotesApiUpdate4
     */
    readonly folder: Folder
}

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * 
     * @summary Create a Folder
     * @param {NotesApiCreateFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public createFolder(requestParameters: NotesApiCreateFolderRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).createFolder(requestParameters.folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Note
     * @param {NotesApiCreateNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public createNote(requestParameters: NotesApiCreateNoteRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).createNote(requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Note
     * @param {NotesApiDelete3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public delete3(requestParameters: NotesApiDelete3Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).delete3(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Folder
     * @param {NotesApiDelete4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public delete4(requestParameters: NotesApiDelete4Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).delete4(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find Notes by Folder
     * @param {NotesApiFindByOwner1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public findByOwner1(requestParameters: NotesApiFindByOwner1Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).findByOwner1(requestParameters.ownerId, requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find a Folder by Owner
     * @param {NotesApiGet1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public get1(requestParameters: NotesApiGet1Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).get1(requestParameters.ownerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Note
     * @param {NotesApiUpdate3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public update3(requestParameters: NotesApiUpdate3Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).update3(requestParameters.id, requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Folder
     * @param {NotesApiUpdate4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public update4(requestParameters: NotesApiUpdate4Request, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).update4(requestParameters.id, requestParameters.folder, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrgMappingApi - axios parameter creator
 * @export
 */
export const OrgMappingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgMapping: async (orgMapping: Array<OrgMapping>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgMapping' is not null or undefined
            assertParamExists('addOrgMapping', 'orgMapping', orgMapping)
            const localVarPath = `/org-mapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organisation Mapping
         * @summary Import organisation mapping
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOrgMapping: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importOrgMapping', 'file', file)
            const localVarPath = `/org-mapping/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgMapping: async (orgMapping: Array<OrgMapping>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgMapping' is not null or undefined
            assertParamExists('removeOrgMapping', 'orgMapping', orgMapping)
            const localVarPath = `/org-mapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgMappingApi - functional programming interface
 * @export
 */
export const OrgMappingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgMappingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrgMapping(orgMapping: Array<OrgMapping>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrgMapping(orgMapping, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Organisation Mapping
         * @summary Import organisation mapping
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importOrgMapping(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrgMappingImportReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importOrgMapping(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrgMapping(orgMapping: Array<OrgMapping>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrgMapping(orgMapping, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrgMappingApi - factory interface
 * @export
 */
export const OrgMappingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgMappingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgMapping(orgMapping: Array<OrgMapping>, options?: any): AxiosPromise<RestResponseListOrgMapping> {
            return localVarFp.addOrgMapping(orgMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * Organisation Mapping
         * @summary Import organisation mapping
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOrgMapping(file: any, options?: any): AxiosPromise<RestResponseOrgMappingImportReport> {
            return localVarFp.importOrgMapping(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove organisation mapping
         * @param {Array<OrgMapping>} orgMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgMapping(orgMapping: Array<OrgMapping>, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.removeOrgMapping(orgMapping, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrgMapping operation in OrgMappingApi.
 * @export
 * @interface OrgMappingApiAddOrgMappingRequest
 */
export interface OrgMappingApiAddOrgMappingRequest {
    /**
     * 
     * @type {Array<OrgMapping>}
     * @memberof OrgMappingApiAddOrgMapping
     */
    readonly orgMapping: Array<OrgMapping>
}

/**
 * Request parameters for importOrgMapping operation in OrgMappingApi.
 * @export
 * @interface OrgMappingApiImportOrgMappingRequest
 */
export interface OrgMappingApiImportOrgMappingRequest {
    /**
     * 
     * @type {any}
     * @memberof OrgMappingApiImportOrgMapping
     */
    readonly file: any
}

/**
 * Request parameters for removeOrgMapping operation in OrgMappingApi.
 * @export
 * @interface OrgMappingApiRemoveOrgMappingRequest
 */
export interface OrgMappingApiRemoveOrgMappingRequest {
    /**
     * 
     * @type {Array<OrgMapping>}
     * @memberof OrgMappingApiRemoveOrgMapping
     */
    readonly orgMapping: Array<OrgMapping>
}

/**
 * OrgMappingApi - object-oriented interface
 * @export
 * @class OrgMappingApi
 * @extends {BaseAPI}
 */
export class OrgMappingApi extends BaseAPI {
    /**
     * 
     * @summary Add organisation mapping
     * @param {OrgMappingApiAddOrgMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgMappingApi
     */
    public addOrgMapping(requestParameters: OrgMappingApiAddOrgMappingRequest, options?: AxiosRequestConfig) {
        return OrgMappingApiFp(this.configuration).addOrgMapping(requestParameters.orgMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organisation Mapping
     * @summary Import organisation mapping
     * @param {OrgMappingApiImportOrgMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgMappingApi
     */
    public importOrgMapping(requestParameters: OrgMappingApiImportOrgMappingRequest, options?: AxiosRequestConfig) {
        return OrgMappingApiFp(this.configuration).importOrgMapping(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove organisation mapping
     * @param {OrgMappingApiRemoveOrgMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgMappingApi
     */
    public removeOrgMapping(requestParameters: OrgMappingApiRemoveOrgMappingRequest, options?: AxiosRequestConfig) {
        return OrgMappingApiFp(this.configuration).removeOrgMapping(requestParameters.orgMapping, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrgObjectiveApi - axios parameter creator
 * @export
 */
export const OrgObjectiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndPublishOrgObjectives: async (orgObjective: Array<OrgObjective>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgObjective' is not null or undefined
            assertParamExists('createAndPublishOrgObjectives', 'orgObjective', orgObjective)
            const localVarPath = `/org-objectives/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgObjective, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgObjectives: async (orgObjective: Array<OrgObjective>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgObjective' is not null or undefined
            assertParamExists('createOrgObjectives', 'orgObjective', orgObjective)
            const localVarPath = `/org-objectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orgObjective, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAuditLogReport', 'requestQuery', requestQuery)
            const localVarPath = `/audit-logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOrgObjectives: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org-objectives/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgObjectiveApi - functional programming interface
 * @export
 */
export const OrgObjectiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgObjectiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndPublishOrgObjectives(orgObjective: Array<OrgObjective>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndPublishOrgObjectives(orgObjective, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgObjectives(orgObjective: Array<OrgObjective>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgObjectives(orgObjective, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListAuditOrgObjectiveReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishOrgObjectives(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrgObjective>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishOrgObjectives(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrgObjectiveApi - factory interface
 * @export
 */
export const OrgObjectiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgObjectiveApiFp(configuration)
    return {
        /**
         * 
         * @summary Create and publish organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndPublishOrgObjectives(orgObjective: Array<OrgObjective>, options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.createAndPublishOrgObjectives(orgObjective, options).then((request) => request(axios, basePath));
        },
        /**
         * Organisation objectives created
         * @summary Create new organisation objectives
         * @param {Array<OrgObjective>} orgObjective 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgObjectives(orgObjective: Array<OrgObjective>, options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.createOrgObjectives(orgObjective, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get audit log of organisation objective actions
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListAuditOrgObjectiveReport> {
            return localVarFp.getAuditLogReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.getOrgObjectives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.getPublishedOrgObjectives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish organisation objectives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOrgObjectives(options?: any): AxiosPromise<RestResponseListOrgObjective> {
            return localVarFp.publishOrgObjectives(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAndPublishOrgObjectives operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiCreateAndPublishOrgObjectivesRequest
 */
export interface OrgObjectiveApiCreateAndPublishOrgObjectivesRequest {
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof OrgObjectiveApiCreateAndPublishOrgObjectives
     */
    readonly orgObjective: Array<OrgObjective>
}

/**
 * Request parameters for createOrgObjectives operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiCreateOrgObjectivesRequest
 */
export interface OrgObjectiveApiCreateOrgObjectivesRequest {
    /**
     * 
     * @type {Array<OrgObjective>}
     * @memberof OrgObjectiveApiCreateOrgObjectives
     */
    readonly orgObjective: Array<OrgObjective>
}

/**
 * Request parameters for getAuditLogReport operation in OrgObjectiveApi.
 * @export
 * @interface OrgObjectiveApiGetAuditLogReportRequest
 */
export interface OrgObjectiveApiGetAuditLogReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof OrgObjectiveApiGetAuditLogReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * OrgObjectiveApi - object-oriented interface
 * @export
 * @class OrgObjectiveApi
 * @extends {BaseAPI}
 */
export class OrgObjectiveApi extends BaseAPI {
    /**
     * 
     * @summary Create and publish organisation objectives
     * @param {OrgObjectiveApiCreateAndPublishOrgObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public createAndPublishOrgObjectives(requestParameters: OrgObjectiveApiCreateAndPublishOrgObjectivesRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).createAndPublishOrgObjectives(requestParameters.orgObjective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organisation objectives created
     * @summary Create new organisation objectives
     * @param {OrgObjectiveApiCreateOrgObjectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public createOrgObjectives(requestParameters: OrgObjectiveApiCreateOrgObjectivesRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).createOrgObjectives(requestParameters.orgObjective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get audit log of organisation objective actions
     * @param {OrgObjectiveApiGetAuditLogReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getAuditLogReport(requestParameters: OrgObjectiveApiGetAuditLogReportRequest, options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getAuditLogReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public getPublishedOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).getPublishedOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish organisation objectives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgObjectiveApi
     */
    public publishOrgObjectives(options?: AxiosRequestConfig) {
        return OrgObjectiveApiFp(this.configuration).publishOrgObjectives(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganisationDictionaryApi - axios parameter creator
 * @export
 */
export const OrganisationDictionaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (organisationDictionary: OrganisationDictionary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationDictionary' is not null or undefined
            assertParamExists('create3', 'organisationDictionary', organisationDictionary)
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationDictionary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('delete2', 'code', code)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganisationDictionaries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organisations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganisationDictionary: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('findOrganisationDictionary', 'code', code)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organisation Hierarchy For Legal Entity
         * @summary Get organisation hierarchy for a legal entity
         * @param {string} legalEntityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationHierarchy: async (legalEntityName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'legalEntityName' is not null or undefined
            assertParamExists('getOrganisationHierarchy', 'legalEntityName', legalEntityName)
            const localVarPath = `/org-hierarchies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (legalEntityName !== undefined) {
                localVarQueryParameter['legal-entity-name'] = legalEntityName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (code: string, organisationDictionary: OrganisationDictionary, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('update2', 'code', code)
            // verify required parameter 'organisationDictionary' is not null or undefined
            assertParamExists('update2', 'organisationDictionary', organisationDictionary)
            const localVarPath = `/organisations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationDictionary, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationDictionaryApi - functional programming interface
 * @export
 */
export const OrganisationDictionaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationDictionaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(organisationDictionary: OrganisationDictionary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(organisationDictionary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganisationDictionaries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganisationDictionaries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganisationDictionary(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganisationDictionary(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Organisation Hierarchy For Legal Entity
         * @summary Get organisation hierarchy for a legal entity
         * @param {string} legalEntityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisationHierarchy(legalEntityName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrgHierarchy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisationHierarchy(legalEntityName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(code: string, organisationDictionary: OrganisationDictionary, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOrganisationDictionary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(code, organisationDictionary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganisationDictionaryApi - factory interface
 * @export
 */
export const OrganisationDictionaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationDictionaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create organisation dictionary
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(organisationDictionary: OrganisationDictionary, options?: any): AxiosPromise<RestResponseOrganisationDictionary> {
            return localVarFp.create3(organisationDictionary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organisation dictionary
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(code: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete2(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organisation dictionaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganisationDictionaries(options?: any): AxiosPromise<RestResponseListOrganisationDictionary> {
            return localVarFp.findAllOrganisationDictionaries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organisation dictionary by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganisationDictionary(code: string, options?: any): AxiosPromise<RestResponseOrganisationDictionary> {
            return localVarFp.findOrganisationDictionary(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Organisation Hierarchy For Legal Entity
         * @summary Get organisation hierarchy for a legal entity
         * @param {string} legalEntityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationHierarchy(legalEntityName: string, options?: any): AxiosPromise<RestResponseOrgHierarchy> {
            return localVarFp.getOrganisationHierarchy(legalEntityName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organisation dictionary
         * @param {string} code 
         * @param {OrganisationDictionary} organisationDictionary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(code: string, organisationDictionary: OrganisationDictionary, options?: any): AxiosPromise<RestResponseOrganisationDictionary> {
            return localVarFp.update2(code, organisationDictionary, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create3 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiCreate3Request
 */
export interface OrganisationDictionaryApiCreate3Request {
    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof OrganisationDictionaryApiCreate3
     */
    readonly organisationDictionary: OrganisationDictionary
}

/**
 * Request parameters for delete2 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiDelete2Request
 */
export interface OrganisationDictionaryApiDelete2Request {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiDelete2
     */
    readonly code: string
}

/**
 * Request parameters for findOrganisationDictionary operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiFindOrganisationDictionaryRequest
 */
export interface OrganisationDictionaryApiFindOrganisationDictionaryRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiFindOrganisationDictionary
     */
    readonly code: string
}

/**
 * Request parameters for getOrganisationHierarchy operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiGetOrganisationHierarchyRequest
 */
export interface OrganisationDictionaryApiGetOrganisationHierarchyRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiGetOrganisationHierarchy
     */
    readonly legalEntityName: string
}

/**
 * Request parameters for update2 operation in OrganisationDictionaryApi.
 * @export
 * @interface OrganisationDictionaryApiUpdate2Request
 */
export interface OrganisationDictionaryApiUpdate2Request {
    /**
     * 
     * @type {string}
     * @memberof OrganisationDictionaryApiUpdate2
     */
    readonly code: string

    /**
     * 
     * @type {OrganisationDictionary}
     * @memberof OrganisationDictionaryApiUpdate2
     */
    readonly organisationDictionary: OrganisationDictionary
}

/**
 * OrganisationDictionaryApi - object-oriented interface
 * @export
 * @class OrganisationDictionaryApi
 * @extends {BaseAPI}
 */
export class OrganisationDictionaryApi extends BaseAPI {
    /**
     * 
     * @summary Create organisation dictionary
     * @param {OrganisationDictionaryApiCreate3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public create3(requestParameters: OrganisationDictionaryApiCreate3Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).create3(requestParameters.organisationDictionary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organisation dictionary
     * @param {OrganisationDictionaryApiDelete2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public delete2(requestParameters: OrganisationDictionaryApiDelete2Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).delete2(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organisation dictionaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public findAllOrganisationDictionaries(options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).findAllOrganisationDictionaries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organisation dictionary by code
     * @param {OrganisationDictionaryApiFindOrganisationDictionaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public findOrganisationDictionary(requestParameters: OrganisationDictionaryApiFindOrganisationDictionaryRequest, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).findOrganisationDictionary(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organisation Hierarchy For Legal Entity
     * @summary Get organisation hierarchy for a legal entity
     * @param {OrganisationDictionaryApiGetOrganisationHierarchyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public getOrganisationHierarchy(requestParameters: OrganisationDictionaryApiGetOrganisationHierarchyRequest, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).getOrganisationHierarchy(requestParameters.legalEntityName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organisation dictionary
     * @param {OrganisationDictionaryApiUpdate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationDictionaryApi
     */
    public update2(requestParameters: OrganisationDictionaryApiUpdate2Request, options?: AxiosRequestConfig) {
        return OrganisationDictionaryApiFp(this.configuration).update2(requestParameters.code, requestParameters.organisationDictionary, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PdpApi - axios parameter creator
 * @export
 */
export const PdpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (pDPGoal: Array<PDPGoal>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pDPGoal' is not null or undefined
            assertParamExists('create2', 'pDPGoal', pDPGoal)
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pDPGoal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal: async (goalUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalUuid' is not null or undefined
            assertParamExists('deleteGoal', 'goalUuid', goalUuid)
            const localVarPath = `/pdp/goals/{goalUuid}`
                .replace(`{${"goalUuid"}}`, encodeURIComponent(String(goalUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTemplate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pdp/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the earliest achievement date of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarlyAchievementDate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pdp/goals/early-achievement-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal: async (goalUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalUuid' is not null or undefined
            assertParamExists('getGoal', 'goalUuid', goalUuid)
            const localVarPath = `/pdp/goals/{goalUuid}`
                .replace(`{${"goalUuid"}}`, encodeURIComponent(String(goalUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal1: async (number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getGoal1', 'number', number)
            const localVarPath = `/pdp/goals/numbers/{number}`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (pDPGoal: Array<PDPGoal>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pDPGoal' is not null or undefined
            assertParamExists('update1', 'pDPGoal', pDPGoal)
            const localVarPath = `/pdp/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pDPGoal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PdpApi - functional programming interface
 * @export
 */
export const PdpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PdpApiAxiosParamCreator(configuration)
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(pDPGoal: Array<PDPGoal>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPDPGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(pDPGoal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoal(goalUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoal(goalUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTemplate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTemplate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the earliest achievement date of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarlyAchievementDate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseLocalDate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarlyAchievementDate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoal(goalUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoal(goalUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoal1(number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoal1(number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoals(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePDPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoals(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(pDPGoal: Array<PDPGoal>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPDPGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(pDPGoal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PdpApi - factory interface
 * @export
 */
export const PdpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PdpApiFp(configuration)
    return {
        /**
         * PDP created
         * @summary Create a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(pDPGoal: Array<PDPGoal>, options?: any): AxiosPromise<RestResponseListPDPGoal> {
            return localVarFp.create2(pDPGoal, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing PDP Goal
         * @summary Delete existing PDP Goal from a Plan by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(goalUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteGoal(goalUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Download PDP template file
         * @summary Download PDP template file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTemplate(options?: any): AxiosPromise<any> {
            return localVarFp.downloadTemplate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the earliest achievement date of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarlyAchievementDate(options?: any): AxiosPromise<RestResponseLocalDate> {
            return localVarFp.getEarlyAchievementDate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a PDP Goal by its uuid
         * @param {string} goalUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(goalUuid: string, options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoal(goalUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a PDP Goal by its colleague and number
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal1(number: number, options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoal1(number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of PDP Goals by its colleague
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options?: any): AxiosPromise<RestResponsePDPResponse> {
            return localVarFp.getGoals(options).then((request) => request(axios, basePath));
        },
        /**
         * PDP updated
         * @summary Update a PDP
         * @param {Array<PDPGoal>} pDPGoal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(pDPGoal: Array<PDPGoal>, options?: any): AxiosPromise<RestResponseListPDPGoal> {
            return localVarFp.update1(pDPGoal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create2 operation in PdpApi.
 * @export
 * @interface PdpApiCreate2Request
 */
export interface PdpApiCreate2Request {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PdpApiCreate2
     */
    readonly pDPGoal: Array<PDPGoal>
}

/**
 * Request parameters for deleteGoal operation in PdpApi.
 * @export
 * @interface PdpApiDeleteGoalRequest
 */
export interface PdpApiDeleteGoalRequest {
    /**
     * 
     * @type {string}
     * @memberof PdpApiDeleteGoal
     */
    readonly goalUuid: string
}

/**
 * Request parameters for getGoal operation in PdpApi.
 * @export
 * @interface PdpApiGetGoalRequest
 */
export interface PdpApiGetGoalRequest {
    /**
     * 
     * @type {string}
     * @memberof PdpApiGetGoal
     */
    readonly goalUuid: string
}

/**
 * Request parameters for getGoal1 operation in PdpApi.
 * @export
 * @interface PdpApiGetGoal1Request
 */
export interface PdpApiGetGoal1Request {
    /**
     * 
     * @type {number}
     * @memberof PdpApiGetGoal1
     */
    readonly number: number
}

/**
 * Request parameters for update1 operation in PdpApi.
 * @export
 * @interface PdpApiUpdate1Request
 */
export interface PdpApiUpdate1Request {
    /**
     * 
     * @type {Array<PDPGoal>}
     * @memberof PdpApiUpdate1
     */
    readonly pDPGoal: Array<PDPGoal>
}

/**
 * PdpApi - object-oriented interface
 * @export
 * @class PdpApi
 * @extends {BaseAPI}
 */
export class PdpApi extends BaseAPI {
    /**
     * PDP created
     * @summary Create a PDP
     * @param {PdpApiCreate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public create2(requestParameters: PdpApiCreate2Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).create2(requestParameters.pDPGoal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing PDP Goal
     * @summary Delete existing PDP Goal from a Plan by its uuid
     * @param {PdpApiDeleteGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public deleteGoal(requestParameters: PdpApiDeleteGoalRequest, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).deleteGoal(requestParameters.goalUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download PDP template file
     * @summary Download PDP template file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public downloadTemplate(options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).downloadTemplate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the earliest achievement date of PDP Goals by its colleague
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getEarlyAchievementDate(options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getEarlyAchievementDate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a PDP Goal by its uuid
     * @param {PdpApiGetGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoal(requestParameters: PdpApiGetGoalRequest, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoal(requestParameters.goalUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a PDP Goal by its colleague and number
     * @param {PdpApiGetGoal1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoal1(requestParameters: PdpApiGetGoal1Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoal1(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of PDP Goals by its colleague
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public getGoals(options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).getGoals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PDP updated
     * @summary Update a PDP
     * @param {PdpApiUpdate1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PdpApi
     */
    public update1(requestParameters: PdpApiUpdate1Request, options?: AxiosRequestConfig) {
        return PdpApiFp(this.configuration).update1(requestParameters.pDPGoal, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PerformanceCycleApi - axios parameter creator
 * @export
 */
export const PerformanceCycleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('create1', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deploy', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}/deploy`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File deployed
         * @summary Deploy file resource by path and name for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} path 
         * @param {string} fileName 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTemplateByPathAndNameForCycle: async (cycleUuid: string, path: string, fileName: string, mergeMode: 'ADDED' | 'OVERWRITE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('deployTemplateByPathAndNameForCycle', 'cycleUuid', cycleUuid)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deployTemplateByPathAndNameForCycle', 'path', path)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deployTemplateByPathAndNameForCycle', 'fileName', fileName)
            // verify required parameter 'mergeMode' is not null or undefined
            assertParamExists('deployTemplateByPathAndNameForCycle', 'mergeMode', mergeMode)
            const localVarPath = `/pm-cycles/{cycleUuid}/files/deploy`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file-name'] = fileName;
            }

            if (mergeMode !== undefined) {
                localVarQueryParameter['merge-mode'] = mergeMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} fileUuid 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTemplateByUuidForCycle: async (cycleUuid: string, fileUuid: string, mergeMode: 'ADDED' | 'OVERWRITE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('deployTemplateByUuidForCycle', 'cycleUuid', cycleUuid)
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('deployTemplateByUuidForCycle', 'fileUuid', fileUuid)
            // verify required parameter 'mergeMode' is not null or undefined
            assertParamExists('deployTemplateByUuidForCycle', 'mergeMode', mergeMode)
            const localVarPath = `/pm-cycles/{cycleUuid}/files/{fileUuid}/deploy`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mergeMode !== undefined) {
                localVarQueryParameter['merge-mode'] = mergeMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (uuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('get', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (requestQuery: RequestQuery, includeMetadata?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAll', 'requestQuery', requestQuery)
            const localVarPath = `/pm-cycles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get colleague cycles for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagueCycles: async (colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getColleagueCycles', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getColleagueCycles', 'cycleUuid', cycleUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getColleagueCycles', 'requestQuery', requestQuery)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/colleague-cycles`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleague: async (colleagueUuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getMetadataByColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/metadata`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get full metadata for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleagueAndCycle: async (colleagueUuid: string, cycleUuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getMetadataByColleagueAndCycle', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getMetadataByColleagueAndCycle', 'cycleUuid', cycleUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/metadata`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle mapping keys per colleagues
         * @param {Array<string>} uuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMappingKeyByColleagues: async (uuids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuids' is not null or undefined
            assertParamExists('getPmCycleMappingKeyByColleagues', 'uuids', uuids)
            const localVarPath = `/pm-cycles/mappings/keys/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuids) {
                localVarQueryParameter['uuids'] = uuids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle mapping keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMappingKeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pm-cycles/mappings/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMetadata: async (uuid: string, includeForms?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPmCycleMetadata', 'uuid', uuid)
            const localVarPath = `/pm-cycles/files/{uuid}/metadata`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeForms !== undefined) {
                localVarQueryParameter['includeForms'] = includeForms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get performance cycles per colleague
         * @param {string} colleagueUuid 
         * @param {string} allowedStatuses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCyclesByColleague: async (colleagueUuid: string, allowedStatuses: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getPmCyclesByColleague', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'allowedStatuses' is not null or undefined
            assertParamExists('getPmCyclesByColleague', 'allowedStatuses', allowedStatuses)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (allowedStatuses !== undefined) {
                localVarQueryParameter['allowedStatuses'] = allowedStatuses;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('publish', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle for colleague
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startColleagueCycle: async (cycleUuid: string, colleagueUuid: string, requestBody: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('startColleagueCycle', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('startColleagueCycle', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('startColleagueCycle', 'requestBody', requestBody)
            const localVarPath = `/pm-cycles/{cycleUuid}/colleagues/{colleagueUuid}/start`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScheduled: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('startScheduled', 'uuid', uuid)
            const localVarPath = `/pm-cycles/{uuid}/start-scheduled`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (uuid: string, pMCycle: PMCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('update', 'uuid', uuid)
            // verify required parameter 'pMCycle' is not null or undefined
            assertParamExists('update', 'pMCycle', pMCycle)
            const localVarPath = `/pm-cycles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update performance cycle form
         * @summary Update form
         * @param {string} uuid 
         * @param {PMCycleUpdateFormRequest} pMCycleUpdateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm: async (uuid: string, pMCycleUpdateFormRequest: PMCycleUpdateFormRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateForm', 'uuid', uuid)
            // verify required parameter 'pMCycleUpdateFormRequest' is not null or undefined
            assertParamExists('updateForm', 'pMCycleUpdateFormRequest', pMCycleUpdateFormRequest)
            const localVarPath = `/pm-cycles/{uuid}/forms`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pMCycleUpdateFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update form to the latest version
         * @summary Update form to the latest version
         * @param {string} uuid 
         * @param {string} formKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFormLatestVersion: async (uuid: string, formKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateFormLatestVersion', 'uuid', uuid)
            // verify required parameter 'formKey' is not null or undefined
            assertParamExists('updateFormLatestVersion', 'formKey', formKey)
            const localVarPath = `/pm-cycles/{uuid}/forms/latest`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (formKey !== undefined) {
                localVarQueryParameter['form-key'] = formKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateStatus', 'uuid', uuid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateStatus', 'status', status)
            const localVarPath = `/pm-cycles/{uuid}/statuses/{status}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerformanceCycleApi - functional programming interface
 * @export
 */
export const PerformanceCycleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PerformanceCycleApiAxiosParamCreator(configuration)
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUUID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * File deployed
         * @summary Deploy file resource by path and name for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} path 
         * @param {string} fileName 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployTemplateByPathAndNameForCycle(cycleUuid: string, path: string, fileName: string, mergeMode: 'ADDED' | 'OVERWRITE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployTemplateByPathAndNameForCycle(cycleUuid, path, fileName, mergeMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} fileUuid 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployTemplateByUuidForCycle(cycleUuid: string, fileUuid: string, mergeMode: 'ADDED' | 'OVERWRITE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployTemplateByUuidForCycle(cycleUuid, fileUuid, mergeMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(uuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(uuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(requestQuery: RequestQuery, includeMetadata?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(requestQuery, includeMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get colleague cycles for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColleagueCycles(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPMColleagueCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColleagueCycles(colleagueUuid, cycleUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataByColleague(colleagueUuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataByColleague(colleagueUuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get full metadata for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataByColleagueAndCycle(colleagueUuid: string, cycleUuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataByColleagueAndCycle(colleagueUuid, cycleUuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle mapping keys per colleagues
         * @param {Array<string>} uuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmCycleMappingKeyByColleagues(uuids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapUUIDString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmCycleMappingKeyByColleagues(uuids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle mapping keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmCycleMappingKeys(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseSetString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmCycleMappingKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmCycleMetadata(uuid: string, includeForms?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCompositePMCycleMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmCycleMetadata(uuid, includeForms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get performance cycles per colleague
         * @param {string} colleagueUuid 
         * @param {string} allowedStatuses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPmCyclesByColleague(colleagueUuid: string, allowedStatuses: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListPMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPmCyclesByColleague(colleagueUuid, allowedStatuses, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle for colleague
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startColleagueCycle(cycleUuid: string, colleagueUuid: string, requestBody: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startColleagueCycle(cycleUuid, colleagueUuid, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startScheduled(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startScheduled(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(uuid: string, pMCycle: PMCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(uuid, pMCycle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update performance cycle form
         * @summary Update form
         * @param {string} uuid 
         * @param {PMCycleUpdateFormRequest} pMCycleUpdateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(uuid: string, pMCycleUpdateFormRequest: PMCycleUpdateFormRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(uuid, pMCycleUpdateFormRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update form to the latest version
         * @summary Update form to the latest version
         * @param {string} uuid 
         * @param {string} formKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFormLatestVersion(uuid: string, formKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFormLatestVersion(uuid, formKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatus(uuid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PerformanceCycleApi - factory interface
 * @export
 */
export const PerformanceCycleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PerformanceCycleApiFp(configuration)
    return {
        /**
         * Performance cycle created
         * @summary Create performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.create1(pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle deployed
         * @summary Deploy performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy(uuid: string, options?: any): AxiosPromise<RestResponseUUID> {
            return localVarFp.deploy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * File deployed
         * @summary Deploy file resource by path and name for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} path 
         * @param {string} fileName 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTemplateByPathAndNameForCycle(cycleUuid: string, path: string, fileName: string, mergeMode: 'ADDED' | 'OVERWRITE', options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deployTemplateByPathAndNameForCycle(cycleUuid, path, fileName, mergeMode, options).then((request) => request(axios, basePath));
        },
        /**
         * File deployed
         * @summary Deploy file resource by uuid for existing performance cycle
         * @param {string} cycleUuid 
         * @param {string} fileUuid 
         * @param {'ADDED' | 'OVERWRITE'} mergeMode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTemplateByUuidForCycle(cycleUuid: string, fileUuid: string, mergeMode: 'ADDED' | 'OVERWRITE', options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deployTemplateByUuidForCycle(cycleUuid, fileUuid, mergeMode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle by UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(uuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleResponse> {
            return localVarFp.get(uuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all performance cycles
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(requestQuery: RequestQuery, includeMetadata?: boolean, options?: any): AxiosPromise<RestResponseListPMCycle> {
            return localVarFp.getAll(requestQuery, includeMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get colleague cycles for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColleagueCycles(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListPMColleagueCycle> {
            return localVarFp.getColleagueCycles(colleagueUuid, cycleUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get full metadata for colleague
         * @param {string} colleagueUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleague(colleagueUuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleMetadataResponse> {
            return localVarFp.getMetadataByColleague(colleagueUuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get full metadata for colleague and cycle
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataByColleagueAndCycle(colleagueUuid: string, cycleUuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleMetadataResponse> {
            return localVarFp.getMetadataByColleagueAndCycle(colleagueUuid, cycleUuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle mapping keys per colleagues
         * @param {Array<string>} uuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMappingKeyByColleagues(uuids: Array<string>, options?: any): AxiosPromise<RestResponseMapUUIDString> {
            return localVarFp.getPmCycleMappingKeyByColleagues(uuids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle mapping keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMappingKeys(options?: any): AxiosPromise<RestResponseSetString> {
            return localVarFp.getPmCycleMappingKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycle metadata by file UUID
         * @param {string} uuid 
         * @param {boolean} [includeForms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCycleMetadata(uuid: string, includeForms?: boolean, options?: any): AxiosPromise<RestResponseCompositePMCycleMetadataResponse> {
            return localVarFp.getPmCycleMetadata(uuid, includeForms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get performance cycles per colleague
         * @param {string} colleagueUuid 
         * @param {string} allowedStatuses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPmCyclesByColleague(colleagueUuid: string, allowedStatuses: string, options?: any): AxiosPromise<RestResponseListPMCycle> {
            return localVarFp.getPmCyclesByColleague(colleagueUuid, allowedStatuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle published
         * @summary Publish performance cycle
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.publish(pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle for colleague
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startColleagueCycle(cycleUuid: string, colleagueUuid: string, requestBody: { [key: string]: string; }, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.startColleagueCycle(cycleUuid, colleagueUuid, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle started
         * @summary Start performance cycle
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScheduled(uuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.startScheduled(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Performance cycle edited
         * @summary Updates an existing performance cycle
         * @param {string} uuid 
         * @param {PMCycle} pMCycle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(uuid: string, pMCycle: PMCycle, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.update(uuid, pMCycle, options).then((request) => request(axios, basePath));
        },
        /**
         * Update performance cycle form
         * @summary Update form
         * @param {string} uuid 
         * @param {PMCycleUpdateFormRequest} pMCycleUpdateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm(uuid: string, pMCycleUpdateFormRequest: PMCycleUpdateFormRequest, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.updateForm(uuid, pMCycleUpdateFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update form to the latest version
         * @summary Update form to the latest version
         * @param {string} uuid 
         * @param {string} formKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFormLatestVersion(uuid: string, formKey: string, options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.updateFormLatestVersion(uuid, formKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update performance cycle status
         * @param {string} uuid 
         * @param {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED'} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(uuid: string, status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED', options?: any): AxiosPromise<RestResponsePMCycle> {
            return localVarFp.updateStatus(uuid, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create1 operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiCreate1Request
 */
export interface PerformanceCycleApiCreate1Request {
    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiCreate1
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for deploy operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiDeployRequest
 */
export interface PerformanceCycleApiDeployRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeploy
     */
    readonly uuid: string
}

/**
 * Request parameters for deployTemplateByPathAndNameForCycle operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiDeployTemplateByPathAndNameForCycleRequest
 */
export interface PerformanceCycleApiDeployTemplateByPathAndNameForCycleRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeployTemplateByPathAndNameForCycle
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeployTemplateByPathAndNameForCycle
     */
    readonly path: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeployTemplateByPathAndNameForCycle
     */
    readonly fileName: string

    /**
     * 
     * @type {'ADDED' | 'OVERWRITE'}
     * @memberof PerformanceCycleApiDeployTemplateByPathAndNameForCycle
     */
    readonly mergeMode: 'ADDED' | 'OVERWRITE'
}

/**
 * Request parameters for deployTemplateByUuidForCycle operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiDeployTemplateByUuidForCycleRequest
 */
export interface PerformanceCycleApiDeployTemplateByUuidForCycleRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeployTemplateByUuidForCycle
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiDeployTemplateByUuidForCycle
     */
    readonly fileUuid: string

    /**
     * 
     * @type {'ADDED' | 'OVERWRITE'}
     * @memberof PerformanceCycleApiDeployTemplateByUuidForCycle
     */
    readonly mergeMode: 'ADDED' | 'OVERWRITE'
}

/**
 * Request parameters for get operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetRequest
 */
export interface PerformanceCycleApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGet
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGet
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getAll operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetAllRequest
 */
export interface PerformanceCycleApiGetAllRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof PerformanceCycleApiGetAll
     */
    readonly requestQuery: RequestQuery

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetAll
     */
    readonly includeMetadata?: boolean
}

/**
 * Request parameters for getColleagueCycles operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetColleagueCyclesRequest
 */
export interface PerformanceCycleApiGetColleagueCyclesRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetColleagueCycles
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetColleagueCycles
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof PerformanceCycleApiGetColleagueCycles
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getMetadataByColleague operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetMetadataByColleagueRequest
 */
export interface PerformanceCycleApiGetMetadataByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetMetadataByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetMetadataByColleague
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getMetadataByColleagueAndCycle operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetMetadataByColleagueAndCycleRequest
 */
export interface PerformanceCycleApiGetMetadataByColleagueAndCycleRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetMetadataByColleagueAndCycle
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetMetadataByColleagueAndCycle
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetMetadataByColleagueAndCycle
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getPmCycleMappingKeyByColleagues operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetPmCycleMappingKeyByColleaguesRequest
 */
export interface PerformanceCycleApiGetPmCycleMappingKeyByColleaguesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PerformanceCycleApiGetPmCycleMappingKeyByColleagues
     */
    readonly uuids: Array<string>
}

/**
 * Request parameters for getPmCycleMetadata operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetPmCycleMetadataRequest
 */
export interface PerformanceCycleApiGetPmCycleMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetPmCycleMetadata
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof PerformanceCycleApiGetPmCycleMetadata
     */
    readonly includeForms?: boolean
}

/**
 * Request parameters for getPmCyclesByColleague operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiGetPmCyclesByColleagueRequest
 */
export interface PerformanceCycleApiGetPmCyclesByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetPmCyclesByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiGetPmCyclesByColleague
     */
    readonly allowedStatuses: string
}

/**
 * Request parameters for publish operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiPublishRequest
 */
export interface PerformanceCycleApiPublishRequest {
    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiPublish
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for startColleagueCycle operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiStartColleagueCycleRequest
 */
export interface PerformanceCycleApiStartColleagueCycleRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiStartColleagueCycle
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiStartColleagueCycle
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PerformanceCycleApiStartColleagueCycle
     */
    readonly requestBody: { [key: string]: string; }
}

/**
 * Request parameters for startScheduled operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiStartScheduledRequest
 */
export interface PerformanceCycleApiStartScheduledRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiStartScheduled
     */
    readonly uuid: string
}

/**
 * Request parameters for update operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateRequest
 */
export interface PerformanceCycleApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdate
     */
    readonly uuid: string

    /**
     * 
     * @type {PMCycle}
     * @memberof PerformanceCycleApiUpdate
     */
    readonly pMCycle: PMCycle
}

/**
 * Request parameters for updateForm operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateFormRequest
 */
export interface PerformanceCycleApiUpdateFormRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdateForm
     */
    readonly uuid: string

    /**
     * 
     * @type {PMCycleUpdateFormRequest}
     * @memberof PerformanceCycleApiUpdateForm
     */
    readonly pMCycleUpdateFormRequest: PMCycleUpdateFormRequest
}

/**
 * Request parameters for updateFormLatestVersion operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateFormLatestVersionRequest
 */
export interface PerformanceCycleApiUpdateFormLatestVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdateFormLatestVersion
     */
    readonly uuid: string

    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdateFormLatestVersion
     */
    readonly formKey: string
}

/**
 * Request parameters for updateStatus operation in PerformanceCycleApi.
 * @export
 * @interface PerformanceCycleApiUpdateStatusRequest
 */
export interface PerformanceCycleApiUpdateStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCycleApiUpdateStatus
     */
    readonly uuid: string

    /**
     * 
     * @type {'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED'}
     * @memberof PerformanceCycleApiUpdateStatus
     */
    readonly status: 'ACTIVE' | 'INACTIVE' | 'COMPLETED' | 'DRAFT' | 'FAILED' | 'REGISTERED' | 'STARTED' | 'SUSPENDED' | 'TERMINATED' | 'SCHEDULED' | 'FINISHING' | 'FINISHED'
}

/**
 * PerformanceCycleApi - object-oriented interface
 * @export
 * @class PerformanceCycleApi
 * @extends {BaseAPI}
 */
export class PerformanceCycleApi extends BaseAPI {
    /**
     * Performance cycle created
     * @summary Create performance cycle
     * @param {PerformanceCycleApiCreate1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public create1(requestParameters: PerformanceCycleApiCreate1Request, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).create1(requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle deployed
     * @summary Deploy performance cycle
     * @param {PerformanceCycleApiDeployRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public deploy(requestParameters: PerformanceCycleApiDeployRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).deploy(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File deployed
     * @summary Deploy file resource by path and name for existing performance cycle
     * @param {PerformanceCycleApiDeployTemplateByPathAndNameForCycleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public deployTemplateByPathAndNameForCycle(requestParameters: PerformanceCycleApiDeployTemplateByPathAndNameForCycleRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).deployTemplateByPathAndNameForCycle(requestParameters.cycleUuid, requestParameters.path, requestParameters.fileName, requestParameters.mergeMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * File deployed
     * @summary Deploy file resource by uuid for existing performance cycle
     * @param {PerformanceCycleApiDeployTemplateByUuidForCycleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public deployTemplateByUuidForCycle(requestParameters: PerformanceCycleApiDeployTemplateByUuidForCycleRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).deployTemplateByUuidForCycle(requestParameters.cycleUuid, requestParameters.fileUuid, requestParameters.mergeMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle by UUID
     * @param {PerformanceCycleApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public get(requestParameters: PerformanceCycleApiGetRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).get(requestParameters.uuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all performance cycles
     * @param {PerformanceCycleApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getAll(requestParameters: PerformanceCycleApiGetAllRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getAll(requestParameters.requestQuery, requestParameters.includeMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get colleague cycles for colleague and cycle
     * @param {PerformanceCycleApiGetColleagueCyclesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getColleagueCycles(requestParameters: PerformanceCycleApiGetColleagueCyclesRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getColleagueCycles(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get full metadata for colleague
     * @param {PerformanceCycleApiGetMetadataByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getMetadataByColleague(requestParameters: PerformanceCycleApiGetMetadataByColleagueRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getMetadataByColleague(requestParameters.colleagueUuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get full metadata for colleague and cycle
     * @param {PerformanceCycleApiGetMetadataByColleagueAndCycleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getMetadataByColleagueAndCycle(requestParameters: PerformanceCycleApiGetMetadataByColleagueAndCycleRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getMetadataByColleagueAndCycle(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle mapping keys per colleagues
     * @param {PerformanceCycleApiGetPmCycleMappingKeyByColleaguesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getPmCycleMappingKeyByColleagues(requestParameters: PerformanceCycleApiGetPmCycleMappingKeyByColleaguesRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getPmCycleMappingKeyByColleagues(requestParameters.uuids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle mapping keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getPmCycleMappingKeys(options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getPmCycleMappingKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycle metadata by file UUID
     * @param {PerformanceCycleApiGetPmCycleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getPmCycleMetadata(requestParameters: PerformanceCycleApiGetPmCycleMetadataRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getPmCycleMetadata(requestParameters.uuid, requestParameters.includeForms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get performance cycles per colleague
     * @param {PerformanceCycleApiGetPmCyclesByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public getPmCyclesByColleague(requestParameters: PerformanceCycleApiGetPmCyclesByColleagueRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).getPmCyclesByColleague(requestParameters.colleagueUuid, requestParameters.allowedStatuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle published
     * @summary Publish performance cycle
     * @param {PerformanceCycleApiPublishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public publish(requestParameters: PerformanceCycleApiPublishRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).publish(requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle started
     * @summary Start performance cycle for colleague
     * @param {PerformanceCycleApiStartColleagueCycleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public startColleagueCycle(requestParameters: PerformanceCycleApiStartColleagueCycleRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).startColleagueCycle(requestParameters.cycleUuid, requestParameters.colleagueUuid, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle started
     * @summary Start performance cycle
     * @param {PerformanceCycleApiStartScheduledRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public startScheduled(requestParameters: PerformanceCycleApiStartScheduledRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).startScheduled(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performance cycle edited
     * @summary Updates an existing performance cycle
     * @param {PerformanceCycleApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public update(requestParameters: PerformanceCycleApiUpdateRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).update(requestParameters.uuid, requestParameters.pMCycle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update performance cycle form
     * @summary Update form
     * @param {PerformanceCycleApiUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public updateForm(requestParameters: PerformanceCycleApiUpdateFormRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).updateForm(requestParameters.uuid, requestParameters.pMCycleUpdateFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update form to the latest version
     * @summary Update form to the latest version
     * @param {PerformanceCycleApiUpdateFormLatestVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public updateFormLatestVersion(requestParameters: PerformanceCycleApiUpdateFormLatestVersionRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).updateFormLatestVersion(requestParameters.uuid, requestParameters.formKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update performance cycle status
     * @param {PerformanceCycleApiUpdateStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerformanceCycleApi
     */
    public updateStatus(requestParameters: PerformanceCycleApiUpdateStatusRequest, options?: AxiosRequestConfig) {
        return PerformanceCycleApiFp(this.configuration).updateStatus(requestParameters.uuid, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessesApi - axios parameter creator
 * @export
 */
export const ProcessesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., group_a1, group_a2, group_b, group_c
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (processKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processKey' is not null or undefined
            assertParamExists('getMetadata', 'processKey', processKey)
            const localVarPath = `/processes/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processKey !== undefined) {
                localVarQueryParameter['process-key'] = processKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run cycle assignment process
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCycleAssignmentProcess: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('runCycleAssignmentProcess', 'requestBody', requestBody)
            const localVarPath = `/pm-cycles/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProcessByKey: async (processKey: string, params: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processKey' is not null or undefined
            assertParamExists('runProcessByKey', 'processKey', processKey)
            // verify required parameter 'params' is not null or undefined
            assertParamExists('runProcessByKey', 'params', params)
            const localVarPath = `/processes/keys/{process-key}`
                .replace(`{${"process-key"}}`, encodeURIComponent(String(processKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessesApi - functional programming interface
 * @export
 */
export const ProcessesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., group_a1, group_a2, group_b, group_c
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(processKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMCycleMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(processKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run cycle assignment process
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runCycleAssignmentProcess(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runCycleAssignmentProcess(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runProcessByKey(processKey: string, params: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runProcessByKey(processKey, params, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessesApi - factory interface
 * @export
 */
export const ProcessesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get process metadata by process key, e.g., group_a1, group_a2, group_b, group_c
         * @param {string} processKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(processKey: string, options?: any): AxiosPromise<RestResponsePMCycleMetadata> {
            return localVarFp.getMetadata(processKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run cycle assignment process
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCycleAssignmentProcess(requestBody: Array<string>, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.runCycleAssignmentProcess(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run process metadata by process key with parameters
         * @param {string} processKey 
         * @param {object} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProcessByKey(processKey: string, params: object, options?: any): AxiosPromise<RestResponseString> {
            return localVarFp.runProcessByKey(processKey, params, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadata operation in ProcessesApi.
 * @export
 * @interface ProcessesApiGetMetadataRequest
 */
export interface ProcessesApiGetMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessesApiGetMetadata
     */
    readonly processKey: string
}

/**
 * Request parameters for runCycleAssignmentProcess operation in ProcessesApi.
 * @export
 * @interface ProcessesApiRunCycleAssignmentProcessRequest
 */
export interface ProcessesApiRunCycleAssignmentProcessRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProcessesApiRunCycleAssignmentProcess
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for runProcessByKey operation in ProcessesApi.
 * @export
 * @interface ProcessesApiRunProcessByKeyRequest
 */
export interface ProcessesApiRunProcessByKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessesApiRunProcessByKey
     */
    readonly processKey: string

    /**
     * 
     * @type {object}
     * @memberof ProcessesApiRunProcessByKey
     */
    readonly params: object
}

/**
 * ProcessesApi - object-oriented interface
 * @export
 * @class ProcessesApi
 * @extends {BaseAPI}
 */
export class ProcessesApi extends BaseAPI {
    /**
     * 
     * @summary Get process metadata by process key, e.g., group_a1, group_a2, group_b, group_c
     * @param {ProcessesApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public getMetadata(requestParameters: ProcessesApiGetMetadataRequest, options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).getMetadata(requestParameters.processKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run cycle assignment process
     * @param {ProcessesApiRunCycleAssignmentProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public runCycleAssignmentProcess(requestParameters: ProcessesApiRunCycleAssignmentProcessRequest, options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).runCycleAssignmentProcess(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run process metadata by process key with parameters
     * @param {ProcessesApiRunProcessByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public runProcessByKey(requestParameters: ProcessesApiRunProcessByKeyRequest, options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).runProcessByKey(requestParameters.processKey, requestParameters.params, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileAttributes: async (colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('createProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'ownersTypedAttributeUUID' is not null or undefined
            assertParamExists('createProfileAttributes', 'ownersTypedAttributeUUID', ownersTypedAttributeUUID)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ownersTypedAttributeUUID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileAttributes: async (colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('deleteProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'ownersTypedAttributeUUID' is not null or undefined
            assertParamExists('deleteProfileAttributes', 'ownersTypedAttributeUUID', ownersTypedAttributeUUID)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ownersTypedAttributeUUID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get assignment tenant for colleagues
         * @summary Get assignment tenant for colleagues
         * @param {Array<string>} colleagueUuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignmentTenant: async (colleagueUuids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuids' is not null or undefined
            assertParamExists('getAssignmentTenant', 'colleagueUuids', colleagueUuids)
            const localVarPath = `/colleagues/tenants/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (colleagueUuids) {
                localVarQueryParameter['colleagueUuids'] = colleagueUuids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequest: async (requestUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestUuid' is not null or undefined
            assertParamExists('getImportRequest', 'requestUuid', requestUuid)
            const localVarPath = `/colleagues/requests/{requestUuid}`
                .replace(`{${"requestUuid"}}`, encodeURIComponent(String(requestUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequestErrors: async (requestUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestUuid' is not null or undefined
            assertParamExists('getImportRequestErrors', 'requestUuid', requestUuid)
            const localVarPath = `/colleagues/requests/{requestUuid}/errors`
                .replace(`{${"requestUuid"}}`, encodeURIComponent(String(requestUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByColleagueUuid: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getProfileByColleagueUuid', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} file 
         * @param {boolean} [saveBeforeAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importColleagues: async (file: any, saveBeforeAssignment?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importColleagues', 'file', file)
            const localVarPath = `/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (saveBeforeAssignment !== undefined) {
                localVarQueryParameter['save-before-assignment'] = saveBeforeAssignment;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset tenant for colleagues
         * @summary Reset tenant for colleagues
         * @param {string} code 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTenant: async (code: string, requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('resetTenant', 'code', code)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('resetTenant', 'requestBody', requestBody)
            const localVarPath = `/colleagues/tenants/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assignment tenant for colleagues
         * @summary Assignment tenant for colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startAssignmentTenant: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('startAssignmentTenant', 'requestBody', requestBody)
            const localVarPath = `/colleagues/tenants/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update managers for colleagues without manager
         * @summary Update managers for colleagues without manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagersForColleagues: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/colleagues/managers/resolve-empty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileAttributes: async (colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateProfileAttributes', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'ownersTypedAttributeUUID' is not null or undefined
            assertParamExists('updateProfileAttributes', 'ownersTypedAttributeUUID', ownersTypedAttributeUUID)
            const localVarPath = `/colleagues/{colleagueUuid}/attributes`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ownersTypedAttributeUUID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOwnersTypedAttributeUUID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOwnersTypedAttributeUUID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get assignment tenant for colleagues
         * @summary Get assignment tenant for colleagues
         * @param {Array<string>} colleagueUuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignmentTenant(colleagueUuids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueTenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignmentTenant(colleagueUuids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportRequest(requestUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseImportRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportRequest(requestUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportRequestErrors(requestUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListImportError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportRequestErrors(requestUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileByColleagueUuid(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseColleagueProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileByColleagueUuid(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} file 
         * @param {boolean} [saveBeforeAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importColleagues(file: any, saveBeforeAssignment?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseImportReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importColleagues(file, saveBeforeAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset tenant for colleagues
         * @summary Reset tenant for colleagues
         * @param {string} code 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTenant(code: string, requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTenant(code, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assignment tenant for colleagues
         * @summary Assignment tenant for colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startAssignmentTenant(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueTenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startAssignmentTenant(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update managers for colleagues without manager
         * @summary Update managers for colleagues without manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagersForColleagues(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagersForColleagues(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListOwnersTypedAttributeUUID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Profile attributes created
         * @summary Create new profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: any): AxiosPromise<RestResponseListOwnersTypedAttributeUUID> {
            return localVarFp.createProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing profile attributes
         * @summary Delete existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: any): AxiosPromise<RestResponseListOwnersTypedAttributeUUID> {
            return localVarFp.deleteProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get assignment tenant for colleagues
         * @summary Get assignment tenant for colleagues
         * @param {Array<string>} colleagueUuids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignmentTenant(colleagueUuids: Array<string>, options?: any): AxiosPromise<RestResponseListColleagueTenant> {
            return localVarFp.getAssignmentTenant(colleagueUuids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get import request by uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequest(requestUuid: string, options?: any): AxiosPromise<RestResponseImportRequest> {
            return localVarFp.getImportRequest(requestUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get import request errors by request uuid
         * @param {string} requestUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportRequestErrors(requestUuid: string, options?: any): AxiosPromise<RestResponseListImportError> {
            return localVarFp.getImportRequestErrors(requestUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profile by colleague uuid
         * @summary Get profile by colleague uuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByColleagueUuid(colleagueUuid: string, options?: any): AxiosPromise<RestResponseColleagueProfile> {
            return localVarFp.getProfileByColleagueUuid(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start import colleagues process
         * @param {any} file 
         * @param {boolean} [saveBeforeAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importColleagues(file: any, saveBeforeAssignment?: boolean, options?: any): AxiosPromise<RestResponseImportReport> {
            return localVarFp.importColleagues(file, saveBeforeAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset tenant for colleagues
         * @summary Reset tenant for colleagues
         * @param {string} code 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTenant(code: string, requestBody: Array<string>, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.resetTenant(code, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Assignment tenant for colleagues
         * @summary Assignment tenant for colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startAssignmentTenant(requestBody: Array<string>, options?: any): AxiosPromise<RestResponseListColleagueTenant> {
            return localVarFp.startAssignmentTenant(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update managers for colleagues without manager
         * @summary Update managers for colleagues without manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagersForColleagues(options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.updateManagersForColleagues(options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing profile attributes
         * @summary Update existing profile attributes
         * @param {string} colleagueUuid 
         * @param {Array<OwnersTypedAttributeUUID>} ownersTypedAttributeUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileAttributes(colleagueUuid: string, ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>, options?: any): AxiosPromise<RestResponseListOwnersTypedAttributeUUID> {
            return localVarFp.updateProfileAttributes(colleagueUuid, ownersTypedAttributeUUID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiCreateProfileAttributesRequest
 */
export interface ProfileApiCreateProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiCreateProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof ProfileApiCreateProfileAttributes
     */
    readonly ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>
}

/**
 * Request parameters for deleteProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiDeleteProfileAttributesRequest
 */
export interface ProfileApiDeleteProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiDeleteProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof ProfileApiDeleteProfileAttributes
     */
    readonly ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>
}

/**
 * Request parameters for getAssignmentTenant operation in ProfileApi.
 * @export
 * @interface ProfileApiGetAssignmentTenantRequest
 */
export interface ProfileApiGetAssignmentTenantRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileApiGetAssignmentTenant
     */
    readonly colleagueUuids: Array<string>
}

/**
 * Request parameters for getImportRequest operation in ProfileApi.
 * @export
 * @interface ProfileApiGetImportRequestRequest
 */
export interface ProfileApiGetImportRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetImportRequest
     */
    readonly requestUuid: string
}

/**
 * Request parameters for getImportRequestErrors operation in ProfileApi.
 * @export
 * @interface ProfileApiGetImportRequestErrorsRequest
 */
export interface ProfileApiGetImportRequestErrorsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetImportRequestErrors
     */
    readonly requestUuid: string
}

/**
 * Request parameters for getProfileByColleagueUuid operation in ProfileApi.
 * @export
 * @interface ProfileApiGetProfileByColleagueUuidRequest
 */
export interface ProfileApiGetProfileByColleagueUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiGetProfileByColleagueUuid
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for importColleagues operation in ProfileApi.
 * @export
 * @interface ProfileApiImportColleaguesRequest
 */
export interface ProfileApiImportColleaguesRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfileApiImportColleagues
     */
    readonly file: any

    /**
     * 
     * @type {boolean}
     * @memberof ProfileApiImportColleagues
     */
    readonly saveBeforeAssignment?: boolean
}

/**
 * Request parameters for resetTenant operation in ProfileApi.
 * @export
 * @interface ProfileApiResetTenantRequest
 */
export interface ProfileApiResetTenantRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiResetTenant
     */
    readonly code: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileApiResetTenant
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for startAssignmentTenant operation in ProfileApi.
 * @export
 * @interface ProfileApiStartAssignmentTenantRequest
 */
export interface ProfileApiStartAssignmentTenantRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileApiStartAssignmentTenant
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for updateProfileAttributes operation in ProfileApi.
 * @export
 * @interface ProfileApiUpdateProfileAttributesRequest
 */
export interface ProfileApiUpdateProfileAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiUpdateProfileAttributes
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {Array<OwnersTypedAttributeUUID>}
     * @memberof ProfileApiUpdateProfileAttributes
     */
    readonly ownersTypedAttributeUUID: Array<OwnersTypedAttributeUUID>
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Profile attributes created
     * @summary Create new profile attributes
     * @param {ProfileApiCreateProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public createProfileAttributes(requestParameters: ProfileApiCreateProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).createProfileAttributes(requestParameters.colleagueUuid, requestParameters.ownersTypedAttributeUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing profile attributes
     * @summary Delete existing profile attributes
     * @param {ProfileApiDeleteProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public deleteProfileAttributes(requestParameters: ProfileApiDeleteProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).deleteProfileAttributes(requestParameters.colleagueUuid, requestParameters.ownersTypedAttributeUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get assignment tenant for colleagues
     * @summary Get assignment tenant for colleagues
     * @param {ProfileApiGetAssignmentTenantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getAssignmentTenant(requestParameters: ProfileApiGetAssignmentTenantRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getAssignmentTenant(requestParameters.colleagueUuids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get import request by uuid
     * @param {ProfileApiGetImportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getImportRequest(requestParameters: ProfileApiGetImportRequestRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getImportRequest(requestParameters.requestUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get import request errors by request uuid
     * @param {ProfileApiGetImportRequestErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getImportRequestErrors(requestParameters: ProfileApiGetImportRequestErrorsRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getImportRequestErrors(requestParameters.requestUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profile by colleague uuid
     * @summary Get profile by colleague uuid
     * @param {ProfileApiGetProfileByColleagueUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfileByColleagueUuid(requestParameters: ProfileApiGetProfileByColleagueUuidRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfileByColleagueUuid(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start import colleagues process
     * @param {ProfileApiImportColleaguesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public importColleagues(requestParameters: ProfileApiImportColleaguesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).importColleagues(requestParameters.file, requestParameters.saveBeforeAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset tenant for colleagues
     * @summary Reset tenant for colleagues
     * @param {ProfileApiResetTenantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public resetTenant(requestParameters: ProfileApiResetTenantRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).resetTenant(requestParameters.code, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assignment tenant for colleagues
     * @summary Assignment tenant for colleagues
     * @param {ProfileApiStartAssignmentTenantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public startAssignmentTenant(requestParameters: ProfileApiStartAssignmentTenantRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).startAssignmentTenant(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update managers for colleagues without manager
     * @summary Update managers for colleagues without manager
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateManagersForColleagues(options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateManagersForColleagues(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing profile attributes
     * @summary Update existing profile attributes
     * @param {ProfileApiUpdateProfileAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateProfileAttributes(requestParameters: ProfileApiUpdateProfileAttributesRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateProfileAttributes(requestParameters.colleagueUuid, requestParameters.ownersTypedAttributeUUID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RatingApi - axios parameter creator
 * @export
 */
export const RatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overall: async (whatRating: string, howRating: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whatRating' is not null or undefined
            assertParamExists('overall', 'whatRating', whatRating)
            // verify required parameter 'howRating' is not null or undefined
            assertParamExists('overall', 'howRating', howRating)
            const localVarPath = `/reports/overall-rating`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (whatRating !== undefined) {
                localVarQueryParameter['what_rating'] = whatRating;
            }

            if (howRating !== undefined) {
                localVarQueryParameter['how_rating'] = howRating;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingApi - functional programming interface
 * @export
 */
export const RatingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overall(whatRating: string, howRating: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapStringString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overall(whatRating, howRating, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RatingApi - factory interface
 * @export
 */
export const RatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingApiFp(configuration)
    return {
        /**
         * 
         * @summary Get overall rating
         * @param {string} whatRating 
         * @param {string} howRating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overall(whatRating: string, howRating: string, options?: any): AxiosPromise<RestResponseMapStringString> {
            return localVarFp.overall(whatRating, howRating, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for overall operation in RatingApi.
 * @export
 * @interface RatingApiOverallRequest
 */
export interface RatingApiOverallRequest {
    /**
     * 
     * @type {string}
     * @memberof RatingApiOverall
     */
    readonly whatRating: string

    /**
     * 
     * @type {string}
     * @memberof RatingApiOverall
     */
    readonly howRating: string
}

/**
 * RatingApi - object-oriented interface
 * @export
 * @class RatingApi
 * @extends {BaseAPI}
 */
export class RatingApi extends BaseAPI {
    /**
     * 
     * @summary Get overall rating
     * @param {RatingApiOverallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public overall(requestParameters: RatingApiOverallRequest, options?: AxiosRequestConfig) {
        return RatingApiFp(this.configuration).overall(requestParameters.whatRating, requestParameters.howRating, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecoveryApi - axios parameter creator
 * @export
 */
export const RecoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update existing colleagues
         * @summary Update existing colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExistingColleague: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateExistingColleague', 'requestBody', requestBody)
            const localVarPath = `/recovery/colleagues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecoveryApi - functional programming interface
 * @export
 */
export const RecoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Update existing colleagues
         * @summary Update existing colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExistingColleague(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseMapUUIDBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExistingColleague(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecoveryApi - factory interface
 * @export
 */
export const RecoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecoveryApiFp(configuration)
    return {
        /**
         * Update existing colleagues
         * @summary Update existing colleagues
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExistingColleague(requestBody: Array<string>, options?: any): AxiosPromise<RestResponseMapUUIDBoolean> {
            return localVarFp.updateExistingColleague(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateExistingColleague operation in RecoveryApi.
 * @export
 * @interface RecoveryApiUpdateExistingColleagueRequest
 */
export interface RecoveryApiUpdateExistingColleagueRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RecoveryApiUpdateExistingColleague
     */
    readonly requestBody: Array<string>
}

/**
 * RecoveryApi - object-oriented interface
 * @export
 * @class RecoveryApi
 * @extends {BaseAPI}
 */
export class RecoveryApi extends BaseAPI {
    /**
     * Update existing colleagues
     * @summary Update existing colleagues
     * @param {RecoveryApiUpdateExistingColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryApi
     */
    public updateExistingColleague(requestParameters: RecoveryApiUpdateExistingColleagueRequest, options?: AxiosRequestConfig) {
        return RecoveryApiFp(this.configuration).updateExistingColleague(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Anniversary Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnniversaryReviewsDetailsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAnniversaryReviewsDetailsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-anniversary-reviews/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Anniversary Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnniversaryReviewsStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getAnniversaryReviewsStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-anniversary-reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get calibration overview report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationOverviewReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getCalibrationOverviewReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/calibration-overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get calibration session report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationSessionReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getCalibrationSessionReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/calibration-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Feedback Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackDetailsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getFeedbackDetailsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-feedbacks/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getFeedbackStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Leadership Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadershipReviewsDetailsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getLeadershipReviewsDetailsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-leadership-reviews/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Leadership Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadershipReviewsStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getLeadershipReviewsStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-leadership-reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportFile: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getLinkedObjectivesReportFile', 'requestQuery', requestQuery)
            const localVarPath = `/reports/linked-objective-report/formats/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Reviews Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMYRReviewsReportFile: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getMYRReviewsReportFile', 'requestQuery', requestQuery)
            const localVarPath = `/reports/mid-year-review-rating-report/formats/csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewToBusinessDeatilsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getNewToBusinessDeatilsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-new-to-business/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewToBusinessStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getNewToBusinessStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-new-to-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Objectives Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectivesReportFile: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getObjectivesReportFile', 'requestQuery', requestQuery)
            const localVarPath = `/reports/objectives-report/formats/csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsOverallRatingDetailsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviewsOverallRatingDetailsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-overall-ratings/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsOverallRatingStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviewsOverallRatingStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-overall-ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Review details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsStatisticsDetailsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviewsStatisticsDetailsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-reviews/colleague`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsStatisticsReport: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviewsStatisticsReport', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Statistics Report as Resource
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticsReportFile: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getStatisticsReportFile', 'requestQuery', requestQuery)
            const localVarPath = `/reports/statistics-report/formats/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalColleagueCount: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getTotalColleagueCount', 'requestQuery', requestQuery)
            const localVarPath = `/reports/colleagues/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Anniversary Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnniversaryReviewsDetailsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnniversaryReviewsDetailsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Anniversary Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnniversaryReviewsStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnniversaryReviewsStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get calibration overview report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalibrationOverviewReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalibrationOverviewReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get calibration session report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalibrationSessionReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalibrationSessionReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Feedback Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackDetailsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbackDetailsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbackStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Leadership Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeadershipReviewsDetailsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadershipReviewsDetailsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Leadership Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeadershipReviewsStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadershipReviewsStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedObjectivesReportFile(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedObjectivesReportFile(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Reviews Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMYRReviewsReportFile(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMYRReviewsReportFile(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewToBusinessDeatilsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewToBusinessDeatilsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewToBusinessStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewToBusinessStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Objectives Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectivesReportFile(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectivesReportFile(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsOverallRatingDetailsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsOverallRatingDetailsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsOverallRatingStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsOverallRatingStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Review details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsStatisticsDetailsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueReportTargeting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsStatisticsDetailsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsStatisticsReport(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReportStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsStatisticsReport(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Statistics Report as Resource
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticsReportFile(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticsReportFile(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalColleagueCount(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseInteger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalColleagueCount(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Anniversary Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnniversaryReviewsDetailsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getAnniversaryReviewsDetailsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Anniversary Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnniversaryReviewsStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getAnniversaryReviewsStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get calibration overview report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationOverviewReport(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getCalibrationOverviewReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get calibration session report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalibrationSessionReport(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getCalibrationSessionReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Feedback Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackDetailsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getFeedbackDetailsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getFeedbackStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Leadership Review Details Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadershipReviewsDetailsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getLeadershipReviewsDetailsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Leadership Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadershipReviewsStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getLeadershipReviewsStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Linked Objectives Report by year of cycle and statuses of review
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedObjectivesReportFile(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getLinkedObjectivesReportFile(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Reviews Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMYRReviewsReportFile(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getMYRReviewsReportFile(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewToBusinessDeatilsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getNewToBusinessDeatilsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get New To Business Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewToBusinessStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getNewToBusinessStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Objectives Report
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectivesReportFile(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getObjectivesReportFile(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsOverallRatingDetailsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getReviewsOverallRatingDetailsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Overall Rating Breakdown Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsOverallRatingStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getReviewsOverallRatingStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Review details Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsStatisticsDetailsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueReportTargeting> {
            return localVarFp.getReviewsStatisticsDetailsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Review Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsStatisticsReport(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListReportStatistics> {
            return localVarFp.getReviewsStatisticsReport(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Statistics Report as Resource
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticsReportFile(requestQuery: RequestQuery, options?: any): AxiosPromise<any> {
            return localVarFp.getStatisticsReportFile(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Feedback Statistics Report Data with filters
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalColleagueCount(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseInteger> {
            return localVarFp.getTotalColleagueCount(requestQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAnniversaryReviewsDetailsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetAnniversaryReviewsDetailsReportRequest
 */
export interface ReportApiGetAnniversaryReviewsDetailsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetAnniversaryReviewsDetailsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getAnniversaryReviewsStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetAnniversaryReviewsStatisticsReportRequest
 */
export interface ReportApiGetAnniversaryReviewsStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetAnniversaryReviewsStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getCalibrationOverviewReport operation in ReportApi.
 * @export
 * @interface ReportApiGetCalibrationOverviewReportRequest
 */
export interface ReportApiGetCalibrationOverviewReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetCalibrationOverviewReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getCalibrationSessionReport operation in ReportApi.
 * @export
 * @interface ReportApiGetCalibrationSessionReportRequest
 */
export interface ReportApiGetCalibrationSessionReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetCalibrationSessionReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getFeedbackDetailsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetFeedbackDetailsReportRequest
 */
export interface ReportApiGetFeedbackDetailsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetFeedbackDetailsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getFeedbackStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetFeedbackStatisticsReportRequest
 */
export interface ReportApiGetFeedbackStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetFeedbackStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getLeadershipReviewsDetailsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetLeadershipReviewsDetailsReportRequest
 */
export interface ReportApiGetLeadershipReviewsDetailsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetLeadershipReviewsDetailsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getLeadershipReviewsStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetLeadershipReviewsStatisticsReportRequest
 */
export interface ReportApiGetLeadershipReviewsStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetLeadershipReviewsStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getLinkedObjectivesReportFile operation in ReportApi.
 * @export
 * @interface ReportApiGetLinkedObjectivesReportFileRequest
 */
export interface ReportApiGetLinkedObjectivesReportFileRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetLinkedObjectivesReportFile
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getMYRReviewsReportFile operation in ReportApi.
 * @export
 * @interface ReportApiGetMYRReviewsReportFileRequest
 */
export interface ReportApiGetMYRReviewsReportFileRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetMYRReviewsReportFile
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getNewToBusinessDeatilsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetNewToBusinessDeatilsReportRequest
 */
export interface ReportApiGetNewToBusinessDeatilsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetNewToBusinessDeatilsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getNewToBusinessStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetNewToBusinessStatisticsReportRequest
 */
export interface ReportApiGetNewToBusinessStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetNewToBusinessStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getObjectivesReportFile operation in ReportApi.
 * @export
 * @interface ReportApiGetObjectivesReportFileRequest
 */
export interface ReportApiGetObjectivesReportFileRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetObjectivesReportFile
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReviewsOverallRatingDetailsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetReviewsOverallRatingDetailsReportRequest
 */
export interface ReportApiGetReviewsOverallRatingDetailsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetReviewsOverallRatingDetailsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReviewsOverallRatingStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetReviewsOverallRatingStatisticsReportRequest
 */
export interface ReportApiGetReviewsOverallRatingStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetReviewsOverallRatingStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReviewsStatisticsDetailsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetReviewsStatisticsDetailsReportRequest
 */
export interface ReportApiGetReviewsStatisticsDetailsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetReviewsStatisticsDetailsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReviewsStatisticsReport operation in ReportApi.
 * @export
 * @interface ReportApiGetReviewsStatisticsReportRequest
 */
export interface ReportApiGetReviewsStatisticsReportRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetReviewsStatisticsReport
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getStatisticsReportFile operation in ReportApi.
 * @export
 * @interface ReportApiGetStatisticsReportFileRequest
 */
export interface ReportApiGetStatisticsReportFileRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetStatisticsReportFile
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getTotalColleagueCount operation in ReportApi.
 * @export
 * @interface ReportApiGetTotalColleagueCountRequest
 */
export interface ReportApiGetTotalColleagueCountRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof ReportApiGetTotalColleagueCount
     */
    readonly requestQuery: RequestQuery
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * 
     * @summary Get Anniversary Review Details Statistics Report Data with filters
     * @param {ReportApiGetAnniversaryReviewsDetailsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getAnniversaryReviewsDetailsReport(requestParameters: ReportApiGetAnniversaryReviewsDetailsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getAnniversaryReviewsDetailsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Anniversary Review Statistics Report Data with filters
     * @param {ReportApiGetAnniversaryReviewsStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getAnniversaryReviewsStatisticsReport(requestParameters: ReportApiGetAnniversaryReviewsStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getAnniversaryReviewsStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get calibration overview report
     * @param {ReportApiGetCalibrationOverviewReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getCalibrationOverviewReport(requestParameters: ReportApiGetCalibrationOverviewReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getCalibrationOverviewReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get calibration session report
     * @param {ReportApiGetCalibrationSessionReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getCalibrationSessionReport(requestParameters: ReportApiGetCalibrationSessionReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getCalibrationSessionReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Feedback Details Statistics Report Data with filters
     * @param {ReportApiGetFeedbackDetailsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getFeedbackDetailsReport(requestParameters: ReportApiGetFeedbackDetailsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getFeedbackDetailsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Feedback Statistics Report Data with filters
     * @param {ReportApiGetFeedbackStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getFeedbackStatisticsReport(requestParameters: ReportApiGetFeedbackStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getFeedbackStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Leadership Review Details Statistics Report Data with filters
     * @param {ReportApiGetLeadershipReviewsDetailsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getLeadershipReviewsDetailsReport(requestParameters: ReportApiGetLeadershipReviewsDetailsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getLeadershipReviewsDetailsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Leadership Review Statistics Report Data with filters
     * @param {ReportApiGetLeadershipReviewsStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getLeadershipReviewsStatisticsReport(requestParameters: ReportApiGetLeadershipReviewsStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getLeadershipReviewsStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Linked Objectives Report by year of cycle and statuses of review
     * @param {ReportApiGetLinkedObjectivesReportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getLinkedObjectivesReportFile(requestParameters: ReportApiGetLinkedObjectivesReportFileRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getLinkedObjectivesReportFile(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Reviews Report
     * @param {ReportApiGetMYRReviewsReportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getMYRReviewsReportFile(requestParameters: ReportApiGetMYRReviewsReportFileRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getMYRReviewsReportFile(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get New To Business Report Data with filters
     * @param {ReportApiGetNewToBusinessDeatilsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getNewToBusinessDeatilsReport(requestParameters: ReportApiGetNewToBusinessDeatilsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getNewToBusinessDeatilsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get New To Business Report Data with filters
     * @param {ReportApiGetNewToBusinessStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getNewToBusinessStatisticsReport(requestParameters: ReportApiGetNewToBusinessStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getNewToBusinessStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Objectives Report
     * @param {ReportApiGetObjectivesReportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getObjectivesReportFile(requestParameters: ReportApiGetObjectivesReportFileRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getObjectivesReportFile(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Overall Rating Breakdown Details Report Data with filters
     * @param {ReportApiGetReviewsOverallRatingDetailsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReviewsOverallRatingDetailsReport(requestParameters: ReportApiGetReviewsOverallRatingDetailsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReviewsOverallRatingDetailsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Overall Rating Breakdown Statistics Report Data with filters
     * @param {ReportApiGetReviewsOverallRatingStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReviewsOverallRatingStatisticsReport(requestParameters: ReportApiGetReviewsOverallRatingStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReviewsOverallRatingStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Review details Report Data with filters
     * @param {ReportApiGetReviewsStatisticsDetailsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReviewsStatisticsDetailsReport(requestParameters: ReportApiGetReviewsStatisticsDetailsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReviewsStatisticsDetailsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Review Statistics Report Data with filters
     * @param {ReportApiGetReviewsStatisticsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReviewsStatisticsReport(requestParameters: ReportApiGetReviewsStatisticsReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReviewsStatisticsReport(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Statistics Report as Resource
     * @param {ReportApiGetStatisticsReportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getStatisticsReportFile(requestParameters: ReportApiGetStatisticsReportFileRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getStatisticsReportFile(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Feedback Statistics Report Data with filters
     * @param {ReportApiGetTotalColleagueCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getTotalColleagueCount(requestParameters: ReportApiGetTotalColleagueCountRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getTotalColleagueCount(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewApi - axios parameter creator
 * @export
 */
export const ReviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {any} review 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview: async (colleagueUuid: string, cycleUuid: string, code: string, number: number, review: any, uploadMetadata?: any, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('createReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('createReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('createReview', 'code', code)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('createReview', 'number', number)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('createReview', 'review', review)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/numbers/{number}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (review !== undefined) { 
                localVarFormParams.append('review', review as any);
            }
    
            if (uploadMetadata !== undefined) { 
                localVarFormParams.append('uploadMetadata', uploadMetadata as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewNote: async (reviewUuid: string, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewUuid' is not null or undefined
            assertParamExists('createReviewNote', 'reviewUuid', reviewUuid)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('createReviewNote', 'note', note)
            const localVarPath = `/reviews/{reviewUuid}/notes`
                .replace(`{${"reviewUuid"}}`, encodeURIComponent(String(reviewUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('delete1', 'fileUuid', fileUuid)
            const localVarPath = `/reviews/files/{fileUuid}`
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview: async (colleagueUuid: string, cycleUuid: string, code: string, number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('deleteReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('deleteReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteReview', 'code', code)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('deleteReview', 'number', number)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/numbers/{number}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a note for review
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewNote: async (noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteReviewNote', 'noteId', noteId)
            const localVarPath = `/reviews/notes/{noteId}`
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} colleagueUuid 
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1: async (colleagueUuid: string, fileUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('download1', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'fileUuid' is not null or undefined
            assertParamExists('download1', 'fileUuid', fileUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/reviews/files/{fileUuid}/download`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"fileUuid"}}`, encodeURIComponent(String(fileUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find Notes by Review
         * @param {string} reviewUuid 
         * @param {string} ownerUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNotesByReview: async (reviewUuid: string, ownerUUID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewUuid' is not null or undefined
            assertParamExists('findNotesByReview', 'reviewUuid', reviewUuid)
            // verify required parameter 'ownerUUID' is not null or undefined
            assertParamExists('findNotesByReview', 'ownerUUID', ownerUUID)
            const localVarPath = `/reviews/{reviewUuid}/notes`
                .replace(`{${"reviewUuid"}}`, encodeURIComponent(String(reviewUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ownerUUID !== undefined) {
                localVarQueryParameter['ownerUUID'] = ownerUUID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullTeamView: async (managerUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerUuid' is not null or undefined
            assertParamExists('getFullTeamView', 'managerUuid', managerUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getFullTeamView', 'requestQuery', requestQuery)
            const localVarPath = `/managers/{managerUuid}/reviews/full-team`
                .replace(`{${"managerUuid"}}`, encodeURIComponent(String(managerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview: async (colleagueUuid: string, cycleUuid: string, code: string, number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getReview', 'code', code)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getReview', 'number', number)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/numbers/{number}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getReviewByUuid', 'uuid', uuid)
            const localVarPath = `/reviews/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews: async (colleagueUuid: string, cycleUuid: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getReviews', 'code', code)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByColleague: async (colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, includeFiles?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviewsByColleague', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getReviewsByColleague', 'cycleUuid', cycleUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getReviewsByColleague', 'requestQuery', requestQuery)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFiles !== undefined) {
                localVarQueryParameter['includeFiles'] = includeFiles;
            }

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleague: async (colleagueUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviewsFilesByColleague', 'colleagueUuid', colleagueUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/reviews/files`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid and reviewUuid
         * @param {string} colleagueUuid 
         * @param {string} reviewUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleagueAndReview: async (colleagueUuid: string, reviewUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getReviewsFilesByColleagueAndReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'reviewUuid' is not null or undefined
            assertParamExists('getReviewsFilesByColleagueAndReview', 'reviewUuid', reviewUuid)
            const localVarPath = `/colleagues/{colleagueUuid}/reviews/{reviewUuid}/files`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"reviewUuid"}}`, encodeURIComponent(String(reviewUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamView: async (managerUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerUuid' is not null or undefined
            assertParamExists('getTeamView', 'managerUuid', managerUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getTeamView', 'requestQuery', requestQuery)
            const localVarPath = `/managers/{managerUuid}/reviews`
                .replace(`{${"managerUuid"}}`, encodeURIComponent(String(managerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineByColleague: async (colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getTimelineByColleague', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('getTimelineByColleague', 'cycleUuid', cycleUuid)
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('getTimelineByColleague', 'requestQuery', requestQuery)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/timeline`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview: async (colleagueUuid: string, cycleUuid: string, code: string, number: number, review: Review, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReview', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReview', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateReview', 'code', code)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('updateReview', 'number', number)
            // verify required parameter 'review' is not null or undefined
            assertParamExists('updateReview', 'review', review)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/numbers/{number}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(review, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewNote: async (reviewUuid: string, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewUuid' is not null or undefined
            assertParamExists('updateReviewNote', 'reviewUuid', reviewUuid)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('updateReviewNote', 'note', note)
            const localVarPath = `/reviews/{reviewUuid}/notes`
                .replace(`{${"reviewUuid"}}`, encodeURIComponent(String(reviewUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {any} reviews 
         * @param {Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>} [modes] 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviews: async (colleagueUuid: string, cycleUuid: string, code: string, reviews: any, modes?: Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>, uploadMetadata?: any, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateReviews', 'code', code)
            // verify required parameter 'reviews' is not null or undefined
            assertParamExists('updateReviews', 'reviews', reviews)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (modes) {
                localVarQueryParameter['modes'] = Array.from(modes);
            }


            if (reviews !== undefined) { 
                localVarFormParams.append('reviews', reviews as any);
            }
    
            if (uploadMetadata !== undefined) { 
                localVarFormParams.append('uploadMetadata', uploadMetadata as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus: async (colleagueUuid: string, cycleUuid: string, code: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('updateReviewsStatus', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('updateReviewsStatus', 'cycleUuid', cycleUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateReviewsStatus', 'code', code)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateReviewsStatus', 'status', status)
            // verify required parameter 'updateReviewsStatusRequest' is not null or undefined
            assertParamExists('updateReviewsStatus', 'updateReviewsStatusRequest', updateReviewsStatusRequest)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/statuses/{status}/reviews`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReviewsStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewApi - functional programming interface
 * @export
 */
export const ReviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewApiAxiosParamCreator(configuration)
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {any} review 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, review: any, uploadMetadata?: any, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(colleagueUuid, cycleUuid, code, number, review, uploadMetadata, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReviewNote(reviewUuid: string, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReviewNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReviewNote(reviewUuid, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(colleagueUuid, cycleUuid, code, number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a note for review
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewNote(noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReviewNote(noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} colleagueUuid 
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download1(colleagueUuid: string, fileUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download1(colleagueUuid, fileUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find Notes by Review
         * @param {string} reviewUuid 
         * @param {string} ownerUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNotesByReview(reviewUuid: string, ownerUUID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReviewNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNotesByReview(reviewUuid, ownerUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullTeamView(managerUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullTeamView(managerUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReview(colleagueUuid, cycleUuid, code, number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewByUuid(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewByUuid(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviews(colleagueUuid: string, cycleUuid: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews(colleagueUuid, cycleUuid, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsByColleague(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, includeFiles?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsByColleague(colleagueUuid, cycleUuid, requestQuery, includeFiles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsFilesByColleague(colleagueUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsFilesByColleague(colleagueUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid and reviewUuid
         * @param {string} colleagueUuid 
         * @param {string} reviewUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsFilesByColleagueAndReview(colleagueUuid: string, reviewUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsFilesByColleagueAndReview(colleagueUuid, reviewUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamView(managerUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListColleagueView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamView(managerUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelineByColleague(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTimelinePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelineByColleague(colleagueUuid, cycleUuid, requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, review: Review, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(colleagueUuid, cycleUuid, code, number, review, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviewNote(reviewUuid: string, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseReviewNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviewNote(reviewUuid, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {any} reviews 
         * @param {Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>} [modes] 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviews(colleagueUuid: string, cycleUuid: string, code: string, reviews: any, modes?: Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>, uploadMetadata?: any, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviews(colleagueUuid, cycleUuid, code, reviews, modes, uploadMetadata, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReviewsStatus(colleagueUuid: string, cycleUuid: string, code: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponsePMReviewStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReviewsStatus(colleagueUuid, cycleUuid, code, status, updateReviewsStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewApi - factory interface
 * @export
 */
export const ReviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewApiFp(configuration)
    return {
        /**
         * Review created
         * @summary Create a review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {any} review 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, review: any, uploadMetadata?: any, files?: Array<any>, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.createReview(colleagueUuid, cycleUuid, code, number, review, uploadMetadata, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewNote(reviewUuid: string, note: Note, options?: any): AxiosPromise<RestResponseReviewNote> {
            return localVarFp.createReviewNote(reviewUuid, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Review File by its uuid
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(fileUuid: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.delete1(fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing review
         * @summary Delete existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteReview(colleagueUuid, cycleUuid, code, number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a note for review
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewNote(noteId: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.deleteReviewNote(noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download Review File
         * @summary Download Review File
         * @param {string} colleagueUuid 
         * @param {string} fileUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1(colleagueUuid: string, fileUuid: string, options?: any): AxiosPromise<any> {
            return localVarFp.download1(colleagueUuid, fileUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find Notes by Review
         * @param {string} reviewUuid 
         * @param {string} ownerUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNotesByReview(reviewUuid: string, ownerUUID: string, options?: any): AxiosPromise<RestResponseListReviewNote> {
            return localVarFp.findNotesByReview(reviewUuid, ownerUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of full team reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullTeamView(managerUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueView> {
            return localVarFp.getFullTeamView(managerUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReview(colleagueUuid, cycleUuid, code, number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a review by its identifier
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewByUuid(uuid: string, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.getReviewByUuid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews(colleagueUuid: string, cycleUuid: string, code: string, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getReviews(colleagueUuid, cycleUuid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by its cycleUuid, colleagueUuid
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {boolean} [includeFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByColleague(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, includeFiles?: boolean, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getReviewsByColleague(colleagueUuid, cycleUuid, requestQuery, includeFiles, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid
         * @param {string} colleagueUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleague(colleagueUuid: string, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.getReviewsFilesByColleague(colleagueUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reviews by colleagueUuid and reviewUuid
         * @param {string} colleagueUuid 
         * @param {string} reviewUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsFilesByColleagueAndReview(colleagueUuid: string, reviewUuid: string, options?: any): AxiosPromise<RestResponseListFile> {
            return localVarFp.getReviewsFilesByColleagueAndReview(colleagueUuid, reviewUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of colleagues reviews by managerUuid
         * @param {string} managerUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamView(managerUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListColleagueView> {
            return localVarFp.getTeamView(managerUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cycle timeline for colleague
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelineByColleague(colleagueUuid: string, cycleUuid: string, requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListTimelinePoint> {
            return localVarFp.getTimelineByColleague(colleagueUuid, cycleUuid, requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing review
         * @summary Update existing review
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {number} number 
         * @param {Review} review 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview(colleagueUuid: string, cycleUuid: string, code: string, number: number, review: Review, options?: any): AxiosPromise<RestResponseReview> {
            return localVarFp.updateReview(colleagueUuid, cycleUuid, code, number, review, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a note for review
         * @param {string} reviewUuid 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewNote(reviewUuid: string, note: Note, options?: any): AxiosPromise<RestResponseReviewNote> {
            return localVarFp.updateReviewNote(reviewUuid, note, options).then((request) => request(axios, basePath));
        },
        /**
         * Update list of reviews
         * @summary Update list of reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {any} reviews 
         * @param {Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>} [modes] 
         * @param {any} [uploadMetadata] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviews(colleagueUuid: string, cycleUuid: string, code: string, reviews: any, modes?: Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>, uploadMetadata?: any, files?: Array<any>, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.updateReviews(colleagueUuid, cycleUuid, code, reviews, modes, uploadMetadata, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Update status of existing reviews
         * @summary Update status of existing reviews
         * @param {string} colleagueUuid 
         * @param {string} cycleUuid 
         * @param {string} code 
         * @param {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'} status 
         * @param {UpdateReviewsStatusRequest} updateReviewsStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReviewsStatus(colleagueUuid: string, cycleUuid: string, code: string, status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED', updateReviewsStatusRequest: UpdateReviewsStatusRequest, options?: any): AxiosPromise<RestResponsePMReviewStatus> {
            return localVarFp.updateReviewsStatus(colleagueUuid, cycleUuid, code, status, updateReviewsStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReview operation in ReviewApi.
 * @export
 * @interface ReviewApiCreateReviewRequest
 */
export interface ReviewApiCreateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReview
     */
    readonly code: string

    /**
     * 
     * @type {number}
     * @memberof ReviewApiCreateReview
     */
    readonly number: number

    /**
     * 
     * @type {any}
     * @memberof ReviewApiCreateReview
     */
    readonly review: any

    /**
     * 
     * @type {any}
     * @memberof ReviewApiCreateReview
     */
    readonly uploadMetadata?: any

    /**
     * 
     * @type {Array<any>}
     * @memberof ReviewApiCreateReview
     */
    readonly files?: Array<any>
}

/**
 * Request parameters for createReviewNote operation in ReviewApi.
 * @export
 * @interface ReviewApiCreateReviewNoteRequest
 */
export interface ReviewApiCreateReviewNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiCreateReviewNote
     */
    readonly reviewUuid: string

    /**
     * 
     * @type {Note}
     * @memberof ReviewApiCreateReviewNote
     */
    readonly note: Note
}

/**
 * Request parameters for delete1 operation in ReviewApi.
 * @export
 * @interface ReviewApiDelete1Request
 */
export interface ReviewApiDelete1Request {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDelete1
     */
    readonly fileUuid: string
}

/**
 * Request parameters for deleteReview operation in ReviewApi.
 * @export
 * @interface ReviewApiDeleteReviewRequest
 */
export interface ReviewApiDeleteReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReview
     */
    readonly code: string

    /**
     * 
     * @type {number}
     * @memberof ReviewApiDeleteReview
     */
    readonly number: number
}

/**
 * Request parameters for deleteReviewNote operation in ReviewApi.
 * @export
 * @interface ReviewApiDeleteReviewNoteRequest
 */
export interface ReviewApiDeleteReviewNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDeleteReviewNote
     */
    readonly noteId: string
}

/**
 * Request parameters for download1 operation in ReviewApi.
 * @export
 * @interface ReviewApiDownload1Request
 */
export interface ReviewApiDownload1Request {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiDownload1
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiDownload1
     */
    readonly fileUuid: string
}

/**
 * Request parameters for findNotesByReview operation in ReviewApi.
 * @export
 * @interface ReviewApiFindNotesByReviewRequest
 */
export interface ReviewApiFindNotesByReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiFindNotesByReview
     */
    readonly reviewUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiFindNotesByReview
     */
    readonly ownerUUID: string
}

/**
 * Request parameters for getFullTeamView operation in ReviewApi.
 * @export
 * @interface ReviewApiGetFullTeamViewRequest
 */
export interface ReviewApiGetFullTeamViewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetFullTeamView
     */
    readonly managerUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof ReviewApiGetFullTeamView
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getReview operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewRequest
 */
export interface ReviewApiGetReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReview
     */
    readonly code: string

    /**
     * 
     * @type {number}
     * @memberof ReviewApiGetReview
     */
    readonly number: number
}

/**
 * Request parameters for getReviewByUuid operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewByUuidRequest
 */
export interface ReviewApiGetReviewByUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewByUuid
     */
    readonly uuid: string
}

/**
 * Request parameters for getReviews operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsRequest
 */
export interface ReviewApiGetReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviews
     */
    readonly code: string
}

/**
 * Request parameters for getReviewsByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsByColleagueRequest
 */
export interface ReviewApiGetReviewsByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly requestQuery: RequestQuery

    /**
     * 
     * @type {boolean}
     * @memberof ReviewApiGetReviewsByColleague
     */
    readonly includeFiles?: boolean
}

/**
 * Request parameters for getReviewsFilesByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsFilesByColleagueRequest
 */
export interface ReviewApiGetReviewsFilesByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsFilesByColleague
     */
    readonly colleagueUuid: string
}

/**
 * Request parameters for getReviewsFilesByColleagueAndReview operation in ReviewApi.
 * @export
 * @interface ReviewApiGetReviewsFilesByColleagueAndReviewRequest
 */
export interface ReviewApiGetReviewsFilesByColleagueAndReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsFilesByColleagueAndReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetReviewsFilesByColleagueAndReview
     */
    readonly reviewUuid: string
}

/**
 * Request parameters for getTeamView operation in ReviewApi.
 * @export
 * @interface ReviewApiGetTeamViewRequest
 */
export interface ReviewApiGetTeamViewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetTeamView
     */
    readonly managerUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof ReviewApiGetTeamView
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for getTimelineByColleague operation in ReviewApi.
 * @export
 * @interface ReviewApiGetTimelineByColleagueRequest
 */
export interface ReviewApiGetTimelineByColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetTimelineByColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiGetTimelineByColleague
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {RequestQuery}
     * @memberof ReviewApiGetTimelineByColleague
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for updateReview operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewRequest
 */
export interface ReviewApiUpdateReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReview
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReview
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReview
     */
    readonly code: string

    /**
     * 
     * @type {number}
     * @memberof ReviewApiUpdateReview
     */
    readonly number: number

    /**
     * 
     * @type {Review}
     * @memberof ReviewApiUpdateReview
     */
    readonly review: Review
}

/**
 * Request parameters for updateReviewNote operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewNoteRequest
 */
export interface ReviewApiUpdateReviewNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewNote
     */
    readonly reviewUuid: string

    /**
     * 
     * @type {Note}
     * @memberof ReviewApiUpdateReviewNote
     */
    readonly note: Note
}

/**
 * Request parameters for updateReviews operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewsRequest
 */
export interface ReviewApiUpdateReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviews
     */
    readonly code: string

    /**
     * 
     * @type {any}
     * @memberof ReviewApiUpdateReviews
     */
    readonly reviews: any

    /**
     * 
     * @type {Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>}
     * @memberof ReviewApiUpdateReviews
     */
    readonly modes?: Set<'CREATE' | 'UPDATE' | 'DELETE' | 'MERGE'>

    /**
     * 
     * @type {any}
     * @memberof ReviewApiUpdateReviews
     */
    readonly uploadMetadata?: any

    /**
     * 
     * @type {Array<any>}
     * @memberof ReviewApiUpdateReviews
     */
    readonly files?: Array<any>
}

/**
 * Request parameters for updateReviewsStatus operation in ReviewApi.
 * @export
 * @interface ReviewApiUpdateReviewsStatusRequest
 */
export interface ReviewApiUpdateReviewsStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly code: string

    /**
     * 
     * @type {'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly status: 'DRAFT' | 'WAITING_FOR_APPROVAL' | 'APPROVED' | 'DECLINED' | 'WAITING_FOR_COMPLETION' | 'REQUESTED_TO_AMEND' | 'COMPLETED'

    /**
     * 
     * @type {UpdateReviewsStatusRequest}
     * @memberof ReviewApiUpdateReviewsStatus
     */
    readonly updateReviewsStatusRequest: UpdateReviewsStatusRequest
}

/**
 * ReviewApi - object-oriented interface
 * @export
 * @class ReviewApi
 * @extends {BaseAPI}
 */
export class ReviewApi extends BaseAPI {
    /**
     * Review created
     * @summary Create a review
     * @param {ReviewApiCreateReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public createReview(requestParameters: ReviewApiCreateReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).createReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.number, requestParameters.review, requestParameters.uploadMetadata, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a note for review
     * @param {ReviewApiCreateReviewNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public createReviewNote(requestParameters: ReviewApiCreateReviewNoteRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).createReviewNote(requestParameters.reviewUuid, requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Review File by its uuid
     * @param {ReviewApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public delete1(requestParameters: ReviewApiDelete1Request, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).delete1(requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing review
     * @summary Delete existing review
     * @param {ReviewApiDeleteReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public deleteReview(requestParameters: ReviewApiDeleteReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).deleteReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a note for review
     * @param {ReviewApiDeleteReviewNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public deleteReviewNote(requestParameters: ReviewApiDeleteReviewNoteRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).deleteReviewNote(requestParameters.noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download Review File
     * @summary Download Review File
     * @param {ReviewApiDownload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public download1(requestParameters: ReviewApiDownload1Request, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).download1(requestParameters.colleagueUuid, requestParameters.fileUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find Notes by Review
     * @param {ReviewApiFindNotesByReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public findNotesByReview(requestParameters: ReviewApiFindNotesByReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).findNotesByReview(requestParameters.reviewUuid, requestParameters.ownerUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of full team reviews by managerUuid
     * @param {ReviewApiGetFullTeamViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getFullTeamView(requestParameters: ReviewApiGetFullTeamViewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getFullTeamView(requestParameters.managerUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a review by its cycleUuid, colleagueUuid, review type and number
     * @param {ReviewApiGetReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReview(requestParameters: ReviewApiGetReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a review by its identifier
     * @param {ReviewApiGetReviewByUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewByUuid(requestParameters: ReviewApiGetReviewByUuidRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewByUuid(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by its cycleUuid, colleagueUuid, review type
     * @param {ReviewApiGetReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviews(requestParameters: ReviewApiGetReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviews(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by its cycleUuid, colleagueUuid
     * @param {ReviewApiGetReviewsByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewsByColleague(requestParameters: ReviewApiGetReviewsByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewsByColleague(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.requestQuery, requestParameters.includeFiles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by colleagueUuid
     * @param {ReviewApiGetReviewsFilesByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewsFilesByColleague(requestParameters: ReviewApiGetReviewsFilesByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewsFilesByColleague(requestParameters.colleagueUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reviews by colleagueUuid and reviewUuid
     * @param {ReviewApiGetReviewsFilesByColleagueAndReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getReviewsFilesByColleagueAndReview(requestParameters: ReviewApiGetReviewsFilesByColleagueAndReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getReviewsFilesByColleagueAndReview(requestParameters.colleagueUuid, requestParameters.reviewUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of colleagues reviews by managerUuid
     * @param {ReviewApiGetTeamViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getTeamView(requestParameters: ReviewApiGetTeamViewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getTeamView(requestParameters.managerUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cycle timeline for colleague
     * @param {ReviewApiGetTimelineByColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public getTimelineByColleague(requestParameters: ReviewApiGetTimelineByColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).getTimelineByColleague(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing review
     * @summary Update existing review
     * @param {ReviewApiUpdateReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReview(requestParameters: ReviewApiUpdateReviewRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReview(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.number, requestParameters.review, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a note for review
     * @param {ReviewApiUpdateReviewNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReviewNote(requestParameters: ReviewApiUpdateReviewNoteRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReviewNote(requestParameters.reviewUuid, requestParameters.note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update list of reviews
     * @summary Update list of reviews
     * @param {ReviewApiUpdateReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReviews(requestParameters: ReviewApiUpdateReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReviews(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.reviews, requestParameters.modes, requestParameters.uploadMetadata, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update status of existing reviews
     * @summary Update status of existing reviews
     * @param {ReviewApiUpdateReviewsStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public updateReviewsStatus(requestParameters: ReviewApiUpdateReviewsStatusRequest, options?: AxiosRequestConfig) {
        return ReviewApiFp(this.configuration).updateReviewsStatus(requestParameters.colleagueUuid, requestParameters.cycleUuid, requestParameters.code, requestParameters.status, requestParameters.updateReviewsStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewSharingApi - axios parameter creator
 * @export
 */
export const ReviewSharingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared reviews by their manager
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedReviewsForColleague: async (colleagueUuid: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('getSharedReviewsForColleague', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getSharedReviewsForColleague', 'code', code)
            const localVarPath = `/colleagues/{colleagueUuid}/review-codes/{code}/sharing`
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if colleague reviews is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isColleagueShareReviews: async (cycleUuid: string, colleagueUuid: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('isColleagueShareReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('isColleagueShareReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('isColleagueShareReviews', 'code', code)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareReviews: async (cycleUuid: string, colleagueUuid: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('shareReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('shareReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('shareReviews', 'code', code)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop sharing colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSharingReviews: async (cycleUuid: string, colleagueUuid: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cycleUuid' is not null or undefined
            assertParamExists('stopSharingReviews', 'cycleUuid', cycleUuid)
            // verify required parameter 'colleagueUuid' is not null or undefined
            assertParamExists('stopSharingReviews', 'colleagueUuid', colleagueUuid)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('stopSharingReviews', 'code', code)
            const localVarPath = `/colleagues/{colleagueUuid}/pm-cycles/{cycleUuid}/review-codes/{code}/sharing`
                .replace(`{${"cycleUuid"}}`, encodeURIComponent(String(cycleUuid)))
                .replace(`{${"colleagueUuid"}}`, encodeURIComponent(String(colleagueUuid)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewSharingApi - functional programming interface
 * @export
 */
export const ReviewSharingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewSharingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all shared reviews by their manager
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedReviewsForColleague(colleagueUuid: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedReviewsForColleague(colleagueUuid, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if colleague reviews is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isColleagueShareReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isColleagueShareReviews(cycleUuid, colleagueUuid, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareReviews(cycleUuid, colleagueUuid, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop sharing colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopSharingReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopSharingReviews(cycleUuid, colleagueUuid, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewSharingApi - factory interface
 * @export
 */
export const ReviewSharingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewSharingApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all shared reviews by their manager
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedReviewsForColleague(colleagueUuid: string, code: string, options?: any): AxiosPromise<RestResponseListReview> {
            return localVarFp.getSharedReviewsForColleague(colleagueUuid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if colleague reviews is shared
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isColleagueShareReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: any): AxiosPromise<RestResponseBoolean> {
            return localVarFp.isColleagueShareReviews(cycleUuid, colleagueUuid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.shareReviews(cycleUuid, colleagueUuid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop sharing colleague reviews
         * @param {string} cycleUuid 
         * @param {string} colleagueUuid 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSharingReviews(cycleUuid: string, colleagueUuid: string, code: string, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp.stopSharingReviews(cycleUuid, colleagueUuid, code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSharedReviewsForColleague operation in ReviewSharingApi.
 * @export
 * @interface ReviewSharingApiGetSharedReviewsForColleagueRequest
 */
export interface ReviewSharingApiGetSharedReviewsForColleagueRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiGetSharedReviewsForColleague
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiGetSharedReviewsForColleague
     */
    readonly code: string
}

/**
 * Request parameters for isColleagueShareReviews operation in ReviewSharingApi.
 * @export
 * @interface ReviewSharingApiIsColleagueShareReviewsRequest
 */
export interface ReviewSharingApiIsColleagueShareReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiIsColleagueShareReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiIsColleagueShareReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiIsColleagueShareReviews
     */
    readonly code: string
}

/**
 * Request parameters for shareReviews operation in ReviewSharingApi.
 * @export
 * @interface ReviewSharingApiShareReviewsRequest
 */
export interface ReviewSharingApiShareReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiShareReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiShareReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiShareReviews
     */
    readonly code: string
}

/**
 * Request parameters for stopSharingReviews operation in ReviewSharingApi.
 * @export
 * @interface ReviewSharingApiStopSharingReviewsRequest
 */
export interface ReviewSharingApiStopSharingReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiStopSharingReviews
     */
    readonly cycleUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiStopSharingReviews
     */
    readonly colleagueUuid: string

    /**
     * 
     * @type {string}
     * @memberof ReviewSharingApiStopSharingReviews
     */
    readonly code: string
}

/**
 * ReviewSharingApi - object-oriented interface
 * @export
 * @class ReviewSharingApi
 * @extends {BaseAPI}
 */
export class ReviewSharingApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared reviews by their manager
     * @param {ReviewSharingApiGetSharedReviewsForColleagueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSharingApi
     */
    public getSharedReviewsForColleague(requestParameters: ReviewSharingApiGetSharedReviewsForColleagueRequest, options?: AxiosRequestConfig) {
        return ReviewSharingApiFp(this.configuration).getSharedReviewsForColleague(requestParameters.colleagueUuid, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if colleague reviews is shared
     * @param {ReviewSharingApiIsColleagueShareReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSharingApi
     */
    public isColleagueShareReviews(requestParameters: ReviewSharingApiIsColleagueShareReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewSharingApiFp(this.configuration).isColleagueShareReviews(requestParameters.cycleUuid, requestParameters.colleagueUuid, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share colleague reviews
     * @param {ReviewSharingApiShareReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSharingApi
     */
    public shareReviews(requestParameters: ReviewSharingApiShareReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewSharingApiFp(this.configuration).shareReviews(requestParameters.cycleUuid, requestParameters.colleagueUuid, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop sharing colleague reviews
     * @param {ReviewSharingApiStopSharingReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSharingApi
     */
    public stopSharingReviews(requestParameters: ReviewSharingApiStopSharingReviewsRequest, options?: AxiosRequestConfig) {
        return ReviewSharingApiFp(this.configuration).stopSharingReviews(requestParameters.cycleUuid, requestParameters.colleagueUuid, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpringRestEventListenerApi - axios parameter creator
 * @export
 */
export const SpringRestEventListenerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handle: async (event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('handle', 'event', event)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpringRestEventListenerApi - functional programming interface
 * @export
 */
export const SpringRestEventListenerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpringRestEventListenerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handle(event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handle(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpringRestEventListenerApi - factory interface
 * @export
 */
export const SpringRestEventListenerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpringRestEventListenerApiFp(configuration)
    return {
        /**
         * 
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handle(event: Event, options?: any): AxiosPromise<void> {
            return localVarFp.handle(event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for handle operation in SpringRestEventListenerApi.
 * @export
 * @interface SpringRestEventListenerApiHandleRequest
 */
export interface SpringRestEventListenerApiHandleRequest {
    /**
     * 
     * @type {Event}
     * @memberof SpringRestEventListenerApiHandle
     */
    readonly event: Event
}

/**
 * SpringRestEventListenerApi - object-oriented interface
 * @export
 * @class SpringRestEventListenerApi
 * @extends {BaseAPI}
 */
export class SpringRestEventListenerApi extends BaseAPI {
    /**
     * 
     * @param {SpringRestEventListenerApiHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpringRestEventListenerApi
     */
    public handle(requestParameters: SpringRestEventListenerApiHandleRequest, options?: AxiosRequestConfig) {
        return SpringRestEventListenerApiFp(this.configuration).handle(requestParameters.event, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TipApi - axios parameter creator
 * @export
 */
export const TipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (uuid: string, withHistory?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('_delete', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withHistory !== undefined) {
                localVarQueryParameter['withHistory'] = withHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (tip: Tip, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tip' is not null or undefined
            assertParamExists('create', 'tip', tip)
            const localVarPath = `/tips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tip, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish1: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('publish1', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}/publish`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (requestQuery: RequestQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestQuery' is not null or undefined
            assertParamExists('read', 'requestQuery', requestQuery)
            const localVarPath = `/tips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestQuery !== undefined) {
                localVarQueryParameter['requestQuery'] = requestQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read1: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('read1', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHistory: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('readHistory', 'uuid', uuid)
            const localVarPath = `/tips/{uuid}/history`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipApi - functional programming interface
 * @export
 */
export const TipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TipApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(uuid: string, withHistory?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(uuid, withHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(tip: Tip, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(tip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish1(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish1(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(requestQuery: RequestQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(requestQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read1(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read1(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readHistory(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseListTip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readHistory(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TipApi - factory interface
 * @export
 */
export const TipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TipApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an existing Tip
         * @param {string} uuid 
         * @param {boolean} [withHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(uuid: string, withHistory?: boolean, options?: any): AxiosPromise<RestResponseVoid> {
            return localVarFp._delete(uuid, withHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tip or create a new version of an existing tip
         * @param {Tip} tip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(tip: Tip, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.create(tip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish tip
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish1(uuid: string, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.publish1(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tips
         * @param {RequestQuery} requestQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(requestQuery: RequestQuery, options?: any): AxiosPromise<RestResponseListTip> {
            return localVarFp.read(requestQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tip by uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read1(uuid: string, options?: any): AxiosPromise<RestResponseTip> {
            return localVarFp.read1(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tip history
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHistory(uuid: string, options?: any): AxiosPromise<RestResponseListTip> {
            return localVarFp.readHistory(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in TipApi.
 * @export
 * @interface TipApiDeleteRequest
 */
export interface TipApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TipApiDelete
     */
    readonly uuid: string

    /**
     * 
     * @type {boolean}
     * @memberof TipApiDelete
     */
    readonly withHistory?: boolean
}

/**
 * Request parameters for create operation in TipApi.
 * @export
 * @interface TipApiCreateRequest
 */
export interface TipApiCreateRequest {
    /**
     * 
     * @type {Tip}
     * @memberof TipApiCreate
     */
    readonly tip: Tip
}

/**
 * Request parameters for publish1 operation in TipApi.
 * @export
 * @interface TipApiPublish1Request
 */
export interface TipApiPublish1Request {
    /**
     * 
     * @type {string}
     * @memberof TipApiPublish1
     */
    readonly uuid: string
}

/**
 * Request parameters for read operation in TipApi.
 * @export
 * @interface TipApiReadRequest
 */
export interface TipApiReadRequest {
    /**
     * 
     * @type {RequestQuery}
     * @memberof TipApiRead
     */
    readonly requestQuery: RequestQuery
}

/**
 * Request parameters for read1 operation in TipApi.
 * @export
 * @interface TipApiRead1Request
 */
export interface TipApiRead1Request {
    /**
     * 
     * @type {string}
     * @memberof TipApiRead1
     */
    readonly uuid: string
}

/**
 * Request parameters for readHistory operation in TipApi.
 * @export
 * @interface TipApiReadHistoryRequest
 */
export interface TipApiReadHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof TipApiReadHistory
     */
    readonly uuid: string
}

/**
 * TipApi - object-oriented interface
 * @export
 * @class TipApi
 * @extends {BaseAPI}
 */
export class TipApi extends BaseAPI {
    /**
     * 
     * @summary Delete an existing Tip
     * @param {TipApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public _delete(requestParameters: TipApiDeleteRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration)._delete(requestParameters.uuid, requestParameters.withHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tip or create a new version of an existing tip
     * @param {TipApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public create(requestParameters: TipApiCreateRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).create(requestParameters.tip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish tip
     * @param {TipApiPublish1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public publish1(requestParameters: TipApiPublish1Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).publish1(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tips
     * @param {TipApiReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public read(requestParameters: TipApiReadRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).read(requestParameters.requestQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tip by uuid
     * @param {TipApiRead1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public read1(requestParameters: TipApiRead1Request, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).read1(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tip history
     * @param {TipApiReadHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipApi
     */
    public readHistory(requestParameters: TipApiReadHistoryRequest, options?: AxiosRequestConfig) {
        return TipApiFp(this.configuration).readHistory(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get user info for current authenticated user
         * @summary Get me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<RestResponseUser> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get user info for current authenticated user
     * @summary Get me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }
}


